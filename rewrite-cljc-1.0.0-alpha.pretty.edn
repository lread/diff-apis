{:group-id "lread",
 :artifact-id "rewrite-cljs-playground",
 :version "1.0.0-alpha",
 :analysis {"clj" ({:doc "APIs to navigate and update Clojure/ClojureScript/EDN source code.\n\nStart with the [[rewrite-clj.parser]] or [[rewrite-clj.zip]] to ingest your source code,\nthen use the [[rewrite-clj.zip]] to navigate and/or change it. [[rewrite-clj.node]]\nwill help you to work with nodes in the zipper tree.\n\n[[rewrite-clj.paredit]] first appeared in the ClojureScript only version of\nrewrite-clj and supports structured editing of the zipper tree.",
                 :name rewrite-clj,
                 :publics ()}
                {:doc "Functional hierarchical zipper, with navigation, editing,\nand enumeration.  See Huet.\nModified to optionally support row col position tracking.",
                 :author "Rich Hickey",
                 :no-doc true,
                 :name rewrite-clj.custom-zipper.core,
                 :publics ({:name append-child,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 219,
                            :arglists ([zloc item]),
                            :doc "Returns zipper with `item` inserted as the rightmost child of the current node in `zloc`,\nwithout moving.",
                            :type :var}
                           {:name branch?,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 56,
                            :arglists ([zloc]),
                            :doc "Returns true if the current node in `zloc` is a branch.\n",
                            :type :var}
                           {:name children,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 61,
                            :arglists ([{:keys [node], :as zloc}]),
                            :doc "Returns a seq of the children of current node in `zloc`, which must be a branch.\n",
                            :type :var}
                           {:name custom-zipper,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 28,
                            :arglists ([root]),
                            :no-doc true,
                            :type :var}
                           {:name custom-zipper?,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 45,
                            :arglists ([value]),
                            :no-doc true,
                            :type :var}
                           {:name down,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 96,
                            :arglists ([zloc]),
                            :doc "Returns zipper with the location at the leftmost child of current node in `zloc`, or\nnil if no children.",
                            :type :var}
                           {:name edit,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 206,
                            :arglists ([zloc f & args]),
                            :doc "Returns zipper with value of `(f current-node args)` replacing current node in `zloc`\n",
                            :type :var}
                           {:name end?,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 251,
                            :arglists ([zloc]),
                            :doc "Returns true if at end of depth-first walk in `zloc`.\n",
                            :type :var}
                           {:name insert-child,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 213,
                            :arglists ([zloc item]),
                            :doc "Returns zipper with `item` inserted as the leftmost child of the current node in `zloc`,\nwithout moving location.",
                            :type :var}
                           {:name insert-left,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 178,
                            :arglists ([zloc item]),
                            :doc "Returns zipper with `item` inserted as the left sibling of current node in `zloc`,\nwithout moving location.",
                            :type :var}
                           {:name insert-right,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 190,
                            :arglists ([zloc item]),
                            :doc "Returns zipper with `item` inserted as the right sibling of the current node in `zloc`,\nwithout moving location.",
                            :type :var}
                           {:name left,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 153,
                            :arglists ([zloc]),
                            :doc "Returns zipper with location at the left sibling of the current node in `zloc`, or nil.\n",
                            :type :var}
                           {:name leftmost,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 165,
                            :arglists ([zloc]),
                            :doc "Returns zipper with location at the leftmost sibling of the current node in `zloc`, or self.\n",
                            :type :var}
                           {:name lefts,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 91,
                            :arglists ([zloc]),
                            :doc "Returns a seq of the left siblings of current node in `zloc`.\n",
                            :type :var}
                           {:name make-node,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 68,
                            :arglists ([_zloc node children]),
                            :doc "Returns a new branch node, given an existing `node` and new\n`children`. ",
                            :no-doc true,
                            :type :var}
                           {:name next,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 225,
                            :arglists ([{:keys [end?], :as zloc}]),
                            :doc "Returns zipper with location at the next depth-first location in the hierarchy in `zloc`.\nWhen reaching the end, returns a distinguished zipper detectable via [[end?]]. If already\nat the end, stays there.",
                            :type :var}
                           {:name node,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 51,
                            :arglists ([zloc]),
                            :doc "Returns the current node in `zloc`.\n",
                            :type :var}
                           {:name position,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 74,
                            :arglists ([zloc]),
                            :doc "Returns the ones-based `[row col]` of the start of the current node in `zloc`.\n",
                            :type :var}
                           {:name position-span,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 84,
                            :arglists ([zloc]),
                            :doc "Returns the ones-based `[[start-row start-col] [end-row end-col]]` of the current node in `zloc`.\n",
                            :type :var}
                           {:name prev,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 240,
                            :arglists ([zloc]),
                            :doc "Returns zipper with location at the previous depth-first location in the hierarchy in `zloc`.\nIf already at the root, returns nil.",
                            :type :var}
                           {:name remove,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 256,
                            :arglists ([zloc]),
                            :doc "Returns zipper with current node in `zloc` removed, with location at node that would have preceded\nit in a depth-first walk.",
                            :type :var}
                           {:name replace,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 201,
                            :arglists ([zloc node]),
                            :doc "Returns zipper with `node` replacing current node in `zloc`, without moving location.\n",
                            :type :var}
                           {:name right,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 135,
                            :arglists ([zloc]),
                            :doc "Returns zipper with location at the right sibling of the current node in `zloc`, or nil.\n",
                            :type :var}
                           {:name rightmost,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 146,
                            :arglists ([zloc]),
                            :doc "Returns zipper with location at the rightmost sibling of the current node in `zloc`, or self.\n",
                            :type :var}
                           {:name root,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 125,
                            :arglists ([{:keys [end?], :as zloc}]),
                            :doc "Zips all the way up `zloc` and returns zipper at the root node, reflecting any changes.\n",
                            :type :var}
                           {:name up,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 111,
                            :arglists ([zloc]),
                            :doc "Returns zipper with the location at the parent of current node in `zloc`, or nil if at\nthe top.",
                            :type :var}
                           {:name zipper,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 37,
                            :arglists ([root]),
                            :no-doc true,
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.custom-zipper.switchable,
                 :publics ({:name custom-zipper?,
                            :file "rewrite_clj/custom_zipper/switchable.cljc",
                            :line 4,
                            :arglists ([value]),
                            :no-doc true,
                            :type :var}
                           {:name defn-switchable,
                            :file "rewrite_clj/custom_zipper/switchable.cljc",
                            :line 8,
                            :arglists ([sym docstring params & body]),
                            :type :macro})}
                {:no-doc true,
                 :name rewrite-clj.custom-zipper.utils,
                 :publics ({:name remove-and-move-left,
                            :file "rewrite_clj/custom_zipper/utils.cljc",
                            :line 62,
                            :arglists ([loc]),
                            :doc "Remove current node and move left. If current node is at the leftmost\nlocation, returns `nil`.",
                            :type :var}
                           {:name remove-and-move-right,
                            :file "rewrite_clj/custom_zipper/utils.cljc",
                            :line 83,
                            :arglists ([loc]),
                            :doc "Remove current node and move right. If current node is at the rightmost\nlocation, returns `nil`.",
                            :type :var}
                           {:name remove-and-move-up,
                            :file "rewrite_clj/custom_zipper/utils.cljc",
                            :line 104,
                            :arglists ([loc]),
                            :doc "Remove the current node and move up.\n`[a [b |c d]] -> [a |[b d]]`\n`[a [|b c d]] -> [a |[c d]]`",
                            :type :var}
                           {:name remove-left,
                            :file "rewrite_clj/custom_zipper/utils.cljc",
                            :line 25,
                            :arglists ([loc]),
                            :doc "Remove left sibling of the current node (if there is one).\n",
                            :type :var}
                           {:name remove-left-while,
                            :file "rewrite_clj/custom_zipper/utils.cljc",
                            :line 49,
                            :arglists ([zloc p?]),
                            :doc "Remove elements to the left of the current zipper location as long as\nthe given predicate matches.",
                            :type :var}
                           {:name remove-right,
                            :file "rewrite_clj/custom_zipper/utils.cljc",
                            :line 15,
                            :arglists ([loc]),
                            :doc "Remove right sibling of the current node (if there is one).\n",
                            :type :var}
                           {:name remove-right-while,
                            :file "rewrite_clj/custom_zipper/utils.cljc",
                            :line 38,
                            :arglists ([zloc p?]),
                            :doc "Remove elements to the right of the current zipper location as long as\nthe given predicate matches.",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.interop,
                 :publics ({:name clojure-whitespace?,
                            :file "rewrite_clj/interop.cljc",
                            :line 31,
                            :arglists ([c]),
                            :type :var}
                           {:name int->str,
                            :file "rewrite_clj/interop.cljc",
                            :line 18,
                            :arglists ([n base]),
                            :type :var}
                           {:name max-int,
                            :file "rewrite_clj/interop.cljc",
                            :line 27,
                            :arglists ([]),
                            :type :var}
                           {:name meta-available?,
                            :file "rewrite_clj/interop.cljc",
                            :line 36,
                            :arglists ([data]),
                            :type :var}
                           {:name min-int,
                            :file "rewrite_clj/interop.cljc",
                            :line 23,
                            :arglists ([]),
                            :type :var}
                           {:name simple-format,
                            :file "rewrite_clj/interop.cljc",
                            :line 5,
                            :arglists ([template & args]),
                            :doc "Interop version of string format\nNote that there a big differences between Java's format and Google Closure's format - we don't address them.\n%d and %s are known to work in both.",
                            :type :var}
                           {:name str->int,
                            :file "rewrite_clj/interop.cljc",
                            :line 13,
                            :arglists ([s]),
                            :type :var})}
                {:doc "Create and evaluate nodes.\n\nAll nodes represent Clojure/ClojureScript/EDN.",
                 :name rewrite-clj.node,
                 :publics ({:name child-sexprs,
                            :file "rewrite_clj/node/protocols.cljc",
                            :line 70,
                            :arglists ([node]),
                            :doc "Return all children converted to forms.\n",
                            :type :var}
                           {:name children,
                            :file "rewrite_clj/node.cljc",
                            :line 27,
                            :arglists ([node]),
                            :doc "Returns child nodes for `node`.\n",
                            :type :var}
                           {:name coerce,
                            :file "rewrite_clj/node.cljc",
                            :line 27,
                            :arglists ([form]),
                            :doc "Coerce `form` to node.\n",
                            :type :var}
                           {:name comma-node,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 86,
                            :arglists ([s]),
                            :doc "Create comma node of string `s`.\n",
                            :type :var}
                           {:name comma-separated,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 130,
                            :arglists ([nodes]),
                            :doc "Interleave `nodes` with `\", \"` nodes.\n",
                            :type :var}
                           {:name comma?,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 165,
                            :arglists ([node]),
                            :doc "Returns true if `node` represents a comma.\n",
                            :type :var}
                           {:name comment-node,
                            :file "rewrite_clj/node/comment.cljc",
                            :line 25,
                            :arglists ([s]),
                            :doc "Create node representing a comment with text `s`.\n",
                            :type :var}
                           {:name comment?,
                            :file "rewrite_clj/node/comment.cljc",
                            :line 31,
                            :arglists ([node]),
                            :doc "Returns true if `node` is a comment.\n",
                            :type :var}
                           {:name concat-strings,
                            :file "rewrite_clj/node/protocols.cljc",
                            :line 42,
                            :arglists ([nodes]),
                            :doc "Return string version of `nodes`.\n",
                            :no-doc true,
                            :type :var}
                           {:name deref-node,
                            :file "rewrite_clj/node/reader_macro.cljc",
                            :line 130,
                            :arglists ([children]),
                            :doc "Create node representing the dereferencing of a form with `children`. (`@...`)\nTakes either a seq of nodes or a single one.",
                            :type :var}
                           {:name eval-node,
                            :file "rewrite_clj/node/reader_macro.cljc",
                            :line 112,
                            :arglists ([children]),
                            :doc "Create node representing an inline evaluation with `children`. (`#=...`)\nTakes either a seq of nodes or a single one.",
                            :type :var}
                           {:name fn-node,
                            :file "rewrite_clj/node/fn.cljc",
                            :line 94,
                            :arglists ([children]),
                            :doc "Create node representing an anonymous function with `children`.\n",
                            :type :var}
                           {:name forms-node,
                            :file "rewrite_clj/node/forms.cljc",
                            :line 40,
                            :arglists ([children]),
                            :doc "Create top-level node wrapping multiple `children`\n(equivalent to an implicit `do` on the top-level).",
                            :type :var}
                           {:name inner?,
                            :file "rewrite_clj/node.cljc",
                            :line 27,
                            :arglists ([node]),
                            :doc "Returns true if `node` can have children.\n",
                            :type :var}
                           {:name integer-node,
                            :file "rewrite_clj/node/integer.cljc",
                            :line 34,
                            :arglists ([value] [value base]),
                            :doc "Create node representing an integer `value` in `base`.\n\n`base` defaults to 10.",
                            :type :var}
                           {:name keyword-node,
                            :file "rewrite_clj/node/keyword.cljc",
                            :line 40,
                            :arglists ([k & [namespaced?]]),
                            :doc "Create node representing a keyword `k`. If `namespaced?` is `true`\na keyword à la `::x` or `::ns/x` (i.e. namespaced/aliased) is generated.",
                            :type :var}
                           {:name leader-length,
                            :file "rewrite_clj/node.cljc",
                            :line 27,
                            :arglists ([node]),
                            :doc "Returns number of characters before children for `node`.\n",
                            :type :var}
                           {:name length,
                            :file "rewrite_clj/node.cljc",
                            :line 27,
                            :arglists ([node]),
                            :doc "Return number of characters for the string version of `node`.\n",
                            :type :var}
                           {:name line-separated,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 138,
                            :arglists ([nodes]),
                            :doc "Interleave `nodes` with newline nodes.\n",
                            :type :var}
                           {:name linebreak?,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 160,
                            :arglists ([node]),
                            :doc "Returns true if `node` represents linebreak(s).\n",
                            :type :var}
                           {:name list-node,
                            :file "rewrite_clj/node/seq.cljc",
                            :line 42,
                            :arglists ([children]),
                            :doc "Create a node representing a list with `children`.\n",
                            :type :var}
                           {:name map-node,
                            :file "rewrite_clj/node/seq.cljc",
                            :line 57,
                            :arglists ([children]),
                            :doc "Create a node representing an map with `children`.\n",
                            :type :var}
                           {:name meta-node,
                            :file "rewrite_clj/node/meta.cljc",
                            :line 39,
                            :arglists ([children] [metadata data]),
                            :doc "Create node representing a form `data` and its `metadata`.\n",
                            :type :var}
                           {:name namespaced-map-node,
                            :file "rewrite_clj/node/namespaced_map.cljc",
                            :line 80,
                            :arglists ([children]),
                            :doc "Create a node representing a namespaced map. There are 3 types of namespaced maps:\n\n 1. prefix namespaced map\n The prefix is a keyword which specifies to a namespace.\n Example: `#:my.name.space{:a 1}`\n\n 2. auto-resolve alias namespaced map\n The prefix is an auto-resolve keyword specifies a namespace alias.\n Example: `#::ns-alias{:b 3}`\n\n 3. auto-resolve namespaced map\n The prefix is `::` which specifies the current namespace.\n Example: `#::{:c 4}`\n\nFirst child is the prefix, followed by optional whitespace then map node.\nTODO: this still seems hacky to me.\nPrefix must be a token-node with a keyword value. Use (keyword ':') for auto-resolve.",
                            :type :var}
                           {:name newline-node,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 92,
                            :arglists ([s]),
                            :doc "Create newline node of string `s`.\n",
                            :type :var}
                           {:name newlines,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 124,
                            :arglists ([n]),
                            :doc "Create node representing `n` newline characters.\n",
                            :type :var}
                           {:name printable-only?,
                            :file "rewrite_clj/node.cljc",
                            :line 27,
                            :arglists ([node]),
                            :doc "Return true if `node` cannot be converted to an s-expression element.\n",
                            :type :var}
                           {:name quote-node,
                            :file "rewrite_clj/node/quote.cljc",
                            :line 39,
                            :arglists ([children]),
                            :doc "Create node representing a quoted form with `children`.\nTakes either a seq of nodes or a single one.",
                            :type :var}
                           {:name raw-meta-node,
                            :file "rewrite_clj/node/meta.cljc",
                            :line 47,
                            :arglists ([children] [metadata data]),
                            :doc "Create node representing a form `data` and its `metadata` using the\n`#^` prefix.",
                            :type :var}
                           {:name reader-macro-node,
                            :file "rewrite_clj/node/reader_macro.cljc",
                            :line 123,
                            :arglists ([children]
                                       [macro-node form-node]),
                            :doc "Create node representing a reader macro with `children`. (`#... ...`)\n",
                            :type :var}
                           {:name regex-node,
                            :file "rewrite_clj/node/regex.cljc",
                            :line 19,
                            :arglists ([pattern-string]),
                            :doc "Create node representing a regex with `pattern-string`\n",
                            :type :var}
                           {:name replace-children,
                            :file "rewrite_clj/node.cljc",
                            :line 27,
                            :arglists ([node children]),
                            :doc "Returns `node` replacing current children with `children`.\n",
                            :type :var}
                           {:name set-node,
                            :file "rewrite_clj/node/seq.cljc",
                            :line 52,
                            :arglists ([children]),
                            :doc "Create a node representing a set with `children`.\n",
                            :type :var}
                           {:name sexpr,
                            :file "rewrite_clj/node.cljc",
                            :line 27,
                            :arglists ([node]),
                            :doc "Return `node` converted to form.\n",
                            :type :var}
                           {:name sexprs,
                            :file "rewrite_clj/node/protocols.cljc",
                            :line 30,
                            :arglists ([nodes]),
                            :doc "Return forms for `nodes`. Nodes that do not represent s-expression are skipped.\n",
                            :type :var}
                           {:name spaces,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 119,
                            :arglists ([n]),
                            :doc "Create node representing `n` spaces.\n",
                            :type :var}
                           {:name string,
                            :file "rewrite_clj/node.cljc",
                            :line 27,
                            :arglists ([node]),
                            :doc "Return the string version of `node`.\n",
                            :type :var}
                           {:name string-node,
                            :file "rewrite_clj/node/stringz.cljc",
                            :line 42,
                            :arglists ([lines]),
                            :doc "Create node representing a string value of `lines`.\n`lines` can be a seq of strings or a single one.",
                            :type :var}
                           {:name syntax-quote-node,
                            :file "rewrite_clj/node/quote.cljc",
                            :line 49,
                            :arglists ([children]),
                            :doc "Create node representing a syntax-quoted form with `children`.\nTakes either a seq of nodes or a single one.",
                            :type :var}
                           {:name tag,
                            :file "rewrite_clj/node.cljc",
                            :line 27,
                            :arglists ([node]),
                            :doc "Returns keyword representing type of `node`.\n",
                            :type :var}
                           {:name token-node,
                            :file "rewrite_clj/node/token.cljc",
                            :line 22,
                            :arglists ([value] [value string-value]),
                            :doc "Create node for an unspecified token of `value`.\n",
                            :type :var}
                           {:name uneval-node,
                            :file "rewrite_clj/node/uneval.cljc",
                            :line 34,
                            :arglists ([children]),
                            :doc "Create node representing an uneval `#_` form with `children`.\n",
                            :type :var}
                           {:name unquote-node,
                            :file "rewrite_clj/node/quote.cljc",
                            :line 59,
                            :arglists ([children]),
                            :doc "Create node representing an unquoted form with `children`. (`~...`)\nTakes either a seq of nodes or a single one.",
                            :type :var}
                           {:name unquote-splicing-node,
                            :file "rewrite_clj/node/quote.cljc",
                            :line 69,
                            :arglists ([children]),
                            :doc "Create node representing an unquote-spliced form with `children`. (`~@...`)\nTakes either a seq of nodes or a single one.",
                            :type :var}
                           {:name value,
                            :file "rewrite_clj/node.cljc",
                            :line 119,
                            :arglists ([node]),
                            :doc "DEPRECATED: Get first child as a pair of tag/sexpr (if inner node),\nor just the node's own sexpr. (use explicit analysis of `children`\n`child-sexprs` instead) ",
                            :deprecated "0.4.0",
                            :type :var}
                           {:name var-node,
                            :file "rewrite_clj/node/reader_macro.cljc",
                            :line 104,
                            :arglists ([children]),
                            :doc "Create node representing a var with `children`.\nTakes either a seq of nodes or a single one.",
                            :type :var}
                           {:name vector-node,
                            :file "rewrite_clj/node/seq.cljc",
                            :line 47,
                            :arglists ([children]),
                            :doc "Create a node representing a vector with `children`.\n",
                            :type :var}
                           {:name whitespace-node,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 80,
                            :arglists ([s]),
                            :doc "Create whitespace node of string `s`.\n",
                            :type :var}
                           {:name whitespace-nodes,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 104,
                            :arglists ([s]),
                            :doc "Convert string `s` of whitespace to whitespace/newline nodes.\n",
                            :type :var}
                           {:name whitespace-or-comment?,
                            :file "rewrite_clj/node.cljc",
                            :line 111,
                            :arglists ([node]),
                            :doc "Return true when `node` represents whitespace or comment.\n",
                            :type :var}
                           {:name whitespace?,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 151,
                            :arglists ([node]),
                            :doc "Returns true if `node represents whitespace.\n",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.node.coercer,
                 :publics ({:name node-with-meta,
                            :file "rewrite_clj/node/coercer.cljc",
                            :line 43,
                            :arglists ([n value]),
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.node.comment,
                 :publics ({:name comment-node,
                            :file "rewrite_clj/node/comment.cljc",
                            :line 25,
                            :arglists ([s]),
                            :doc "Create node representing a comment with text `s`.\n",
                            :type :var}
                           {:name comment?,
                            :file "rewrite_clj/node/comment.cljc",
                            :line 31,
                            :arglists ([node]),
                            :doc "Returns true if `node` is a comment.\n",
                            :type :var}
                           {:name CommentNode,
                            :file "rewrite_clj/node/comment.cljc",
                            :line 6,
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.node.fn,
                 :publics ({:name fn-node,
                            :file "rewrite_clj/node/fn.cljc",
                            :line 94,
                            :arglists ([children]),
                            :doc "Create node representing an anonymous function with `children`.\n",
                            :type :var}
                           {:name FnNode,
                            :file "rewrite_clj/node/fn.cljc",
                            :line 64,
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.node.forms,
                 :publics ({:name forms-node,
                            :file "rewrite_clj/node/forms.cljc",
                            :line 40,
                            :arglists ([children]),
                            :doc "Create top-level node wrapping multiple `children`\n(equivalent to an implicit `do` on the top-level).",
                            :type :var}
                           {:name FormsNode,
                            :file "rewrite_clj/node/forms.cljc",
                            :line 6,
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.node.indent,
                 :publics ({:name indent-spaces,
                            :file "rewrite_clj/node/indent.cljc",
                            :line 47,
                            :arglists ([node n]),
                            :type :var}
                           {:name indent-tabs,
                            :file "rewrite_clj/node/indent.cljc",
                            :line 52,
                            :arglists ([node n]),
                            :type :var}
                           {:name LinePrefixedNode,
                            :file "rewrite_clj/node/indent.cljc",
                            :line 19,
                            :type :var}
                           {:name prefix-lines,
                            :file "rewrite_clj/node/indent.cljc",
                            :line 43,
                            :arglists ([node prefix]),
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.node.integer,
                 :publics ({:name integer-node,
                            :file "rewrite_clj/node/integer.cljc",
                            :line 34,
                            :arglists ([value] [value base]),
                            :doc "Create node representing an integer `value` in `base`.\n\n`base` defaults to 10.",
                            :type :var}
                           {:name IntNode,
                            :file "rewrite_clj/node/integer.cljc",
                            :line 7,
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.node.keyword,
                 :publics ({:name keyword-node,
                            :file "rewrite_clj/node/keyword.cljc",
                            :line 40,
                            :arglists ([k & [namespaced?]]),
                            :doc "Create node representing a keyword `k`. If `namespaced?` is `true`\na keyword à la `::x` or `::ns/x` (i.e. namespaced/aliased) is generated.",
                            :type :var}
                           {:name KeywordNode,
                            :file "rewrite_clj/node/keyword.cljc",
                            :line 10,
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.node.meta,
                 :publics ({:name meta-node,
                            :file "rewrite_clj/node/meta.cljc",
                            :line 39,
                            :arglists ([children] [metadata data]),
                            :doc "Create node representing a form `data` and its `metadata`.\n",
                            :type :var}
                           {:name MetaNode,
                            :file "rewrite_clj/node/meta.cljc",
                            :line 8,
                            :type :var}
                           {:name raw-meta-node,
                            :file "rewrite_clj/node/meta.cljc",
                            :line 47,
                            :arglists ([children] [metadata data]),
                            :doc "Create node representing a form `data` and its `metadata` using the\n`#^` prefix.",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.node.namespaced-map,
                 :publics ({:name namespaced-map-node,
                            :file "rewrite_clj/node/namespaced_map.cljc",
                            :line 80,
                            :arglists ([children]),
                            :doc "Create a node representing a namespaced map. There are 3 types of namespaced maps:\n\n 1. prefix namespaced map\n The prefix is a keyword which specifies to a namespace.\n Example: `#:my.name.space{:a 1}`\n\n 2. auto-resolve alias namespaced map\n The prefix is an auto-resolve keyword specifies a namespace alias.\n Example: `#::ns-alias{:b 3}`\n\n 3. auto-resolve namespaced map\n The prefix is `::` which specifies the current namespace.\n Example: `#::{:c 4}`\n\nFirst child is the prefix, followed by optional whitespace then map node.\nTODO: this still seems hacky to me.\nPrefix must be a token-node with a keyword value. Use (keyword ':') for auto-resolve.",
                            :type :var}
                           {:name NamespacedMapNode,
                            :file "rewrite_clj/node/namespaced_map.cljc",
                            :line 44,
                            :type :var})}
                {:added "0.4.0",
                 :no-doc true,
                 :name rewrite-clj.node.protocols,
                 :publics ({:name +extent,
                            :file "rewrite_clj/node/protocols.cljc",
                            :line 162,
                            :arglists ([[row col]
                                        [row-extent col-extent]]),
                            :no-doc true,
                            :type :var}
                           {:name assert-sexpr-count,
                            :file "rewrite_clj/node/protocols.cljc",
                            :line 123,
                            :arglists ([nodes c]),
                            :no-doc true,
                            :type :var}
                           {:name assert-single-sexpr,
                            :file "rewrite_clj/node/protocols.cljc",
                            :line 130,
                            :arglists ([nodes]),
                            :no-doc true,
                            :type :var}
                           {:name child-sexprs,
                            :file "rewrite_clj/node/protocols.cljc",
                            :line 70,
                            :arglists ([node]),
                            :doc "Return all children converted to forms.\n",
                            :type :var}
                           {:name concat-strings,
                            :file "rewrite_clj/node/protocols.cljc",
                            :line 42,
                            :arglists ([nodes]),
                            :doc "Return string version of `nodes`.\n",
                            :no-doc true,
                            :type :var}
                           {:name extent,
                            :file "rewrite_clj/node/protocols.cljc",
                            :line 134,
                            :arglists ([node]),
                            :doc "A node's extent is how far it moves the \"cursor\".\nRows are simple - if we have x newlines in the string representation, we\nwill always move the \"cursor\" x rows.\nColumns are strange.  If we have *any* newlines at all in the textual\nrepresentation of a node, following nodes' column positions are not\naffected by our startting column position at all.  So the second number\nin the pair we return is interpreted as a relative column adjustment\nwhen the first number in the pair (rows) is zero, and as an absolute\ncolumn position when rows is non-zero.",
                            :no-doc true,
                            :type :var}
                           {:name InnerNode,
                            :file "rewrite_clj/node/protocols.cljc",
                            :line 49,
                            :doc "Protocol for non-leaf EDN/Clojure/ClojureScript nodes.\n",
                            :type :protocol,
                            :members ({:name children,
                                       :arglists ([node]),
                                       :doc "Returns child nodes for `node`.\n",
                                       :type :var}
                                      {:name inner?,
                                       :arglists ([node]),
                                       :doc "Returns true if `node` can have children.\n",
                                       :type :var}
                                      {:name leader-length,
                                       :arglists ([node]),
                                       :doc "Returns number of characters before children for `node`.\n",
                                       :type :var}
                                      {:name replace-children,
                                       :arglists ([node children]),
                                       :doc "Returns `node` replacing current children with `children`.\n",
                                       :type :var})}
                           {:name make-printable!,
                            :file "rewrite_clj/node/protocols.cljc",
                            :line 113,
                            :arglists ([obj]),
                            :type :var}
                           {:name make-printable-clj!,
                            :file "rewrite_clj/node/protocols.cljc",
                            :line 100,
                            :arglists ([class]),
                            :no-doc true,
                            :type :macro}
                           {:name Node,
                            :file "rewrite_clj/node/protocols.cljc",
                            :line 9,
                            :doc "Protocol for EDN/Clojure/ClojureScript nodes.\n",
                            :type :protocol,
                            :members ({:name length,
                                       :arglists ([node]),
                                       :doc "Return number of characters for the string version of `node`.\n",
                                       :type :var}
                                      {:name printable-only?,
                                       :arglists ([node]),
                                       :doc "Return true if `node` cannot be converted to an s-expression element.\n",
                                       :type :var}
                                      {:name sexpr,
                                       :arglists ([node]),
                                       :doc "Return `node` converted to form.\n",
                                       :type :var}
                                      {:name string,
                                       :arglists ([node]),
                                       :doc "Return the string version of `node`.\n",
                                       :type :var}
                                      {:name tag,
                                       :arglists ([node]),
                                       :doc "Returns keyword representing type of `node`.\n",
                                       :type :var})}
                           {:name NodeCoerceable,
                            :file "rewrite_clj/node/protocols.cljc",
                            :line 78,
                            :doc "Protocol for values that can be coerced to nodes.\n",
                            :type :protocol,
                            :members ({:name coerce,
                                       :arglists ([form]),
                                       :doc "Coerce `form` to node.\n",
                                       :type :var})}
                           {:name sexprs,
                            :file "rewrite_clj/node/protocols.cljc",
                            :line 30,
                            :arglists ([nodes]),
                            :doc "Return forms for `nodes`. Nodes that do not represent s-expression are skipped.\n",
                            :type :var}
                           {:name sum-lengths,
                            :file "rewrite_clj/node/protocols.cljc",
                            :line 37,
                            :arglists ([nodes]),
                            :doc "Return total string length for `nodes`.\n",
                            :no-doc true,
                            :type :var}
                           {:name without-whitespace,
                            :file "rewrite_clj/node/protocols.cljc",
                            :line 119,
                            :arglists ([nodes]),
                            :no-doc true,
                            :type :var}
                           {:name write-node,
                            :file "rewrite_clj/node/protocols.cljc",
                            :line 95,
                            :arglists ([writer node]),
                            :no-doc true,
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.node.quote,
                 :publics ({:name quote-node,
                            :file "rewrite_clj/node/quote.cljc",
                            :line 39,
                            :arglists ([children]),
                            :doc "Create node representing a quoted form with `children`.\nTakes either a seq of nodes or a single one.",
                            :type :var}
                           {:name QuoteNode,
                            :file "rewrite_clj/node/quote.cljc",
                            :line 6,
                            :type :var}
                           {:name syntax-quote-node,
                            :file "rewrite_clj/node/quote.cljc",
                            :line 49,
                            :arglists ([children]),
                            :doc "Create node representing a syntax-quoted form with `children`.\nTakes either a seq of nodes or a single one.",
                            :type :var}
                           {:name unquote-node,
                            :file "rewrite_clj/node/quote.cljc",
                            :line 59,
                            :arglists ([children]),
                            :doc "Create node representing an unquoted form with `children`. (`~...`)\nTakes either a seq of nodes or a single one.",
                            :type :var}
                           {:name unquote-splicing-node,
                            :file "rewrite_clj/node/quote.cljc",
                            :line 69,
                            :arglists ([children]),
                            :doc "Create node representing an unquote-spliced form with `children`. (`~@...`)\nTakes either a seq of nodes or a single one.",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.node.reader-macro,
                 :publics ({:name deref-node,
                            :file "rewrite_clj/node/reader_macro.cljc",
                            :line 130,
                            :arglists ([children]),
                            :doc "Create node representing the dereferencing of a form with `children`. (`@...`)\nTakes either a seq of nodes or a single one.",
                            :type :var}
                           {:name DerefNode,
                            :file "rewrite_clj/node/reader_macro.cljc",
                            :line 64,
                            :type :var}
                           {:name eval-node,
                            :file "rewrite_clj/node/reader_macro.cljc",
                            :line 112,
                            :arglists ([children]),
                            :doc "Create node representing an inline evaluation with `children`. (`#=...`)\nTakes either a seq of nodes or a single one.",
                            :type :var}
                           {:name reader-macro-node,
                            :file "rewrite_clj/node/reader_macro.cljc",
                            :line 123,
                            :arglists ([children]
                                       [macro-node form-node]),
                            :doc "Create node representing a reader macro with `children`. (`#... ...`)\n",
                            :type :var}
                           {:name ReaderMacroNode,
                            :file "rewrite_clj/node/reader_macro.cljc",
                            :line 39,
                            :type :var}
                           {:name ReaderNode,
                            :file "rewrite_clj/node/reader_macro.cljc",
                            :line 7,
                            :type :var}
                           {:name var-node,
                            :file "rewrite_clj/node/reader_macro.cljc",
                            :line 104,
                            :arglists ([children]),
                            :doc "Create node representing a var with `children`.\nTakes either a seq of nodes or a single one.",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.node.regex,
                 :publics ({:name regex-node,
                            :file "rewrite_clj/node/regex.cljc",
                            :line 19,
                            :arglists ([pattern-string]),
                            :doc "Create node representing a regex with `pattern-string`\n",
                            :type :var}
                           {:name RegexNode,
                            :file "rewrite_clj/node/regex.cljc",
                            :line 7,
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.node.seq,
                 :publics ({:name list-node,
                            :file "rewrite_clj/node/seq.cljc",
                            :line 42,
                            :arglists ([children]),
                            :doc "Create a node representing a list with `children`.\n",
                            :type :var}
                           {:name map-node,
                            :file "rewrite_clj/node/seq.cljc",
                            :line 57,
                            :arglists ([children]),
                            :doc "Create a node representing an map with `children`.\n",
                            :type :var}
                           {:name SeqNode,
                            :file "rewrite_clj/node/seq.cljc",
                            :line 7,
                            :type :var}
                           {:name set-node,
                            :file "rewrite_clj/node/seq.cljc",
                            :line 52,
                            :arglists ([children]),
                            :doc "Create a node representing a set with `children`.\n",
                            :type :var}
                           {:name vector-node,
                            :file "rewrite_clj/node/seq.cljc",
                            :line 47,
                            :arglists ([children]),
                            :doc "Create a node representing a vector with `children`.\n",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.node.string,
                 :publics ({:name string-node,
                            :file "rewrite_clj/node/stringz.cljc",
                            :line 42,
                            :arglists ([lines]),
                            :doc "Create node representing a string value of `lines`.\n`lines` can be a seq of strings or a single one.",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.node.stringz,
                 :publics ({:name string-node,
                            :file "rewrite_clj/node/stringz.cljc",
                            :line 42,
                            :arglists ([lines]),
                            :doc "Create node representing a string value of `lines`.\n`lines` can be a seq of strings or a single one.",
                            :type :var}
                           {:name StringNode,
                            :file "rewrite_clj/node/stringz.cljc",
                            :line 16,
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.node.token,
                 :publics ({:name token-node,
                            :file "rewrite_clj/node/token.cljc",
                            :line 22,
                            :arglists ([value] [value string-value]),
                            :doc "Create node for an unspecified token of `value`.\n",
                            :type :var}
                           {:name TokenNode,
                            :file "rewrite_clj/node/token.cljc",
                            :line 6,
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.node.uneval,
                 :publics ({:name uneval-node,
                            :file "rewrite_clj/node/uneval.cljc",
                            :line 34,
                            :arglists ([children]),
                            :doc "Create node representing an uneval `#_` form with `children`.\n",
                            :type :var}
                           {:name UnevalNode,
                            :file "rewrite_clj/node/uneval.cljc",
                            :line 6,
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.node.whitespace,
                 :publics ({:name *count-fn*,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 12,
                            :doc "This function is applied to every newline string and should produce\nthe eventual character count.",
                            :dynamic true,
                            :type :var}
                           {:name *newline-fn*,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 8,
                            :doc "This function is applied to every newline string.\n",
                            :dynamic true,
                            :type :var}
                           {:name comma-node,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 86,
                            :arglists ([s]),
                            :doc "Create comma node of string `s`.\n",
                            :type :var}
                           {:name comma-separated,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 130,
                            :arglists ([nodes]),
                            :doc "Interleave `nodes` with `\", \"` nodes.\n",
                            :type :var}
                           {:name comma?,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 165,
                            :arglists ([node]),
                            :doc "Returns true if `node` represents a comma.\n",
                            :type :var}
                           {:name CommaNode,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 43,
                            :type :var}
                           {:name line-separated,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 138,
                            :arglists ([nodes]),
                            :doc "Interleave `nodes` with newline nodes.\n",
                            :type :var}
                           {:name linebreak?,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 160,
                            :arglists ([node]),
                            :doc "Returns true if `node` represents linebreak(s).\n",
                            :type :var}
                           {:name newline-node,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 92,
                            :arglists ([s]),
                            :doc "Create newline node of string `s`.\n",
                            :type :var}
                           {:name NewlineNode,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 55,
                            :type :var}
                           {:name newlines,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 124,
                            :arglists ([n]),
                            :doc "Create node representing `n` newline characters.\n",
                            :type :var}
                           {:name space-separated,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 144,
                            :arglists ([nodes]),
                            :doc "Interleave `nodes` with `\" \"` nodes.\n",
                            :type :var}
                           {:name spaces,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 119,
                            :arglists ([n]),
                            :doc "Create node representing `n` spaces.\n",
                            :type :var}
                           {:name whitespace-node,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 80,
                            :arglists ([s]),
                            :doc "Create whitespace node of string `s`.\n",
                            :type :var}
                           {:name whitespace-nodes,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 104,
                            :arglists ([s]),
                            :doc "Convert string `s` of whitespace to whitespace/newline nodes.\n",
                            :type :var}
                           {:name whitespace?,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 151,
                            :arglists ([node]),
                            :doc "Returns true if `node represents whitespace.\n",
                            :type :var}
                           {:name WhitespaceNode,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 31,
                            :type :var}
                           {:name with-count-fn,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 24,
                            :arglists ([f & body]),
                            :type :macro}
                           {:name with-newline-fn,
                            :file "rewrite_clj/node/whitespace.cljc",
                            :line 18,
                            :arglists ([f & body]),
                            :type :macro})}
                {:doc "Paredit zipper operations for Clojure/ClojureScript/EDN.\n\nYou might find inspiration from examples here: http://pub.gajendra.net/src/paredit-refcard.pdf",
                 :name rewrite-clj.paredit,
                 :publics ({:name barf-backward,
                            :file "rewrite_clj/paredit.cljc",
                            :line 339,
                            :arglists ([zloc]),
                            :doc "Push out the leftmost node of the current S-expression into outer left form\n\n- `[1 2 [3 |4] 5] => [1 2 3 [|4] 5]`",
                            :type :var}
                           {:name barf-forward,
                            :file "rewrite_clj/paredit.cljc",
                            :line 315,
                            :arglists ([zloc]),
                            :doc "Push out the rightmost node of the current S-expression into outer right form\n\n- `[1 2 [|3 4] 5] => [1 2 [|3] 4 5]`",
                            :type :var}
                           {:name join,
                            :file "rewrite_clj/paredit.cljc",
                            :line 499,
                            :arglists ([zloc]),
                            :doc "Join S-expression to the left and right of current loc. Also works for strings.\n\n- `[[1 2] |[3 4]] => [[1 2 3 4]]`\n- `[\"Hello \" | \"World\"] => [\"Hello World\"]",
                            :type :var}
                           {:name kill,
                            :file "rewrite_clj/paredit.cljc",
                            :line 82,
                            :arglists ([zloc]),
                            :doc "Kill all sibling nodes to the right of the current node in `zloc`.\n\n- [1 2| 3 4] => [1 2|]",
                            :type :var}
                           {:name kill-at-pos,
                            :file "rewrite_clj/paredit.cljc",
                            :line 127,
                            :arglists ([zloc pos]),
                            :doc "In string and comment aware kill\n\nPerform kill for given position `pos` Like [[kill]], but:\n\n- if inside string kills to end of string and stops there\n- If inside comment kills to end of line (not including linebreak!)\n\n`pos` should provide `{:row :col }` which are relative to the start of the given form the zipper represents\n`zloc` must be positioned at a node previous (given depth first) to the node at given pos",
                            :type :var}
                           {:name kill-one-at-pos,
                            :file "rewrite_clj/paredit.cljc",
                            :line 196,
                            :arglists ([zloc pos]),
                            :doc "In string and comment aware kill for one node/word at `pos` in `zloc`.\n\n- `(+ |100 100) => (+ |100)`\n- `(for |(bar do)) => (foo)`\n- `\"|hello world\" => \"| world\"`\n- ` ; |hello world => ;  |world`",
                            :type :var}
                           {:name move-n,
                            :file "rewrite_clj/paredit.cljc",
                            :line 19,
                            :arglists ([loc f n]),
                            :no-doc true,
                            :type :var}
                           {:name move-to-prev,
                            :file "rewrite_clj/paredit.cljc",
                            :line 528,
                            :arglists ([zloc]),
                            :doc "Move node at current location to the position of previous location given a depth first traversal\n\n  -  `(+ 1 (+ 2 |3) 4) => (+ 1 (+ |3 2) 4)`\n  - `(+ 1 (+ 2 3) |4) => (+ 1 (+ 2 3 |4))`\n\nreturns zloc after move or given zloc if a move isn't possible",
                            :type :var}
                           {:name raise,
                            :file "rewrite_clj/paredit.cljc",
                            :line 517,
                            :arglists ([zloc]),
                            :doc "Delete siblings and raise node at zloc one level up\n\n- `[1 [2 |3 4]] => [1 |3]`",
                            :type :var}
                           {:name slurp-backward,
                            :file "rewrite_clj/paredit.cljc",
                            :line 273,
                            :arglists ([zloc]),
                            :doc "Pull in prev left outer node (if none at first level, tries next etc) into\ncurrent S-expression\n\n- `[1 2 [|3] 4 5] => [1 [2 |3] 4 5]`",
                            :type :var}
                           {:name slurp-backward-fully,
                            :file "rewrite_clj/paredit.cljc",
                            :line 300,
                            :arglists ([zloc]),
                            :doc "Pull in all left outer-nodes into current S-expression, but only the ones at the same level\nas the the first one.\n\n- `[1 2 [|3] 4 5] => [[1 2 |3] 4 5]`",
                            :type :var}
                           {:name slurp-forward,
                            :file "rewrite_clj/paredit.cljc",
                            :line 235,
                            :arglists ([zloc]),
                            :doc "Pull in next right outer node (if none at first level, tries next etc) into\ncurrent S-expression\n\n- `[1 2 [|3] 4 5] => [1 2 [|3 4] 5]`",
                            :type :var}
                           {:name slurp-forward-fully,
                            :file "rewrite_clj/paredit.cljc",
                            :line 258,
                            :arglists ([zloc]),
                            :doc "Pull in all right outer-nodes into current S-expression, but only the ones at the same level\nas the the first one.\n\n- `[1 2 [|3] 4 5] => [1 2 [|3 4 5]]`",
                            :type :var}
                           {:name splice,
                            :file "rewrite_clj/paredit.cljc",
                            :line 385,
                            :doc "See rewrite-clj.zip/splice\n",
                            :type :var}
                           {:name splice-killing-backward,
                            :file "rewrite_clj/paredit.cljc",
                            :line 400,
                            :arglists ([zloc]),
                            :doc "Remove left siblings of current given node in S-Expression and unwrap remaining into enclosing S-expression\n\n- `(foo (let ((x 5)) |(sqrt n)) bar) => (foo (sqrt n) bar)`",
                            :type :var}
                           {:name splice-killing-forward,
                            :file "rewrite_clj/paredit.cljc",
                            :line 407,
                            :arglists ([zloc]),
                            :doc "Remove current given node and its right siblings in S-Expression and unwrap remaining into enclosing S-expression\n\n- `(a (b c |d e) f) => (a b |c f)`",
                            :type :var}
                           {:name split,
                            :file "rewrite_clj/paredit.cljc",
                            :line 419,
                            :arglists ([zloc]),
                            :doc "Split current s-sexpression in two at given node `zloc`\n\n-  `[1 2 |3 4 5] => [1 2 3] [4 5]`",
                            :type :var}
                           {:name split-at-pos,
                            :file "rewrite_clj/paredit.cljc",
                            :line 459,
                            :arglists ([zloc pos]),
                            :doc "In string aware split\n\nPerform split at given position `pos` Like split, but:\n\n- if inside string splits string into two strings\n\n`pos` should provide `{:row :col }` which are relative to the start of the given form the zipper represents\n`zloc` must be positioned at a node previous (given depth first) to the node at given pos",
                            :type :var}
                           {:name wrap-around,
                            :file "rewrite_clj/paredit.cljc",
                            :line 361,
                            :arglists ([zloc t]),
                            :doc "Wrap current node with a given type `t` (:vector, :list, :set, :map :fn)\n\n- `|123 => [|123] ; given :vector`\n- `|[1 [2]] => [|[1 [2]]]`",
                            :type :var}
                           {:name wrap-fully-forward-slurp,
                            :file "rewrite_clj/paredit.cljc",
                            :line 375,
                            :arglists ([zloc t]),
                            :doc "Create a new seq node of type `t` left of `zloc` then slurp fully into the new node\n\n- `[1 |2 3 4] => [1 [|2 3 4]]`",
                            :type :var})}
                {:doc "Parse Clojure/ClojureScript/EDN source code to nodes.\n\nAfter parsing, the typical next step is [[rewrite-clj.zip/edn]] to create zipper.\n\nAlternatively consider parsing and zipping in one step from [[rewrite-clj.zip/of-string]] or [[rewrite-clj.zip/of-file]].",
                 :name rewrite-clj.parser,
                 :publics ({:name parse,
                            :file "rewrite_clj/parser.cljc",
                            :line 13,
                            :arglists ([reader]),
                            :doc "Parse next form from the given reader.\n",
                            :no-doc true,
                            :type :var}
                           {:name parse-all,
                            :file "rewrite_clj/parser.cljc",
                            :line 18,
                            :arglists ([reader]),
                            :doc "Parse all forms from the given reader.\n",
                            :no-doc true,
                            :type :var}
                           {:name parse-file,
                            :file "rewrite_clj/parser.cljc",
                            :line 41,
                            :arglists ([f]),
                            :doc "Parse first form from the given file.\n",
                            :type :var}
                           {:name parse-file-all,
                            :file "rewrite_clj/parser.cljc",
                            :line 49,
                            :arglists ([f]),
                            :doc "Parse all forms from the given file.\n",
                            :type :var}
                           {:name parse-string,
                            :file "rewrite_clj/parser.cljc",
                            :line 30,
                            :arglists ([s]),
                            :doc "Parse first form in the given string.\n",
                            :type :var}
                           {:name parse-string-all,
                            :file "rewrite_clj/parser.cljc",
                            :line 35,
                            :arglists ([s]),
                            :doc "Parse all forms in the given string.\n",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.parser.core,
                 :publics ({:name parse-next,
                            :file "rewrite_clj/parser/core.cljc",
                            :line 31,
                            :arglists ([reader]),
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.parser.keyword,
                 :publics ({:name parse-keyword,
                            :file "rewrite_clj/parser/keyword.cljc",
                            :line 7,
                            :arglists ([reader]),
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.parser.namespaced-map,
                 :publics ({:name parse-namespaced-map,
                            :file "rewrite_clj/parser/namespaced_map.cljc",
                            :line 54,
                            :arglists ([reader read-next]),
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.parser.string,
                 :publics ({:name parse-regex,
                            :file "rewrite_clj/parser/string.cljc",
                            :line 38,
                            :arglists ([reader]),
                            :type :var}
                           {:name parse-string,
                            :file "rewrite_clj/parser/string.cljc",
                            :line 34,
                            :arglists ([reader]),
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.parser.token,
                 :publics ({:name parse-token,
                            :file "rewrite_clj/parser/token.cljc",
                            :line 35,
                            :arglists ([reader]),
                            :doc "Parse a single token.\n",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.parser.utils,
                 :publics ({:name ignore,
                            :file "rewrite_clj/parser/utils.cljc",
                            :line 20,
                            :arglists ([reader]),
                            :doc "Ignore next character of Reader.\n",
                            :type :var}
                           {:name linebreak?,
                            :file "rewrite_clj/parser/utils.cljc",
                            :line 10,
                            :arglists ([c]),
                            :doc "Check if a given character is a linebreak.\n",
                            :type :var}
                           {:name read-eol,
                            :file "rewrite_clj/parser/utils.cljc",
                            :line 33,
                            :arglists ([reader]),
                            :type :var}
                           {:name space?,
                            :file "rewrite_clj/parser/utils.cljc",
                            :line 15,
                            :arglists ([c]),
                            :doc "Check if a given character is a non-linebreak whitespace.\n",
                            :type :var}
                           {:name throw-reader,
                            :file "rewrite_clj/parser/utils.cljc",
                            :line 26,
                            :arglists ([reader & msg]),
                            :type :var}
                           {:name whitespace?,
                            :file "rewrite_clj/parser/utils.cljc",
                            :line 5,
                            :arglists ([c]),
                            :doc "Check if a given character is a whitespace.\n",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.parser.whitespace,
                 :publics ({:name parse-whitespace,
                            :file "rewrite_clj/parser/whitespace.cljc",
                            :line 5,
                            :arglists ([reader]),
                            :doc "Parse as much whitespace as possible. The created node can either contain\nonly linebreaks or only space/tabs.",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.potemkin.cljs,
                 :publics ({:name defprotocol+,
                            :file "rewrite_clj/potemkin/cljs.cljc",
                            :line 92,
                            :arglists ([name & body]),
                            :doc "Currently a no-op for cljs.\n",
                            :type :macro}
                           {:name import-vars,
                            :file "rewrite_clj/potemkin/cljs.cljc",
                            :line 75,
                            :arglists ([& raw-syms]),
                            :doc "Imports a list of vars from other namespaces with optional renaming and doc string altering.\n",
                            :type :macro})}
                {:no-doc true,
                 :name rewrite-clj.potemkin.clojure,
                 :publics ({:name defprotocol+,
                            :file "rewrite_clj/potemkin/clojure.clj",
                            :line 104,
                            :arglists ([name & body]),
                            :doc "A simpler version of 'potemkin.types/defprotocol+'.\n",
                            :type :macro}
                           {:name import-def,
                            :file "rewrite_clj/potemkin/clojure.clj",
                            :line 76,
                            :arglists ([src-sym
                                        target-name
                                        target-meta]),
                            :doc "Given a regular def'd var from another namespace, defined a new var with the\nsame name in the current namespace.",
                            :type :macro}
                           {:name import-fn,
                            :file "rewrite_clj/potemkin/clojure.clj",
                            :line 43,
                            :arglists ([src-sym
                                        target-name
                                        target-meta]),
                            :doc "Given a function in another namespace, defines a function with the\nsame name in the current namespace.  Argument lists, doc-strings,\nand original line-numbers are preserved.",
                            :type :macro}
                           {:name import-macro,
                            :file "rewrite_clj/potemkin/clojure.clj",
                            :line 60,
                            :arglists ([src-sym
                                        target-name
                                        target-meta]),
                            :doc "Given a macro in another namespace, defines a macro with the same\nname in the current namespace.  Argument lists, doc-strings, and\noriginal line-numbers are preserved.",
                            :type :macro}
                           {:name import-vars,
                            :file "rewrite_clj/potemkin/clojure.clj",
                            :line 89,
                            :arglists ([& raw-syms]),
                            :doc "Imports a list of vars from other namespaces with optional renaming and doc string altering.\n",
                            :type :macro})}
                {:no-doc true,
                 :name rewrite-clj.potemkin.helper,
                 :publics ({:name new-meta,
                            :file "rewrite_clj/potemkin/helper.cljc",
                            :line 9,
                            :arglists ([orig-meta opts]),
                            :type :var}
                           {:name new-name,
                            :file "rewrite_clj/potemkin/helper.cljc",
                            :line 4,
                            :arglists ([orig-name opts]),
                            :type :var}
                           {:name syms->import-data,
                            :file "rewrite_clj/potemkin/helper.cljc",
                            :line 46,
                            :arglists ([syms resolve-fn meta-fn]),
                            :type :var}
                           {:name unravel-syms,
                            :file "rewrite_clj/potemkin/helper.cljc",
                            :line 22,
                            :arglists ([x]),
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.reader,
                 :publics ({:name boundary?,
                            :file "rewrite_clj/reader.cljc",
                            :line 24,
                            :arglists ([c]),
                            :doc "Check whether a given char is a token boundary.\n",
                            :type :var}
                           {:name comma?,
                            :file "rewrite_clj/reader.cljc",
                            :line 32,
                            :arglists ([c]),
                            :type :var}
                           {:name file-reader,
                            :file "rewrite_clj/reader.cljc",
                            :line 178,
                            :arglists ([f]),
                            :doc "Create reader for files.\n",
                            :type :var}
                           {:name ignore,
                            :file "rewrite_clj/reader.cljc",
                            :line 105,
                            :arglists ([reader]),
                            :doc "Ignore the next character.\n",
                            :type :var}
                           {:name linebreak?,
                            :file "rewrite_clj/reader.cljc",
                            :line 42,
                            :arglists ([c]),
                            :doc "Checks whether the character is a newline\n",
                            :type :var}
                           {:name next,
                            :file "rewrite_clj/reader.cljc",
                            :line 111,
                            :arglists ([reader]),
                            :doc "Read next char.\n",
                            :type :var}
                           {:name peek,
                            :file "rewrite_clj/reader.cljc",
                            :line 121,
                            :arglists ([reader]),
                            :doc "Peek next char.\n",
                            :type :var}
                           {:name position,
                            :file "rewrite_clj/reader.cljc",
                            :line 126,
                            :arglists ([reader row-k col-k]),
                            :doc "Create map of `row-k` and `col-k` representing the current reader position.\n",
                            :type :var}
                           {:name read-include-linebreak,
                            :file "rewrite_clj/reader.cljc",
                            :line 91,
                            :arglists ([reader]),
                            :doc "Read until linebreak and include it.\n",
                            :type :var}
                           {:name read-n,
                            :file "rewrite_clj/reader.cljc",
                            :line 149,
                            :arglists ([reader node-tag read-fn p? n]),
                            :doc "Call the given function on the given reader until `n` values matching `p?` have been\ncollected.",
                            :type :var}
                           {:name read-repeatedly,
                            :file "rewrite_clj/reader.cljc",
                            :line 141,
                            :arglists ([reader read-fn]),
                            :doc "Call the given function on the given reader until it returns\na non-truthy value.",
                            :type :var}
                           {:name read-until,
                            :file "rewrite_clj/reader.cljc",
                            :line 82,
                            :arglists ([reader p?]),
                            :doc "Read until a char fulfills the given condition. Ignores the\nmatching char.",
                            :type :var}
                           {:name read-while,
                            :file "rewrite_clj/reader.cljc",
                            :line 61,
                            :arglists ([reader p?] [reader p? eof?]),
                            :doc "Read while the chars fulfill the given condition. Ignores\nthe unmatching char.",
                            :type :var}
                           {:name read-with-meta,
                            :file "rewrite_clj/reader.cljc",
                            :line 132,
                            :arglists ([reader read-fn]),
                            :doc "Use the given function to read value, then attach row/col metadata.\n",
                            :type :var}
                           {:name space?,
                            :file "rewrite_clj/reader.cljc",
                            :line 47,
                            :arglists ([c]),
                            :doc "Checks whether the character is a space\n",
                            :type :var}
                           {:name string->edn,
                            :file "rewrite_clj/reader.cljc",
                            :line 100,
                            :arglists ([s]),
                            :doc "Convert string to EDN value.\n",
                            :type :var}
                           {:name string-reader,
                            :file "rewrite_clj/reader.cljc",
                            :line 171,
                            :arglists ([s]),
                            :doc "Create reader for strings.\n",
                            :type :var}
                           {:name throw-reader,
                            :file "rewrite_clj/reader.cljc",
                            :line 12,
                            :arglists ([reader fmt & data]),
                            :doc "Throw reader exception, including line line/column.\n",
                            :type :var}
                           {:name unread,
                            :file "rewrite_clj/reader.cljc",
                            :line 116,
                            :arglists ([reader ch]),
                            :doc "Unreads a char. Puts the char back on the reader.\n",
                            :type :var}
                           {:name whitespace-or-boundary?,
                            :file "rewrite_clj/reader.cljc",
                            :line 54,
                            :arglists ([c]),
                            :type :var}
                           {:name whitespace?,
                            :file "rewrite_clj/reader.cljc",
                            :line 36,
                            :arglists ([c]),
                            :doc "Checks whether a given character is whitespace\n",
                            :type :var})}
                {:doc "A rich API for navigating and updating Clojure/ClojureScripti/EDN source code via a zipper tree.\n\nThe zipper holds a tree of nodes representing source code. It also holds your current location while navigating\nthrough the tree and any pending changes you have made. Changes are applied back into the tree\nwhen invoking root functions.\n\nAlthough they are preserved, whitespace and comment nodes are normally skipped when navigating through the tree.\nThere are times when you will want to include whitespace and comment nodes, and as you see below, provisions are\navailable to do so.\n\nIt is good to remember that while some function names convey mutation, we are never changing anything, we are\ninstead returning modified copies.\n\nSome conventions in the code and docstrings:\n- `zloc` is the used as the argument name for our zipper\n- \"current node in `zloc`\" is shorthand for: node at current location in zipper `zloc`\n\nBecause this API contains many functions, we offer the following categorized listing:\n\n**Create a zipper**\n[[edn]]\n[[edn*]]\n[[of-string]]\n[[of-file]]\n\n**Move**\n[[left]]\n[[right]]\n[[up]]\n[[down]]\n[[prev]]\n[[next]]\n[[leftmost]]\n[[rightmost]]\n\n**Move without skipping whitespace and comments**\n[[left*]]\n[[right*]]\n[[up*]]\n[[down*]]\n[[prev*]]\n[[next*]]\n[[leftmost*]]\n[[rightmost*]]\n\n**Whitespace/comment aware skip**\n[[skip]]\n[[skip-whitespace]]\n[[skip-whitespace-left]]\n\n**Test for whitespace**\n[[whitespace?]]\n[[linebreak?]]\n[[whitespace-or-comment?]]\n\n**Test location**\n[[leftmost?]]\n[[rightmost?]]\n[[end?]]\n\n**Test data type**\n[[seq?]]\n[[list?]]\n[[vector?]]\n[[set?]]\n[[map?]]\n\n**Find**\n[[find]]\n[[find-next]]\n[[find-depth-first]]\n[[find-next-depth-first]]\n[[find-tag]]\n[[find-next-tag]]\n[[find-value]]\n[[find-next-value]]\n[[find-token]]\n[[find-next-token]]\n[[find-last-by-pos]]\n[[find-tag-by-pos]]\n\n**Inspect**\n[[node]]\n[[position]]\n[[position-span]]\n[[tag]]\n[[length]]\n\n**Convert**\n[[sexpr]]\n[[child-sexpr]]\n\n**Update**\n[[replace]]\n[[edit]]\n[[splice]]\n[[prefix]]\n[[suffix]]\n[[insert-right]]\n[[insert-left]]\n[[insert-child]]\n[[insert-space-left]]\n[[insert-space-right]]\n[[insert-newline-left]]\n[[insert-newline-right]]\n[[append-child]]\n[[remove]]\n[[remove-preserve-newline]]\n[[root]]\n\n**Update without whitespace treatment**\n[[replace*]]\n[[edit*]]\n[[insert-left*]]\n[[insert-right*]]\n[[append-child*]]\n[[remove*]]\n\n**Isolated update without changing location**\n[[edit-node]]\n[[subedit-node]]\n[[subzip]]\n[[prewalk]]\n[[postwalk]]\n[[edit->]]\n[[edit->>]]\n[[subedit->]]\n[[subedit->>]]\n\n**Sequence operations**\n[[map]]\n[[map-keys]]\n[[map-vals]]\n[[get]]\n[[assoc]]\n\n**Stringify**\n[[string]]\n[[root-string]]\n\n**Output**\n[[print]]\n[[print-root]]",
                 :name rewrite-clj.zip,
                 :publics ({:name ->root-string,
                            :file "rewrite_clj/zip.cljc",
                            :line 249,
                            :arglists ([zloc]),
                            :doc "DEPRECATED. Renamed to [[root-string]].\n",
                            :deprecated "0.4.0",
                            :type :var}
                           {:name ->string,
                            :file "rewrite_clj/zip.cljc",
                            :line 244,
                            :arglists ([zloc]),
                            :doc "DEPRECATED. Renamed to [[string]].\n",
                            :deprecated "0.4.0",
                            :type :var}
                           {:name append-child,
                            :file "rewrite_clj/zip/insert.cljc",
                            :line 52,
                            :arglists ([zloc item]),
                            :doc "Return zipper with `item` appended as last child of the current node in `zloc`.\nWill insert a space if necessary.",
                            :type :var}
                           {:name append-child*,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 219,
                            :arglists ([zloc item]),
                            :doc "Raw version of [[append-child]].\n\nReturns zipper with `item` inserted as the rightmost child of the current node in `zloc`,\n  without moving.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                            :type :var}
                           {:name append-newline,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 113,
                            :arglists ([zloc & [n]]),
                            :doc "DEPRECATED: renamed to [[insert-newline-right]].\n",
                            :deprecated "0.5.0",
                            :type :var}
                           {:name append-space,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 103,
                            :arglists ([zloc & [n]]),
                            :doc "DEPRECATED: renamed to [[insert-space-right]].\n",
                            :deprecated "0.5.0",
                            :type :var}
                           {:name assoc,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 111,
                            :arglists ([zloc k v]),
                            :doc "Returns zipper with key `k` set to value `v` when current node in `zloc` is a map node.\nReturns zipper with index `k` set to value `v` when current node in `zloc` is a sequence.",
                            :type :var}
                           {:name child-sexprs,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 51,
                            :arglists ([zloc]),
                            :doc "Return s-expression of children of current node in `zloc`.\n",
                            :added "0.4.4",
                            :type :var}
                           {:name down,
                            :file "rewrite_clj/zip/move.cljc",
                            :line 16,
                            :arglists ([zloc]),
                            :doc "Return zipper with location moved down to next non-whitespace/non-comment node in `zloc`.\n",
                            :type :var}
                           {:name down*,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 96,
                            :arglists ([zloc]),
                            :doc "Raw version of [[down]].\n\nReturns zipper with the location at the leftmost child of current node in `zloc`, or\n  nil if no children.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                            :type :var}
                           {:name edit,
                            :file "rewrite_clj/zip/editz.cljc",
                            :line 26,
                            :arglists ([zloc f & args]),
                            :doc "Return zipper with the current node in `zloc` replaced with the result of:\n\n(`f` (s-expression node) `args`)\n\nThe result of `f` will be coerced to a node if possible.",
                            :type :var}
                           {:name edit*,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 206,
                            :arglists ([zloc f & args]),
                            :doc "Raw version of [[edit]].\n\nReturns zipper with value of `(f current-node args)` replacing current node in `zloc`\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                            :type :var}
                           {:name edit->,
                            :file "rewrite_clj/zip/subedit.cljc",
                            :line 41,
                            :arglists ([zloc & body]),
                            :doc "Like `->`. Threads `zloc` through forms.\nThe resulting zipper will be located at the same path (i.e. the same\nnumber of downwards and right movements from the root) as incoming `zloc`.",
                            :type :macro}
                           {:name edit->>,
                            :file "rewrite_clj/zip/subedit.cljc",
                            :line 48,
                            :arglists ([zloc & body]),
                            :doc "Like `->>`. Threads `zloc` through forms.\nThe resulting zipper will be located at the same path (i.e. the same\nnumber of downwards and right movements from the root) as incoming `zloc`.",
                            :type :macro}
                           {:name edit-node,
                            :file "rewrite_clj/zip/subedit.cljc",
                            :line 32,
                            :arglists ([zloc f]),
                            :doc "Return zipper applying function `f` to `zloc`. The resulting\nzipper will be located at the same path (i.e. the same number of\ndownwards and right movements from the root) incoming `zloc`.",
                            :type :var}
                           {:name edn,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 23,
                            :arglists ([node] [node options]),
                            :doc "Create and return zipper from Clojure/ClojureScript/EDN `node` (likely parsed by [[rewrite-clj-.parse]])\nand move to the first non-whitespace/non-comment child.\n\nSet `:track-position?` in `options` to enable ones-based row/column tracking.\nSee [[rewrite-clj.zip/position]].\n\nNOTE: when position tracking is enabled, `clojure.zip` is not interchangeable with `rewrite-clj.zip`, you must use `rewrite-clj.zip`.",
                            :type :var}
                           {:name edn*,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 9,
                            :arglists ([node]
                                       [node
                                        {:keys [track-position?]}]),
                            :doc "Create and return zipper from Clojure/ClojureScript/EDN `node` (likely parsed by [[rewrite-clj.parse]]).\n\nSet `:track-position?` in `options` to enable ones-based row/column tracking.\nSee [[rewrite-clj.zip/position]].\n\nNOTE: when position tracking is enabled, `clojure.zip` is not interchangeable with `rewrite-clj.zip`, you must use `rewrite-clj.zip`.",
                            :type :var}
                           {:name end?,
                            :file "rewrite_clj/zip/move.cljc",
                            :line 35,
                            :arglists ([zloc]),
                            :doc "Return true if `zloc` is at end of depth-first traversal.\n",
                            :type :var}
                           {:name find,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 29,
                            :arglists ([zloc p?] [zloc f p?]),
                            :doc "Return the first node satisfying predicate `p?` seaching from the current node\nin `zloc` traversing by function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var}
                           {:name find-depth-first,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 59,
                            :arglists ([zloc p?]),
                            :doc "Return first node satisfying predicate `p?` searching depth-first from\nthe current node in `zloc`.",
                            :type :var}
                           {:name find-last-by-pos,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 44,
                            :arglists ([zloc pos] [zloc pos p?]),
                            :doc "Return the last node spanning position `pos` that satisfies predicate `p?`\n searching depth-first from the current node in `zloc`.\n\nNOTE: Does not ignore whitespace/comment nodes.",
                            :type :var}
                           {:name find-next,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 65,
                            :arglists ([zloc p?] [zloc f p?]),
                            :doc "Return the first node satisfying predicate `p?` searching one movement `f` from the current\nnode in `zloc` traversing by function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var}
                           {:name find-next-depth-first,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 75,
                            :arglists ([zloc p?]),
                            :doc "Return the first node satisfying predicate `p?` searching depth-first from one\nnode after the current node in `zloc`",
                            :type :var}
                           {:name find-next-tag,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 91,
                            :arglists ([zloc t] [zloc f t]),
                            :doc "Return the first node with tag `t` searching one movement `f` from the current\nnode in `zloc` traversing by function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var}
                           {:name find-next-token,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 118,
                            :arglists ([zloc p?] [zloc f p?]),
                            :doc "Return the first token node satisfying predicate `p?` searching from the current node in `zloc` traversing\nby function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var}
                           {:name find-next-value,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 141,
                            :arglists ([zloc v] [zloc f v]),
                            :doc "Return the first token node with value `v` searching one movement `f` from the current node in `zloc` traversing\nby function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var}
                           {:name find-tag,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 81,
                            :arglists ([zloc t] [zloc f t]),
                            :doc "Return the first node with tag `t` searching from the current node in `zloc` traversing by\nfunction `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var}
                           {:name find-tag-by-pos,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 102,
                            :arglists ([zloc pos t]),
                            :doc "Return the last node spanning position `pos` with tag `t` searching depth-first from the current node in `zloc`.\n",
                            :type :var}
                           {:name find-token,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 107,
                            :arglists ([zloc p?] [zloc f p?]),
                            :doc "Return the first token node satisfying predicate `p?` searching from the current node in `zloc` traversing\nby function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var}
                           {:name find-value,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 128,
                            :arglists ([zloc v] [zloc f v]),
                            :doc "Return the first token node with value `v` searching one movement `f` from the current node in `zloc` traversing\nby function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var}
                           {:name get,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 98,
                            :arglists ([zloc k]),
                            :doc "Returns value node mapped to key `k` when current node in `zloc` is a map node.\nReturns nth `k` value node when current node in `zloc` is a sequence node.",
                            :type :var}
                           {:name insert-child,
                            :file "rewrite_clj/zip/insert.cljc",
                            :line 43,
                            :arglists ([zloc item]),
                            :doc "Return zipper with `item` inserted as the first child of the current node in `zloc`.\n",
                            :type :var}
                           {:name insert-left,
                            :file "rewrite_clj/zip/insert.cljc",
                            :line 33,
                            :arglists ([zloc item]),
                            :doc "Return zipper with `item` inserted to the left of the current node in `zloc`.\nWill insert a space if necessary.",
                            :type :var}
                           {:name insert-left*,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 178,
                            :arglists ([zloc item]),
                            :doc "Raw version of [[insert-left]].\n\nReturns zipper with `item` inserted as the left sibling of current node in `zloc`,\n without moving location.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                            :type :var}
                           {:name insert-newline-left,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 82,
                            :arglists ([zloc] [zloc n]),
                            :doc "Return zipper with `n` newlines node inserted to the left of the current node in `zloc`.\n`n` defaults to 1.",
                            :added "0.5.0",
                            :type :var}
                           {:name insert-newline-right,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 89,
                            :arglists ([zloc] [zloc n]),
                            :doc "Return zipper with `n` newlines node inserted to the right of the current node in `zloc`.\n`n` defaults to 1.",
                            :added "0.5.0",
                            :type :var}
                           {:name insert-right,
                            :file "rewrite_clj/zip/insert.cljc",
                            :line 23,
                            :arglists ([zloc item]),
                            :doc "Return zipper with `item` inserted to the right of the current node in `zloc`.\nWill insert a space if necessary.",
                            :type :var}
                           {:name insert-right*,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 190,
                            :arglists ([zloc item]),
                            :doc "Raw version of [[insert-right]].\n\nReturns zipper with `item` inserted as the right sibling of the current node in `zloc`,\n  without moving location.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                            :type :var}
                           {:name insert-space-left,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 62,
                            :arglists ([zloc] [zloc n]),
                            :doc "Return zipper with `n` space whitespace node inserted to the left of the current node in `zloc`.\n`n` defaults to 1.",
                            :added "0.5.0",
                            :type :var}
                           {:name insert-space-right,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 72,
                            :arglists ([zloc] [zloc n]),
                            :doc "Return zipper with `n` space whitespace node inserted to the right of the current node in `zloc`.\n`n` defaults to 1.",
                            :added "0.5.0",
                            :type :var}
                           {:name left,
                            :file "rewrite_clj/zip/move.cljc",
                            :line 11,
                            :arglists ([zloc]),
                            :doc "Return zipper with location moved left to next non-whitespace/non-comment node in `zloc`.\n",
                            :type :var}
                           {:name left*,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 153,
                            :arglists ([zloc]),
                            :doc "Raw version of [[left]].\n\nReturns zipper with location at the left sibling of the current node in `zloc`, or nil.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                            :type :var}
                           {:name leftmost,
                            :file "rewrite_clj/zip/move.cljc",
                            :line 59,
                            :arglists ([zloc]),
                            :doc "Return zipper with location moved to the leftmost non-whitespace/non-comment node in `zloc`.\n",
                            :type :var}
                           {:name leftmost*,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 165,
                            :arglists ([zloc]),
                            :doc "Raw version of [[leftmost]].\n\nReturns zipper with location at the leftmost sibling of the current node in `zloc`, or self.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                            :type :var}
                           {:name leftmost?,
                            :file "rewrite_clj/zip/move.cljc",
                            :line 47,
                            :arglists ([zloc]),
                            :doc "Return true if at leftmost non-whitespace/non-comment node in `zloc`.\n",
                            :type :var}
                           {:name length,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 56,
                            :arglists ([zloc]),
                            :doc "Return length of printable string of current node in `zloc`.\n",
                            :type :var}
                           {:name linebreak?,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 12,
                            :arglists ([zloc]),
                            :doc "Returns true when the current node in `zloc` is a linebreak.\n",
                            :type :var}
                           {:name list?,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 19,
                            :arglists ([zloc]),
                            :doc "Returns true if current node in `zloc` is a list.\n",
                            :type :var}
                           {:name map,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 83,
                            :arglists ([f zloc]),
                            :doc "Returns zipper with function `f` applied to all value nodes of current node in `zloc`.\nCurrent node must be a sequence node.\n\nIterates over:\n- value nodes of maps\n- each element of a seq",
                            :type :var}
                           {:name map-keys,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 70,
                            :arglists ([f zloc]),
                            :doc "Returns zipper with function `f` applied to all key nodes of the current node in `zloc`.\nCurrent node must be map node.",
                            :type :var}
                           {:name map-vals,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 55,
                            :arglists ([f zloc]),
                            :doc "Returns zipper with function `f` applied to all value current node in `zloc`.\nCurrent node must be map node.",
                            :type :var}
                           {:name map?,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 34,
                            :arglists ([zloc]),
                            :doc "Returns true if current node in `zloc` is a map.\n",
                            :type :var}
                           {:name next,
                            :file "rewrite_clj/zip/move.cljc",
                            :line 26,
                            :arglists ([zloc]),
                            :doc "Return zipper with location moved to the next depth-first non-whitespace/non-comment node in `zloc`.\n",
                            :type :var}
                           {:name next*,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 225,
                            :arglists ([{:keys [end?], :as zloc}]),
                            :doc "Raw version of [[next]].\n\nReturns zipper with location at the next depth-first location in the hierarchy in `zloc`.\n  When reaching the end, returns a distinguished zipper detectable via [[end?]]. If already\n  at the end, stays there.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                            :type :var}
                           {:name node,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 51,
                            :arglists ([zloc]),
                            :doc "Returns the current node in `zloc`.\n",
                            :type :var}
                           {:name of-file,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 80,
                            :arglists ([f] [f options]),
                            :doc "Create and return zipper from all forms in Clojure/ClojureScript/EDN File `f`.\n\nSet `:track-position?` in `options` to enable ones-based row/column tracking.\nSee [[rewrite-clj.zip/position]].\n\nNOTE: when position tracking is enabled, `clojure.zip` is not interchangeable with `rewrite-clj.zip`, you must use `rewrite-clj.zip`.",
                            :type :var}
                           {:name of-string,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 68,
                            :arglists ([s] [s options]),
                            :doc "Create and return zipper from all forms in Clojure/ClojureScript/EDN string `s`.\n\nSet `:track-position?` in `options` to enable ones-based row/column tracking.\nSee [[rewrite-clj.zip/position]].\n\nNOTE: when position tracking is enabled, `clojure.zip` is not interchangeable with `rewrite-clj.zip`, you must use `rewrite-clj.zip`.",
                            :type :var}
                           {:name position,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 74,
                            :arglists ([zloc]),
                            :doc "Returns the ones-based `[row col]` of the start of the current node in `zloc`.\n",
                            :type :var}
                           {:name position-span,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 84,
                            :arglists ([zloc]),
                            :doc "Returns the ones-based `[[start-row start-col] [end-row end-col]]` of the current node in `zloc`.\n",
                            :type :var}
                           {:name postwalk,
                            :file "rewrite_clj/zip/walk.cljc",
                            :line 38,
                            :arglists ([zloc f] [zloc p? f]),
                            :doc "Return zipper modified by an isolated depth-first post-order traversal.\nTraversal starts at the current node in `zloc` and continues to the end of the isolated sub-tree.\nFunction `f` is called on the zipper locations satisfying predicate `p?`, or all locations when `p?` is absent,\nand must return a valid zipper - modified or not.\n\nWARNING: when function `f` changes the location in the zipper, normal traversal will be affected.",
                            :added "0.4.9",
                            :type :var}
                           {:name prefix,
                            :file "rewrite_clj/zip/editz.cljc",
                            :line 75,
                            :arglists ([zloc s]),
                            :doc "Return zipper with the current node in `zloc` prefixed with string `s`.\nOperates on token node or a multi-line node, else exception is thrown.\nWhen multi-line, all lines are prefixed.\n\nTODO: either multi-line handling is broken or I don't understand intent of code.",
                            :type :var}
                           {:name prepend-newline,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 108,
                            :arglists ([zloc & [n]]),
                            :doc "DEPRECATED: renamed to [[insert-newline-left]].\n",
                            :deprecated "0.5.0",
                            :type :var}
                           {:name prepend-space,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 98,
                            :arglists ([zloc & [n]]),
                            :doc "DEPRECATED: renamed to [[insert-space-left]].\n",
                            :deprecated "0.5.0",
                            :type :var}
                           {:name prev,
                            :file "rewrite_clj/zip/move.cljc",
                            :line 52,
                            :arglists ([zloc]),
                            :doc "Return zipper with location moved to the previous depth-first non-whitespace/non-comment node in `zloc`.\n",
                            :type :var}
                           {:name prev*,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 240,
                            :arglists ([zloc]),
                            :doc "Raw version of [[prev]].\n\nReturns zipper with location at the previous depth-first location in the hierarchy in `zloc`.\n  If already at the root, returns nil.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                            :type :var}
                           {:name prewalk,
                            :file "rewrite_clj/zip/walk.cljc",
                            :line 16,
                            :arglists ([zloc f] [zloc p? f]),
                            :doc "Return zipper modified by an isolated depth-first pre-order traversal.\nTraversal starts at the current node in `zloc` and continues to the end of the isolated sub-tree.\nFunction `f` is called on the zipper locations satisfying predicate `p?`, or all locations when `p?` is absent,\nand must return a valid zipper - modified or not.\n\nWARNING: when function `f` changes the location in the zipper, normal traversal will be affected.",
                            :type :var}
                           {:name print,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 112,
                            :arglists ([zloc & [writer]]),
                            :doc "Print current node in `zloc`.\n\nNOTE: Optional `writer` is currently ignored for ClojureScript.",
                            :type :var}
                           {:name print-root,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 121,
                            :arglists ([zloc & [writer]]),
                            :doc "Zip up and print `zloc` from root node.\n\nNOTE: Optional `writer` is currently ignored for ClojureScript.",
                            :type :var}
                           {:name remove,
                            :file "rewrite_clj/zip/removez.cljc",
                            :line 28,
                            :arglists ([zloc]),
                            :doc "Return zipper with current node in `zloc` removed. Returned zipper location\n is moved to the first non-whitespace node preceding removed node in a depth-first walk.\n Removes whitespace appropriately.\n\n- `[1  2  3]   => [1  3]`\n- `[1 2]       => [1]`\n- `[1 2]       => [2]`\n- `[1]         => []`\n- `[  1  ]     => []`\n- `[1 [2 3] 4] => [1 [2 3]]`\n- `[1 [2 3] 4] => [[2 3] 4]`\n\n If the removed node is at the rightmost location, both preceding and trailing spaces are removed,\n otherwise only trailing spaces are removed. This means that a following element\n (no matter whether on the same line or not) will end up in the same position\n (line/column) as the removed one, _unless_ a comment lies between the original\n node and the neighbour.",
                            :type :var}
                           {:name remove*,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 256,
                            :arglists ([zloc]),
                            :doc "Raw version of [[remove]].\n\nReturns zipper with current node in `zloc` removed, with location at node that would have preceded\n  it in a depth-first walk.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                            :type :var}
                           {:name remove-preserve-newline,
                            :file "rewrite_clj/zip/removez.cljc",
                            :line 51,
                            :arglists ([zloc]),
                            :doc "Same as [[remove]] but preserves newlines.\n",
                            :type :var}
                           {:name replace,
                            :file "rewrite_clj/zip/editz.cljc",
                            :line 12,
                            :arglists ([zloc value]),
                            :doc "Return zipper with the current node in `zloc` replaced with one representing `value`.\n`value` will be coerced to a node if possible.",
                            :type :var}
                           {:name replace*,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 201,
                            :arglists ([zloc node]),
                            :doc "Raw version of [[replace]].\n\nReturns zipper with `node` replacing current node in `zloc`, without moving location.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                            :type :var}
                           {:name right,
                            :file "rewrite_clj/zip/move.cljc",
                            :line 6,
                            :arglists ([zloc]),
                            :doc "Return zipper with location moved right to next non-whitespace/non-comment node in `zloc`.\n",
                            :type :var}
                           {:name right*,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 135,
                            :arglists ([zloc]),
                            :doc "Raw version of [[right]].\n\nReturns zipper with location at the right sibling of the current node in `zloc`, or nil.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                            :type :var}
                           {:name rightmost,
                            :file "rewrite_clj/zip/move.cljc",
                            :line 66,
                            :arglists ([zloc]),
                            :doc "Return zipper with location moved to the rightmost non-whitespace/non-comment node in `zloc`.\n",
                            :type :var}
                           {:name rightmost*,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 146,
                            :arglists ([zloc]),
                            :doc "Raw version of [[rightmost]].\n\nReturns zipper with location at the rightmost sibling of the current node in `zloc`, or self.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                            :type :var}
                           {:name rightmost?,
                            :file "rewrite_clj/zip/move.cljc",
                            :line 42,
                            :arglists ([zloc]),
                            :doc "Return true if at rightmost non-whitespace/non-comment node in `zloc`.\n",
                            :type :var}
                           {:name root,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 125,
                            :arglists ([{:keys [end?], :as zloc}]),
                            :doc "Zips all the way up `zloc` and returns zipper at the root node, reflecting any changes.\n",
                            :type :var}
                           {:name root-string,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 98,
                            :arglists ([zloc]),
                            :doc "Return string representing the zipped-up `zloc` zipper.\n",
                            :added "0.4.0",
                            :type :var}
                           {:name seq?,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 12,
                            :arglists ([zloc]),
                            :doc "Returns true if current node in `zloc` is a sequence.\n",
                            :type :var}
                           {:name set?,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 29,
                            :arglists ([zloc]),
                            :doc "Returns true if current node in `zloc` is a set.\n",
                            :type :var}
                           {:name sexpr,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 46,
                            :arglists ([zloc]),
                            :doc "Return s-expression of current node in `zloc`.\n",
                            :type :var}
                           {:name skip,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 37,
                            :arglists ([f p? zloc]),
                            :doc "Return zipper with location moved to first location not satisfying predicate `p?` starting from the node in\n`zloc` and traversing by function `f`.",
                            :type :var}
                           {:name skip-whitespace,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 47,
                            :arglists ([zloc] [f zloc]),
                            :doc "Return zipper with location moved to first non-whitespace/non-comment starting from current node in `zloc`\nand traversing by function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var}
                           {:name skip-whitespace-left,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 55,
                            :arglists ([zloc]),
                            :doc "Return zipper with location moved to first non-whitespace/non-comment starting from current node in `zloc` traversing left.\n",
                            :type :var}
                           {:name splice,
                            :file "rewrite_clj/zip/editz.cljc",
                            :line 37,
                            :arglists ([zloc]),
                            :doc "Return zipper with the children of the current node in `zloc` merged into itself.\n(akin to Clojure's `unquote-splicing` macro: `~@...`).\n- if the node is not one that can have children, no modification will\n  be performed.\n- if the node has no or only whitespace children, it will be removed.\n- otherwise, splicing will be performed, moving the zipper to the first\n  non-whitespace child afterwards.",
                            :type :var}
                           {:name string,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 93,
                            :arglists ([zloc]),
                            :doc "Return string representing the current node in `zloc`.\n",
                            :added "0.4.0",
                            :type :var}
                           {:name subedit->,
                            :file "rewrite_clj/zip/subedit.cljc",
                            :line 72,
                            :arglists ([zloc & body]),
                            :doc "Like `->`. Threads `zloc`, as an isolated sub-tree through forms, then zips\nup to, and locates at, the root of the modified sub-tree.",
                            :type :macro}
                           {:name subedit->>,
                            :file "rewrite_clj/zip/subedit.cljc",
                            :line 78,
                            :arglists ([zloc & body]),
                            :doc "Like `->`. Threads `zloc`, as an isolated sub-tree through forms, then zips\nup to, and locates at, the root of the modified sub-tree.",
                            :type :macro}
                           {:name subedit-node,
                            :file "rewrite_clj/zip/subedit.cljc",
                            :line 64,
                            :arglists ([zloc f]),
                            :doc "Return zipper replacing current node in `zloc` with result of `f` applied to said node as an isolated sub-tree.\nThe resulting zipper will be located on the root of the modified sub-tree.",
                            :type :var}
                           {:name subzip,
                            :file "rewrite_clj/zip/subedit.cljc",
                            :line 57,
                            :arglists ([zloc]),
                            :doc "Create and return a zipper whose root is the current node in `zloc`.\n",
                            :type :var}
                           {:name suffix,
                            :file "rewrite_clj/zip/editz.cljc",
                            :line 90,
                            :arglists ([zloc s]),
                            :doc "Return zipper with the current node in `zloc` suffixed with string `s`.\nOperates on token node or a multi-line node, else exception is thrown.\nWhen multi-line, all lines are suffixed.\n\nTODO: either multi-line handling is broken or I don't understand intent of code.",
                            :type :var}
                           {:name tag,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 41,
                            :arglists ([zloc]),
                            :doc "Return tag of current node in `zloc`.\n",
                            :type :var}
                           {:name up,
                            :file "rewrite_clj/zip/move.cljc",
                            :line 21,
                            :arglists ([zloc]),
                            :doc "Return zipper with location moved up to next non-whitespace/non-comment node in `zloc`.\n",
                            :type :var}
                           {:name up*,
                            :file "rewrite_clj/custom_zipper/core.cljc",
                            :line 111,
                            :arglists ([zloc]),
                            :doc "Raw version of [[up]].\n\nReturns zipper with the location at the parent of current node in `zloc`, or nil if at\n  the top.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                            :type :var}
                           {:name value,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 61,
                            :arglists ([zloc]),
                            :doc "DEPRECATED. Return a tag/s-expression pair for inner nodes, or\nthe s-expression itself for leaves.",
                            :deprecated "0.4.0",
                            :type :var}
                           {:name vector?,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 24,
                            :arglists ([zloc]),
                            :doc "Returns true if current node in `zloc` is a vector.\n",
                            :type :var}
                           {:name whitespace-or-comment?,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 29,
                            :arglists ([zloc]),
                            :doc "Returns true when current node in `zloc` is whitespace or a comment.\n",
                            :type :var}
                           {:name whitespace?,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 7,
                            :arglists ([zloc]),
                            :doc "Returns true when the current the node in `zloc` is a Clojure whitespace (which includes the comma).\n",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.zip.base,
                 :publics ({:name child-sexprs,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 51,
                            :arglists ([zloc]),
                            :doc "Return s-expression of children of current node in `zloc`.\n",
                            :added "0.4.4",
                            :type :var}
                           {:name edn,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 23,
                            :arglists ([node] [node options]),
                            :doc "Create and return zipper from Clojure/ClojureScript/EDN `node` (likely parsed by [[rewrite-clj-.parse]])\nand move to the first non-whitespace/non-comment child.\n\nSet `:track-position?` in `options` to enable ones-based row/column tracking.\nSee [[rewrite-clj.zip/position]].\n\nNOTE: when position tracking is enabled, `clojure.zip` is not interchangeable with `rewrite-clj.zip`, you must use `rewrite-clj.zip`.",
                            :type :var}
                           {:name edn*,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 9,
                            :arglists ([node]
                                       [node
                                        {:keys [track-position?]}]),
                            :doc "Create and return zipper from Clojure/ClojureScript/EDN `node` (likely parsed by [[rewrite-clj.parse]]).\n\nSet `:track-position?` in `options` to enable ones-based row/column tracking.\nSee [[rewrite-clj.zip/position]].\n\nNOTE: when position tracking is enabled, `clojure.zip` is not interchangeable with `rewrite-clj.zip`, you must use `rewrite-clj.zip`.",
                            :type :var}
                           {:name length,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 56,
                            :arglists ([zloc]),
                            :doc "Return length of printable string of current node in `zloc`.\n",
                            :type :var}
                           {:name of-file,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 80,
                            :arglists ([f] [f options]),
                            :doc "Create and return zipper from all forms in Clojure/ClojureScript/EDN File `f`.\n\nSet `:track-position?` in `options` to enable ones-based row/column tracking.\nSee [[rewrite-clj.zip/position]].\n\nNOTE: when position tracking is enabled, `clojure.zip` is not interchangeable with `rewrite-clj.zip`, you must use `rewrite-clj.zip`.",
                            :type :var}
                           {:name of-string,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 68,
                            :arglists ([s] [s options]),
                            :doc "Create and return zipper from all forms in Clojure/ClojureScript/EDN string `s`.\n\nSet `:track-position?` in `options` to enable ones-based row/column tracking.\nSee [[rewrite-clj.zip/position]].\n\nNOTE: when position tracking is enabled, `clojure.zip` is not interchangeable with `rewrite-clj.zip`, you must use `rewrite-clj.zip`.",
                            :type :var}
                           {:name print,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 112,
                            :arglists ([zloc & [writer]]),
                            :doc "Print current node in `zloc`.\n\nNOTE: Optional `writer` is currently ignored for ClojureScript.",
                            :type :var}
                           {:name print-root,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 121,
                            :arglists ([zloc & [writer]]),
                            :doc "Zip up and print `zloc` from root node.\n\nNOTE: Optional `writer` is currently ignored for ClojureScript.",
                            :type :var}
                           {:name root-string,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 98,
                            :arglists ([zloc]),
                            :doc "Return string representing the zipped-up `zloc` zipper.\n",
                            :added "0.4.0",
                            :type :var}
                           {:name sexpr,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 46,
                            :arglists ([zloc]),
                            :doc "Return s-expression of current node in `zloc`.\n",
                            :type :var}
                           {:name string,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 93,
                            :arglists ([zloc]),
                            :doc "Return string representing the current node in `zloc`.\n",
                            :added "0.4.0",
                            :type :var}
                           {:name tag,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 41,
                            :arglists ([zloc]),
                            :doc "Return tag of current node in `zloc`.\n",
                            :type :var}
                           {:name value,
                            :file "rewrite_clj/zip/base.cljc",
                            :line 61,
                            :arglists ([zloc]),
                            :doc "DEPRECATED. Return a tag/s-expression pair for inner nodes, or\nthe s-expression itself for leaves.",
                            :deprecated "0.4.0",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.zip.edit,
                 :publics ({:name edit,
                            :file "rewrite_clj/zip/editz.cljc",
                            :line 26,
                            :arglists ([zloc f & args]),
                            :doc "Return zipper with the current node in `zloc` replaced with the result of:\n\n(`f` (s-expression node) `args`)\n\nThe result of `f` will be coerced to a node if possible.",
                            :type :var}
                           {:name prefix,
                            :file "rewrite_clj/zip/editz.cljc",
                            :line 75,
                            :arglists ([zloc s]),
                            :doc "Return zipper with the current node in `zloc` prefixed with string `s`.\nOperates on token node or a multi-line node, else exception is thrown.\nWhen multi-line, all lines are prefixed.\n\nTODO: either multi-line handling is broken or I don't understand intent of code.",
                            :type :var}
                           {:name replace,
                            :file "rewrite_clj/zip/editz.cljc",
                            :line 12,
                            :arglists ([zloc value]),
                            :doc "Return zipper with the current node in `zloc` replaced with one representing `value`.\n`value` will be coerced to a node if possible.",
                            :type :var}
                           {:name splice,
                            :file "rewrite_clj/zip/editz.cljc",
                            :line 37,
                            :arglists ([zloc]),
                            :doc "Return zipper with the children of the current node in `zloc` merged into itself.\n(akin to Clojure's `unquote-splicing` macro: `~@...`).\n- if the node is not one that can have children, no modification will\n  be performed.\n- if the node has no or only whitespace children, it will be removed.\n- otherwise, splicing will be performed, moving the zipper to the first\n  non-whitespace child afterwards.",
                            :type :var}
                           {:name suffix,
                            :file "rewrite_clj/zip/editz.cljc",
                            :line 90,
                            :arglists ([zloc s]),
                            :doc "Return zipper with the current node in `zloc` suffixed with string `s`.\nOperates on token node or a multi-line node, else exception is thrown.\nWhen multi-line, all lines are suffixed.\n\nTODO: either multi-line handling is broken or I don't understand intent of code.",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.zip.editz,
                 :publics ({:name edit,
                            :file "rewrite_clj/zip/editz.cljc",
                            :line 26,
                            :arglists ([zloc f & args]),
                            :doc "Return zipper with the current node in `zloc` replaced with the result of:\n\n(`f` (s-expression node) `args`)\n\nThe result of `f` will be coerced to a node if possible.",
                            :type :var}
                           {:name prefix,
                            :file "rewrite_clj/zip/editz.cljc",
                            :line 75,
                            :arglists ([zloc s]),
                            :doc "Return zipper with the current node in `zloc` prefixed with string `s`.\nOperates on token node or a multi-line node, else exception is thrown.\nWhen multi-line, all lines are prefixed.\n\nTODO: either multi-line handling is broken or I don't understand intent of code.",
                            :type :var}
                           {:name replace,
                            :file "rewrite_clj/zip/editz.cljc",
                            :line 12,
                            :arglists ([zloc value]),
                            :doc "Return zipper with the current node in `zloc` replaced with one representing `value`.\n`value` will be coerced to a node if possible.",
                            :type :var}
                           {:name splice,
                            :file "rewrite_clj/zip/editz.cljc",
                            :line 37,
                            :arglists ([zloc]),
                            :doc "Return zipper with the children of the current node in `zloc` merged into itself.\n(akin to Clojure's `unquote-splicing` macro: `~@...`).\n- if the node is not one that can have children, no modification will\n  be performed.\n- if the node has no or only whitespace children, it will be removed.\n- otherwise, splicing will be performed, moving the zipper to the first\n  non-whitespace child afterwards.",
                            :type :var}
                           {:name suffix,
                            :file "rewrite_clj/zip/editz.cljc",
                            :line 90,
                            :arglists ([zloc s]),
                            :doc "Return zipper with the current node in `zloc` suffixed with string `s`.\nOperates on token node or a multi-line node, else exception is thrown.\nWhen multi-line, all lines are suffixed.\n\nTODO: either multi-line handling is broken or I don't understand intent of code.",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.zip.find,
                 :publics ({:name find,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 29,
                            :arglists ([zloc p?] [zloc f p?]),
                            :doc "Return the first node satisfying predicate `p?` seaching from the current node\nin `zloc` traversing by function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var}
                           {:name find-depth-first,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 59,
                            :arglists ([zloc p?]),
                            :doc "Return first node satisfying predicate `p?` searching depth-first from\nthe current node in `zloc`.",
                            :type :var}
                           {:name find-last-by-pos,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 44,
                            :arglists ([zloc pos] [zloc pos p?]),
                            :doc "Return the last node spanning position `pos` that satisfies predicate `p?`\n searching depth-first from the current node in `zloc`.\n\nNOTE: Does not ignore whitespace/comment nodes.",
                            :type :var}
                           {:name find-next,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 65,
                            :arglists ([zloc p?] [zloc f p?]),
                            :doc "Return the first node satisfying predicate `p?` searching one movement `f` from the current\nnode in `zloc` traversing by function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var}
                           {:name find-next-depth-first,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 75,
                            :arglists ([zloc p?]),
                            :doc "Return the first node satisfying predicate `p?` searching depth-first from one\nnode after the current node in `zloc`",
                            :type :var}
                           {:name find-next-tag,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 91,
                            :arglists ([zloc t] [zloc f t]),
                            :doc "Return the first node with tag `t` searching one movement `f` from the current\nnode in `zloc` traversing by function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var}
                           {:name find-next-token,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 118,
                            :arglists ([zloc p?] [zloc f p?]),
                            :doc "Return the first token node satisfying predicate `p?` searching from the current node in `zloc` traversing\nby function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var}
                           {:name find-next-value,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 141,
                            :arglists ([zloc v] [zloc f v]),
                            :doc "Return the first token node with value `v` searching one movement `f` from the current node in `zloc` traversing\nby function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var}
                           {:name find-tag,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 81,
                            :arglists ([zloc t] [zloc f t]),
                            :doc "Return the first node with tag `t` searching from the current node in `zloc` traversing by\nfunction `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var}
                           {:name find-tag-by-pos,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 102,
                            :arglists ([zloc pos t]),
                            :doc "Return the last node spanning position `pos` with tag `t` searching depth-first from the current node in `zloc`.\n",
                            :type :var}
                           {:name find-token,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 107,
                            :arglists ([zloc p?] [zloc f p?]),
                            :doc "Return the first token node satisfying predicate `p?` searching from the current node in `zloc` traversing\nby function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var}
                           {:name find-value,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 128,
                            :arglists ([zloc v] [zloc f v]),
                            :doc "Return the first token node with value `v` searching one movement `f` from the current node in `zloc` traversing\nby function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.zip.findz,
                 :publics ({:name find,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 29,
                            :arglists ([zloc p?] [zloc f p?]),
                            :doc "Return the first node satisfying predicate `p?` seaching from the current node\nin `zloc` traversing by function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var}
                           {:name find-depth-first,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 59,
                            :arglists ([zloc p?]),
                            :doc "Return first node satisfying predicate `p?` searching depth-first from\nthe current node in `zloc`.",
                            :type :var}
                           {:name find-last-by-pos,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 44,
                            :arglists ([zloc pos] [zloc pos p?]),
                            :doc "Return the last node spanning position `pos` that satisfies predicate `p?`\n searching depth-first from the current node in `zloc`.\n\nNOTE: Does not ignore whitespace/comment nodes.",
                            :type :var}
                           {:name find-next,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 65,
                            :arglists ([zloc p?] [zloc f p?]),
                            :doc "Return the first node satisfying predicate `p?` searching one movement `f` from the current\nnode in `zloc` traversing by function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var}
                           {:name find-next-depth-first,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 75,
                            :arglists ([zloc p?]),
                            :doc "Return the first node satisfying predicate `p?` searching depth-first from one\nnode after the current node in `zloc`",
                            :type :var}
                           {:name find-next-tag,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 91,
                            :arglists ([zloc t] [zloc f t]),
                            :doc "Return the first node with tag `t` searching one movement `f` from the current\nnode in `zloc` traversing by function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var}
                           {:name find-next-token,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 118,
                            :arglists ([zloc p?] [zloc f p?]),
                            :doc "Return the first token node satisfying predicate `p?` searching from the current node in `zloc` traversing\nby function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var}
                           {:name find-next-value,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 141,
                            :arglists ([zloc v] [zloc f v]),
                            :doc "Return the first token node with value `v` searching one movement `f` from the current node in `zloc` traversing\nby function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var}
                           {:name find-tag,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 81,
                            :arglists ([zloc t] [zloc f t]),
                            :doc "Return the first node with tag `t` searching from the current node in `zloc` traversing by\nfunction `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var}
                           {:name find-tag-by-pos,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 102,
                            :arglists ([zloc pos t]),
                            :doc "Return the last node spanning position `pos` with tag `t` searching depth-first from the current node in `zloc`.\n",
                            :type :var}
                           {:name find-token,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 107,
                            :arglists ([zloc p?] [zloc f p?]),
                            :doc "Return the first token node satisfying predicate `p?` searching from the current node in `zloc` traversing\nby function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var}
                           {:name find-value,
                            :file "rewrite_clj/zip/findz.cljc",
                            :line 128,
                            :arglists ([zloc v] [zloc f v]),
                            :doc "Return the first token node with value `v` searching one movement `f` from the current node in `zloc` traversing\nby function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.zip.insert,
                 :publics ({:name append-child,
                            :file "rewrite_clj/zip/insert.cljc",
                            :line 52,
                            :arglists ([zloc item]),
                            :doc "Return zipper with `item` appended as last child of the current node in `zloc`.\nWill insert a space if necessary.",
                            :type :var}
                           {:name insert-child,
                            :file "rewrite_clj/zip/insert.cljc",
                            :line 43,
                            :arglists ([zloc item]),
                            :doc "Return zipper with `item` inserted as the first child of the current node in `zloc`.\n",
                            :type :var}
                           {:name insert-left,
                            :file "rewrite_clj/zip/insert.cljc",
                            :line 33,
                            :arglists ([zloc item]),
                            :doc "Return zipper with `item` inserted to the left of the current node in `zloc`.\nWill insert a space if necessary.",
                            :type :var}
                           {:name insert-right,
                            :file "rewrite_clj/zip/insert.cljc",
                            :line 23,
                            :arglists ([zloc item]),
                            :doc "Return zipper with `item` inserted to the right of the current node in `zloc`.\nWill insert a space if necessary.",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.zip.move,
                 :publics ({:name down,
                            :file "rewrite_clj/zip/move.cljc",
                            :line 16,
                            :arglists ([zloc]),
                            :doc "Return zipper with location moved down to next non-whitespace/non-comment node in `zloc`.\n",
                            :type :var}
                           {:name end?,
                            :file "rewrite_clj/zip/move.cljc",
                            :line 35,
                            :arglists ([zloc]),
                            :doc "Return true if `zloc` is at end of depth-first traversal.\n",
                            :type :var}
                           {:name left,
                            :file "rewrite_clj/zip/move.cljc",
                            :line 11,
                            :arglists ([zloc]),
                            :doc "Return zipper with location moved left to next non-whitespace/non-comment node in `zloc`.\n",
                            :type :var}
                           {:name leftmost,
                            :file "rewrite_clj/zip/move.cljc",
                            :line 59,
                            :arglists ([zloc]),
                            :doc "Return zipper with location moved to the leftmost non-whitespace/non-comment node in `zloc`.\n",
                            :type :var}
                           {:name leftmost?,
                            :file "rewrite_clj/zip/move.cljc",
                            :line 47,
                            :arglists ([zloc]),
                            :doc "Return true if at leftmost non-whitespace/non-comment node in `zloc`.\n",
                            :type :var}
                           {:name next,
                            :file "rewrite_clj/zip/move.cljc",
                            :line 26,
                            :arglists ([zloc]),
                            :doc "Return zipper with location moved to the next depth-first non-whitespace/non-comment node in `zloc`.\n",
                            :type :var}
                           {:name prev,
                            :file "rewrite_clj/zip/move.cljc",
                            :line 52,
                            :arglists ([zloc]),
                            :doc "Return zipper with location moved to the previous depth-first non-whitespace/non-comment node in `zloc`.\n",
                            :type :var}
                           {:name right,
                            :file "rewrite_clj/zip/move.cljc",
                            :line 6,
                            :arglists ([zloc]),
                            :doc "Return zipper with location moved right to next non-whitespace/non-comment node in `zloc`.\n",
                            :type :var}
                           {:name rightmost,
                            :file "rewrite_clj/zip/move.cljc",
                            :line 66,
                            :arglists ([zloc]),
                            :doc "Return zipper with location moved to the rightmost non-whitespace/non-comment node in `zloc`.\n",
                            :type :var}
                           {:name rightmost?,
                            :file "rewrite_clj/zip/move.cljc",
                            :line 42,
                            :arglists ([zloc]),
                            :doc "Return true if at rightmost non-whitespace/non-comment node in `zloc`.\n",
                            :type :var}
                           {:name up,
                            :file "rewrite_clj/zip/move.cljc",
                            :line 21,
                            :arglists ([zloc]),
                            :doc "Return zipper with location moved up to next non-whitespace/non-comment node in `zloc`.\n",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.zip.remove,
                 :publics ({:name remove,
                            :file "rewrite_clj/zip/removez.cljc",
                            :line 28,
                            :arglists ([zloc]),
                            :doc "Return zipper with current node in `zloc` removed. Returned zipper location\n is moved to the first non-whitespace node preceding removed node in a depth-first walk.\n Removes whitespace appropriately.\n\n- `[1  2  3]   => [1  3]`\n- `[1 2]       => [1]`\n- `[1 2]       => [2]`\n- `[1]         => []`\n- `[  1  ]     => []`\n- `[1 [2 3] 4] => [1 [2 3]]`\n- `[1 [2 3] 4] => [[2 3] 4]`\n\n If the removed node is at the rightmost location, both preceding and trailing spaces are removed,\n otherwise only trailing spaces are removed. This means that a following element\n (no matter whether on the same line or not) will end up in the same position\n (line/column) as the removed one, _unless_ a comment lies between the original\n node and the neighbour.",
                            :type :var}
                           {:name remove-preserve-newline,
                            :file "rewrite_clj/zip/removez.cljc",
                            :line 51,
                            :arglists ([zloc]),
                            :doc "Same as [[remove]] but preserves newlines.\n",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.zip.removez,
                 :publics ({:name remove,
                            :file "rewrite_clj/zip/removez.cljc",
                            :line 28,
                            :arglists ([zloc]),
                            :doc "Return zipper with current node in `zloc` removed. Returned zipper location\n is moved to the first non-whitespace node preceding removed node in a depth-first walk.\n Removes whitespace appropriately.\n\n- `[1  2  3]   => [1  3]`\n- `[1 2]       => [1]`\n- `[1 2]       => [2]`\n- `[1]         => []`\n- `[  1  ]     => []`\n- `[1 [2 3] 4] => [1 [2 3]]`\n- `[1 [2 3] 4] => [[2 3] 4]`\n\n If the removed node is at the rightmost location, both preceding and trailing spaces are removed,\n otherwise only trailing spaces are removed. This means that a following element\n (no matter whether on the same line or not) will end up in the same position\n (line/column) as the removed one, _unless_ a comment lies between the original\n node and the neighbour.",
                            :type :var}
                           {:name remove-preserve-newline,
                            :file "rewrite_clj/zip/removez.cljc",
                            :line 51,
                            :arglists ([zloc]),
                            :doc "Same as [[remove]] but preserves newlines.\n",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.zip.seq,
                 :publics ({:name assoc,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 111,
                            :arglists ([zloc k v]),
                            :doc "Returns zipper with key `k` set to value `v` when current node in `zloc` is a map node.\nReturns zipper with index `k` set to value `v` when current node in `zloc` is a sequence.",
                            :type :var}
                           {:name get,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 98,
                            :arglists ([zloc k]),
                            :doc "Returns value node mapped to key `k` when current node in `zloc` is a map node.\nReturns nth `k` value node when current node in `zloc` is a sequence node.",
                            :type :var}
                           {:name list?,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 19,
                            :arglists ([zloc]),
                            :doc "Returns true if current node in `zloc` is a list.\n",
                            :type :var}
                           {:name map,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 83,
                            :arglists ([f zloc]),
                            :doc "Returns zipper with function `f` applied to all value nodes of current node in `zloc`.\nCurrent node must be a sequence node.\n\nIterates over:\n- value nodes of maps\n- each element of a seq",
                            :type :var}
                           {:name map-keys,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 70,
                            :arglists ([f zloc]),
                            :doc "Returns zipper with function `f` applied to all key nodes of the current node in `zloc`.\nCurrent node must be map node.",
                            :type :var}
                           {:name map-vals,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 55,
                            :arglists ([f zloc]),
                            :doc "Returns zipper with function `f` applied to all value current node in `zloc`.\nCurrent node must be map node.",
                            :type :var}
                           {:name map?,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 34,
                            :arglists ([zloc]),
                            :doc "Returns true if current node in `zloc` is a map.\n",
                            :type :var}
                           {:name seq?,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 12,
                            :arglists ([zloc]),
                            :doc "Returns true if current node in `zloc` is a sequence.\n",
                            :type :var}
                           {:name set?,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 29,
                            :arglists ([zloc]),
                            :doc "Returns true if current node in `zloc` is a set.\n",
                            :type :var}
                           {:name vector?,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 24,
                            :arglists ([zloc]),
                            :doc "Returns true if current node in `zloc` is a vector.\n",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.zip.seqz,
                 :publics ({:name assoc,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 111,
                            :arglists ([zloc k v]),
                            :doc "Returns zipper with key `k` set to value `v` when current node in `zloc` is a map node.\nReturns zipper with index `k` set to value `v` when current node in `zloc` is a sequence.",
                            :type :var}
                           {:name get,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 98,
                            :arglists ([zloc k]),
                            :doc "Returns value node mapped to key `k` when current node in `zloc` is a map node.\nReturns nth `k` value node when current node in `zloc` is a sequence node.",
                            :type :var}
                           {:name list?,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 19,
                            :arglists ([zloc]),
                            :doc "Returns true if current node in `zloc` is a list.\n",
                            :type :var}
                           {:name map,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 83,
                            :arglists ([f zloc]),
                            :doc "Returns zipper with function `f` applied to all value nodes of current node in `zloc`.\nCurrent node must be a sequence node.\n\nIterates over:\n- value nodes of maps\n- each element of a seq",
                            :type :var}
                           {:name map-keys,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 70,
                            :arglists ([f zloc]),
                            :doc "Returns zipper with function `f` applied to all key nodes of the current node in `zloc`.\nCurrent node must be map node.",
                            :type :var}
                           {:name map-vals,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 55,
                            :arglists ([f zloc]),
                            :doc "Returns zipper with function `f` applied to all value current node in `zloc`.\nCurrent node must be map node.",
                            :type :var}
                           {:name map?,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 34,
                            :arglists ([zloc]),
                            :doc "Returns true if current node in `zloc` is a map.\n",
                            :type :var}
                           {:name seq?,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 12,
                            :arglists ([zloc]),
                            :doc "Returns true if current node in `zloc` is a sequence.\n",
                            :type :var}
                           {:name set?,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 29,
                            :arglists ([zloc]),
                            :doc "Returns true if current node in `zloc` is a set.\n",
                            :type :var}
                           {:name vector?,
                            :file "rewrite_clj/zip/seqz.cljc",
                            :line 24,
                            :arglists ([zloc]),
                            :doc "Returns true if current node in `zloc` is a vector.\n",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.zip.subedit,
                 :publics ({:name edit->,
                            :file "rewrite_clj/zip/subedit.cljc",
                            :line 41,
                            :arglists ([zloc & body]),
                            :doc "Like `->`. Threads `zloc` through forms.\nThe resulting zipper will be located at the same path (i.e. the same\nnumber of downwards and right movements from the root) as incoming `zloc`.",
                            :type :macro}
                           {:name edit->>,
                            :file "rewrite_clj/zip/subedit.cljc",
                            :line 48,
                            :arglists ([zloc & body]),
                            :doc "Like `->>`. Threads `zloc` through forms.\nThe resulting zipper will be located at the same path (i.e. the same\nnumber of downwards and right movements from the root) as incoming `zloc`.",
                            :type :macro}
                           {:name edit-node,
                            :file "rewrite_clj/zip/subedit.cljc",
                            :line 32,
                            :arglists ([zloc f]),
                            :doc "Return zipper applying function `f` to `zloc`. The resulting\nzipper will be located at the same path (i.e. the same number of\ndownwards and right movements from the root) incoming `zloc`.",
                            :type :var}
                           {:name subedit->,
                            :file "rewrite_clj/zip/subedit.cljc",
                            :line 72,
                            :arglists ([zloc & body]),
                            :doc "Like `->`. Threads `zloc`, as an isolated sub-tree through forms, then zips\nup to, and locates at, the root of the modified sub-tree.",
                            :type :macro}
                           {:name subedit->>,
                            :file "rewrite_clj/zip/subedit.cljc",
                            :line 78,
                            :arglists ([zloc & body]),
                            :doc "Like `->`. Threads `zloc`, as an isolated sub-tree through forms, then zips\nup to, and locates at, the root of the modified sub-tree.",
                            :type :macro}
                           {:name subedit-node,
                            :file "rewrite_clj/zip/subedit.cljc",
                            :line 64,
                            :arglists ([zloc f]),
                            :doc "Return zipper replacing current node in `zloc` with result of `f` applied to said node as an isolated sub-tree.\nThe resulting zipper will be located on the root of the modified sub-tree.",
                            :type :var}
                           {:name subzip,
                            :file "rewrite_clj/zip/subedit.cljc",
                            :line 57,
                            :arglists ([zloc]),
                            :doc "Create and return a zipper whose root is the current node in `zloc`.\n",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.zip.walk,
                 :publics ({:name postwalk,
                            :file "rewrite_clj/zip/walk.cljc",
                            :line 38,
                            :arglists ([zloc f] [zloc p? f]),
                            :doc "Return zipper modified by an isolated depth-first post-order traversal.\nTraversal starts at the current node in `zloc` and continues to the end of the isolated sub-tree.\nFunction `f` is called on the zipper locations satisfying predicate `p?`, or all locations when `p?` is absent,\nand must return a valid zipper - modified or not.\n\nWARNING: when function `f` changes the location in the zipper, normal traversal will be affected.",
                            :added "0.4.9",
                            :type :var}
                           {:name postwalk-subtree,
                            :file "rewrite_clj/zip/walk.cljc",
                            :line 28,
                            :arglists ([p? f loc]),
                            :type :var}
                           {:name prewalk,
                            :file "rewrite_clj/zip/walk.cljc",
                            :line 16,
                            :arglists ([zloc f] [zloc p? f]),
                            :doc "Return zipper modified by an isolated depth-first pre-order traversal.\nTraversal starts at the current node in `zloc` and continues to the end of the isolated sub-tree.\nFunction `f` is called on the zipper locations satisfying predicate `p?`, or all locations when `p?` is absent,\nand must return a valid zipper - modified or not.\n\nWARNING: when function `f` changes the location in the zipper, normal traversal will be affected.",
                            :type :var})}
                {:no-doc true,
                 :name rewrite-clj.zip.whitespace,
                 :publics ({:name append-newline,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 113,
                            :arglists ([zloc & [n]]),
                            :doc "DEPRECATED: renamed to [[insert-newline-right]].\n",
                            :deprecated "0.5.0",
                            :type :var}
                           {:name append-space,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 103,
                            :arglists ([zloc & [n]]),
                            :doc "DEPRECATED: renamed to [[insert-space-right]].\n",
                            :deprecated "0.5.0",
                            :type :var}
                           {:name comment?,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 17,
                            :arglists ([zloc]),
                            :doc "Returns true when the current node in `zloc` is a comment.\n",
                            :type :var}
                           {:name insert-newline-left,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 82,
                            :arglists ([zloc] [zloc n]),
                            :doc "Return zipper with `n` newlines node inserted to the left of the current node in `zloc`.\n`n` defaults to 1.",
                            :added "0.5.0",
                            :type :var}
                           {:name insert-newline-right,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 89,
                            :arglists ([zloc] [zloc n]),
                            :doc "Return zipper with `n` newlines node inserted to the right of the current node in `zloc`.\n`n` defaults to 1.",
                            :added "0.5.0",
                            :type :var}
                           {:name insert-space-left,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 62,
                            :arglists ([zloc] [zloc n]),
                            :doc "Return zipper with `n` space whitespace node inserted to the left of the current node in `zloc`.\n`n` defaults to 1.",
                            :added "0.5.0",
                            :type :var}
                           {:name insert-space-right,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 72,
                            :arglists ([zloc] [zloc n]),
                            :doc "Return zipper with `n` space whitespace node inserted to the right of the current node in `zloc`.\n`n` defaults to 1.",
                            :added "0.5.0",
                            :type :var}
                           {:name linebreak?,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 12,
                            :arglists ([zloc]),
                            :doc "Returns true when the current node in `zloc` is a linebreak.\n",
                            :type :var}
                           {:name prepend-newline,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 108,
                            :arglists ([zloc & [n]]),
                            :doc "DEPRECATED: renamed to [[insert-newline-left]].\n",
                            :deprecated "0.5.0",
                            :type :var}
                           {:name prepend-space,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 98,
                            :arglists ([zloc & [n]]),
                            :doc "DEPRECATED: renamed to [[insert-space-left]].\n",
                            :deprecated "0.5.0",
                            :type :var}
                           {:name skip,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 37,
                            :arglists ([f p? zloc]),
                            :doc "Return zipper with location moved to first location not satisfying predicate `p?` starting from the node in\n`zloc` and traversing by function `f`.",
                            :type :var}
                           {:name skip-whitespace,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 47,
                            :arglists ([zloc] [f zloc]),
                            :doc "Return zipper with location moved to first non-whitespace/non-comment starting from current node in `zloc`\nand traversing by function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                            :type :var}
                           {:name skip-whitespace-left,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 55,
                            :arglists ([zloc]),
                            :doc "Return zipper with location moved to first non-whitespace/non-comment starting from current node in `zloc` traversing left.\n",
                            :type :var}
                           {:name whitespace-not-linebreak?,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 22,
                            :arglists ([zloc]),
                            :doc "Returns true when current node in `zloc` is a whitespace but not a linebreak.\n",
                            :type :var}
                           {:name whitespace-or-comment?,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 29,
                            :arglists ([zloc]),
                            :doc "Returns true when current node in `zloc` is whitespace or a comment.\n",
                            :type :var}
                           {:name whitespace?,
                            :file "rewrite_clj/zip/whitespace.cljc",
                            :line 7,
                            :arglists ([zloc]),
                            :doc "Returns true when the current the node in `zloc` is a Clojure whitespace (which includes the comma).\n",
                            :type :var})}),
         "cljs" ({:name rewrite-clj,
                  :doc "APIs to navigate and update Clojure/ClojureScript/EDN source code.\n\nStart with the [[rewrite-clj.parser]] or [[rewrite-clj.zip]] to ingest your source code,\nthen use the [[rewrite-clj.zip]] to navigate and/or change it. [[rewrite-clj.node]]\nwill help you to work with nodes in the zipper tree.\n\n[[rewrite-clj.paredit]] first appeared in the ClojureScript only version of\nrewrite-clj and supports structured editing of the zipper tree.",
                  :publics ()}
                 {:name rewrite-clj.custom-zipper.core,
                  :doc "Functional hierarchical zipper, with navigation, editing,\nand enumeration.  See Huet.\nModified to optionally support row col position tracking.",
                  :no-doc true,
                  :author "Rich Hickey",
                  :publics ({:name append-child,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 219,
                             :arglists ([zloc item]),
                             :doc "Returns zipper with `item` inserted as the rightmost child of the current node in `zloc`,\nwithout moving.",
                             :type :var}
                            {:name branch?,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 56,
                             :arglists ([zloc]),
                             :doc "Returns true if the current node in `zloc` is a branch.\n",
                             :type :var}
                            {:name children,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 61,
                             :arglists ([{:keys [node], :as zloc}]),
                             :doc "Returns a seq of the children of current node in `zloc`, which must be a branch.\n",
                             :type :var}
                            {:name custom-zipper,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 28,
                             :arglists ([root]),
                             :no-doc true,
                             :type :var}
                            {:name custom-zipper?,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 45,
                             :arglists ([value]),
                             :no-doc true,
                             :type :var}
                            {:name down,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 96,
                             :arglists ([zloc]),
                             :doc "Returns zipper with the location at the leftmost child of current node in `zloc`, or\nnil if no children.",
                             :type :var}
                            {:name edit,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 206,
                             :arglists ([zloc f & args]),
                             :doc "Returns zipper with value of `(f current-node args)` replacing current node in `zloc`\n",
                             :type :var}
                            {:name end?,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 251,
                             :arglists ([zloc]),
                             :doc "Returns true if at end of depth-first walk in `zloc`.\n",
                             :type :var}
                            {:name insert-child,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 213,
                             :arglists ([zloc item]),
                             :doc "Returns zipper with `item` inserted as the leftmost child of the current node in `zloc`,\nwithout moving location.",
                             :type :var}
                            {:name insert-left,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 178,
                             :arglists ([zloc item]),
                             :doc "Returns zipper with `item` inserted as the left sibling of current node in `zloc`,\nwithout moving location.",
                             :type :var}
                            {:name insert-right,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 190,
                             :arglists ([zloc item]),
                             :doc "Returns zipper with `item` inserted as the right sibling of the current node in `zloc`,\nwithout moving location.",
                             :type :var}
                            {:name left,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 153,
                             :arglists ([zloc]),
                             :doc "Returns zipper with location at the left sibling of the current node in `zloc`, or nil.\n",
                             :type :var}
                            {:name leftmost,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 165,
                             :arglists ([zloc]),
                             :doc "Returns zipper with location at the leftmost sibling of the current node in `zloc`, or self.\n",
                             :type :var}
                            {:name lefts,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 91,
                             :arglists ([zloc]),
                             :doc "Returns a seq of the left siblings of current node in `zloc`.\n",
                             :type :var}
                            {:name make-node,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 68,
                             :arglists ([_zloc node children]),
                             :doc "Returns a new branch node, given an existing `node` and new\n`children`. ",
                             :no-doc true,
                             :type :var}
                            {:name next,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 225,
                             :arglists ([{:keys [end?], :as zloc}]),
                             :doc "Returns zipper with location at the next depth-first location in the hierarchy in `zloc`.\nWhen reaching the end, returns a distinguished zipper detectable via [[end?]]. If already\nat the end, stays there.",
                             :type :var}
                            {:name node,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 51,
                             :arglists ([zloc]),
                             :doc "Returns the current node in `zloc`.\n",
                             :type :var}
                            {:name position,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 74,
                             :arglists ([zloc]),
                             :doc "Returns the ones-based `[row col]` of the start of the current node in `zloc`.\n",
                             :type :var}
                            {:name position-span,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 84,
                             :arglists ([zloc]),
                             :doc "Returns the ones-based `[[start-row start-col] [end-row end-col]]` of the current node in `zloc`.\n",
                             :type :var}
                            {:name prev,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 240,
                             :arglists ([zloc]),
                             :doc "Returns zipper with location at the previous depth-first location in the hierarchy in `zloc`.\nIf already at the root, returns nil.",
                             :type :var}
                            {:name remove,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 256,
                             :arglists ([zloc]),
                             :doc "Returns zipper with current node in `zloc` removed, with location at node that would have preceded\nit in a depth-first walk.",
                             :type :var}
                            {:name replace,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 201,
                             :arglists ([zloc node]),
                             :doc "Returns zipper with `node` replacing current node in `zloc`, without moving location.\n",
                             :type :var}
                            {:name right,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 135,
                             :arglists ([zloc]),
                             :doc "Returns zipper with location at the right sibling of the current node in `zloc`, or nil.\n",
                             :type :var}
                            {:name rightmost,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 146,
                             :arglists ([zloc]),
                             :doc "Returns zipper with location at the rightmost sibling of the current node in `zloc`, or self.\n",
                             :type :var}
                            {:name root,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 125,
                             :arglists ([{:keys [end?], :as zloc}]),
                             :doc "Zips all the way up `zloc` and returns zipper at the root node, reflecting any changes.\n",
                             :type :var}
                            {:name up,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 111,
                             :arglists ([zloc]),
                             :doc "Returns zipper with the location at the parent of current node in `zloc`, or nil if at\nthe top.",
                             :type :var}
                            {:name zipper,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 37,
                             :arglists ([root]),
                             :no-doc true,
                             :type :var})}
                 {:name rewrite-clj.custom-zipper.switchable,
                  :no-doc true,
                  :publics ({:name custom-zipper?,
                             :file "rewrite_clj/custom_zipper/switchable.cljc",
                             :line 4,
                             :arglists ([value]),
                             :no-doc true,
                             :type :var}
                            {:name defn-switchable,
                             :file "rewrite_clj/custom_zipper/switchable.cljc",
                             :line 8,
                             :arglists ([sym docstring params & body]),
                             :type :macro})}
                 {:name rewrite-clj.custom-zipper.utils,
                  :no-doc true,
                  :publics ({:name remove-and-move-left,
                             :file "rewrite_clj/custom_zipper/utils.cljc",
                             :line 62,
                             :arglists ([loc]),
                             :doc "Remove current node and move left. If current node is at the leftmost\nlocation, returns `nil`.",
                             :type :var}
                            {:name remove-and-move-right,
                             :file "rewrite_clj/custom_zipper/utils.cljc",
                             :line 83,
                             :arglists ([loc]),
                             :doc "Remove current node and move right. If current node is at the rightmost\nlocation, returns `nil`.",
                             :type :var}
                            {:name remove-and-move-up,
                             :file "rewrite_clj/custom_zipper/utils.cljc",
                             :line 104,
                             :arglists ([loc]),
                             :doc "Remove the current node and move up.\n`[a [b |c d]] -> [a |[b d]]`\n`[a [|b c d]] -> [a |[c d]]`",
                             :type :var}
                            {:name remove-left,
                             :file "rewrite_clj/custom_zipper/utils.cljc",
                             :line 25,
                             :arglists ([loc]),
                             :doc "Remove left sibling of the current node (if there is one).\n",
                             :type :var}
                            {:name remove-left-while,
                             :file "rewrite_clj/custom_zipper/utils.cljc",
                             :line 49,
                             :arglists ([zloc p?]),
                             :doc "Remove elements to the left of the current zipper location as long as\nthe given predicate matches.",
                             :type :var}
                            {:name remove-right,
                             :file "rewrite_clj/custom_zipper/utils.cljc",
                             :line 15,
                             :arglists ([loc]),
                             :doc "Remove right sibling of the current node (if there is one).\n",
                             :type :var}
                            {:name remove-right-while,
                             :file "rewrite_clj/custom_zipper/utils.cljc",
                             :line 38,
                             :arglists ([zloc p?]),
                             :doc "Remove elements to the right of the current zipper location as long as\nthe given predicate matches.",
                             :type :var})}
                 {:name rewrite-clj.interop,
                  :no-doc true,
                  :publics ({:name clojure-whitespace?,
                             :file "rewrite_clj/interop.cljc",
                             :line 31,
                             :arglists ([c]),
                             :type :var}
                            {:name int->str,
                             :file "rewrite_clj/interop.cljc",
                             :line 18,
                             :arglists ([n base]),
                             :type :var}
                            {:name max-int,
                             :file "rewrite_clj/interop.cljc",
                             :line 27,
                             :arglists ([]),
                             :type :var}
                            {:name meta-available?,
                             :file "rewrite_clj/interop.cljc",
                             :line 36,
                             :arglists ([data]),
                             :type :var}
                            {:name min-int,
                             :file "rewrite_clj/interop.cljc",
                             :line 23,
                             :arglists ([]),
                             :type :var}
                            {:name simple-format,
                             :file "rewrite_clj/interop.cljc",
                             :line 5,
                             :arglists ([template & args]),
                             :doc "Interop version of string format\nNote that there a big differences between Java's format and Google Closure's format - we don't address them.\n%d and %s are known to work in both.",
                             :type :var}
                            {:name str->int,
                             :file "rewrite_clj/interop.cljc",
                             :line 13,
                             :arglists ([s]),
                             :type :var})}
                 {:name rewrite-clj.node,
                  :doc "Create and evaluate nodes.\n\nAll nodes represent Clojure/ClojureScript/EDN.",
                  :publics ({:name child-sexprs,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 70,
                             :arglists ([node]),
                             :doc "Return all children converted to forms.\n",
                             :type :var}
                            {:name children,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 49,
                             :arglists ([node]),
                             :doc "Returns child nodes for `node`.\n",
                             :type :var}
                            {:name coerce,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 78,
                             :arglists ([form]),
                             :doc "Coerce `form` to node.\n",
                             :type :var}
                            {:name comma-node,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 86,
                             :arglists ([s]),
                             :doc "Create comma node of string `s`.\n",
                             :type :var}
                            {:name comma-separated,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 130,
                             :arglists ([nodes]),
                             :doc "Interleave `nodes` with `\", \"` nodes.\n",
                             :type :var}
                            {:name comma?,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 165,
                             :arglists ([node]),
                             :doc "Returns true if `node` represents a comma.\n",
                             :type :var}
                            {:name comment-node,
                             :file "rewrite_clj/node/comment.cljc",
                             :line 25,
                             :arglists ([s]),
                             :doc "Create node representing a comment with text `s`.\n",
                             :type :var}
                            {:name comment?,
                             :file "rewrite_clj/node/comment.cljc",
                             :line 31,
                             :arglists ([node]),
                             :doc "Returns true if `node` is a comment.\n",
                             :type :var}
                            {:name concat-strings,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 42,
                             :arglists ([nodes]),
                             :doc "Return string version of `nodes`.\n",
                             :no-doc true,
                             :type :var}
                            {:name deref-node,
                             :file "rewrite_clj/node/reader_macro.cljc",
                             :line 130,
                             :arglists ([children]),
                             :doc "Create node representing the dereferencing of a form with `children`. (`@...`)\nTakes either a seq of nodes or a single one.",
                             :type :var}
                            {:name eval-node,
                             :file "rewrite_clj/node/reader_macro.cljc",
                             :line 112,
                             :arglists ([children]),
                             :doc "Create node representing an inline evaluation with `children`. (`#=...`)\nTakes either a seq of nodes or a single one.",
                             :type :var}
                            {:name fn-node,
                             :file "rewrite_clj/node/fn.cljc",
                             :line 94,
                             :arglists ([children]),
                             :doc "Create node representing an anonymous function with `children`.\n",
                             :type :var}
                            {:name forms-node,
                             :file "rewrite_clj/node/forms.cljc",
                             :line 40,
                             :arglists ([children]),
                             :doc "Create top-level node wrapping multiple `children`\n(equivalent to an implicit `do` on the top-level).",
                             :type :var}
                            {:name inner?,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 49,
                             :arglists ([node]),
                             :doc "Returns true if `node` can have children.\n",
                             :type :var}
                            {:name integer-node,
                             :file "rewrite_clj/node/integer.cljc",
                             :line 34,
                             :arglists ([value] [value base]),
                             :doc "Create node representing an integer `value` in `base`.\n\n`base` defaults to 10.",
                             :type :var}
                            {:name keyword-node,
                             :file "rewrite_clj/node/keyword.cljc",
                             :line 40,
                             :arglists ([k & [namespaced?]]),
                             :doc "Create node representing a keyword `k`. If `namespaced?` is `true`\na keyword à la `::x` or `::ns/x` (i.e. namespaced/aliased) is generated.",
                             :type :var}
                            {:name leader-length,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 49,
                             :arglists ([node]),
                             :doc "Returns number of characters before children for `node`.\n",
                             :type :var}
                            {:name length,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 9,
                             :arglists ([node]),
                             :doc "Return number of characters for the string version of `node`.\n",
                             :type :var}
                            {:name line-separated,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 138,
                             :arglists ([nodes]),
                             :doc "Interleave `nodes` with newline nodes.\n",
                             :type :var}
                            {:name linebreak?,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 160,
                             :arglists ([node]),
                             :doc "Returns true if `node` represents linebreak(s).\n",
                             :type :var}
                            {:name list-node,
                             :file "rewrite_clj/node/seq.cljc",
                             :line 42,
                             :arglists ([children]),
                             :doc "Create a node representing a list with `children`.\n",
                             :type :var}
                            {:name map-node,
                             :file "rewrite_clj/node/seq.cljc",
                             :line 57,
                             :arglists ([children]),
                             :doc "Create a node representing an map with `children`.\n",
                             :type :var}
                            {:name meta-node,
                             :file "rewrite_clj/node/meta.cljc",
                             :line 39,
                             :arglists ([children] [metadata data]),
                             :doc "Create node representing a form `data` and its `metadata`.\n",
                             :type :var}
                            {:name namespaced-map-node,
                             :file "rewrite_clj/node/namespaced_map.cljc",
                             :line 80,
                             :arglists ([children]),
                             :doc "Create a node representing a namespaced map. There are 3 types of namespaced maps:\n\n 1. prefix namespaced map\n The prefix is a keyword which specifies to a namespace.\n Example: `#:my.name.space{:a 1}`\n\n 2. auto-resolve alias namespaced map\n The prefix is an auto-resolve keyword specifies a namespace alias.\n Example: `#::ns-alias{:b 3}`\n\n 3. auto-resolve namespaced map\n The prefix is `::` which specifies the current namespace.\n Example: `#::{:c 4}`\n\nFirst child is the prefix, followed by optional whitespace then map node.\nTODO: this still seems hacky to me.\nPrefix must be a token-node with a keyword value. Use (keyword ':') for auto-resolve.",
                             :type :var}
                            {:name newline-node,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 92,
                             :arglists ([s]),
                             :doc "Create newline node of string `s`.\n",
                             :type :var}
                            {:name newlines,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 124,
                             :arglists ([n]),
                             :doc "Create node representing `n` newline characters.\n",
                             :type :var}
                            {:name printable-only?,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 9,
                             :arglists ([node]),
                             :doc "Return true if `node` cannot be converted to an s-expression element.\n",
                             :type :var}
                            {:name quote-node,
                             :file "rewrite_clj/node/quote.cljc",
                             :line 39,
                             :arglists ([children]),
                             :doc "Create node representing a quoted form with `children`.\nTakes either a seq of nodes or a single one.",
                             :type :var}
                            {:name raw-meta-node,
                             :file "rewrite_clj/node/meta.cljc",
                             :line 47,
                             :arglists ([children] [metadata data]),
                             :doc "Create node representing a form `data` and its `metadata` using the\n`#^` prefix.",
                             :type :var}
                            {:name reader-macro-node,
                             :file "rewrite_clj/node/reader_macro.cljc",
                             :line 123,
                             :arglists ([children]
                                        [macro-node form-node]),
                             :doc "Create node representing a reader macro with `children`. (`#... ...`)\n",
                             :type :var}
                            {:name regex-node,
                             :file "rewrite_clj/node/regex.cljc",
                             :line 19,
                             :arglists ([pattern-string]),
                             :doc "Create node representing a regex with `pattern-string`\n",
                             :type :var}
                            {:name replace-children,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 49,
                             :arglists ([node children]),
                             :doc "Returns `node` replacing current children with `children`.\n",
                             :type :var}
                            {:name set-node,
                             :file "rewrite_clj/node/seq.cljc",
                             :line 52,
                             :arglists ([children]),
                             :doc "Create a node representing a set with `children`.\n",
                             :type :var}
                            {:name sexpr,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 9,
                             :arglists ([node]),
                             :doc "Return `node` converted to form.\n",
                             :type :var}
                            {:name sexprs,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 30,
                             :arglists ([nodes]),
                             :doc "Return forms for `nodes`. Nodes that do not represent s-expression are skipped.\n",
                             :type :var}
                            {:name spaces,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 119,
                             :arglists ([n]),
                             :doc "Create node representing `n` spaces.\n",
                             :type :var}
                            {:name string,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 9,
                             :arglists ([node]),
                             :doc "Return the string version of `node`.\n",
                             :type :var}
                            {:name string-node,
                             :file "rewrite_clj/node/stringz.cljc",
                             :line 42,
                             :arglists ([lines]),
                             :doc "Create node representing a string value of `lines`.\n`lines` can be a seq of strings or a single one.",
                             :type :var}
                            {:name syntax-quote-node,
                             :file "rewrite_clj/node/quote.cljc",
                             :line 49,
                             :arglists ([children]),
                             :doc "Create node representing a syntax-quoted form with `children`.\nTakes either a seq of nodes or a single one.",
                             :type :var}
                            {:name tag,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 9,
                             :arglists ([node]),
                             :doc "Returns keyword representing type of `node`.\n",
                             :type :var}
                            {:name token-node,
                             :file "rewrite_clj/node/token.cljc",
                             :line 22,
                             :arglists ([value] [value string-value]),
                             :doc "Create node for an unspecified token of `value`.\n",
                             :type :var}
                            {:name uneval-node,
                             :file "rewrite_clj/node/uneval.cljc",
                             :line 34,
                             :arglists ([children]),
                             :doc "Create node representing an uneval `#_` form with `children`.\n",
                             :type :var}
                            {:name unquote-node,
                             :file "rewrite_clj/node/quote.cljc",
                             :line 59,
                             :arglists ([children]),
                             :doc "Create node representing an unquoted form with `children`. (`~...`)\nTakes either a seq of nodes or a single one.",
                             :type :var}
                            {:name unquote-splicing-node,
                             :file "rewrite_clj/node/quote.cljc",
                             :line 69,
                             :arglists ([children]),
                             :doc "Create node representing an unquote-spliced form with `children`. (`~@...`)\nTakes either a seq of nodes or a single one.",
                             :type :var}
                            {:name value,
                             :file "rewrite_clj/node.cljc",
                             :line 119,
                             :arglists ([node]),
                             :doc "DEPRECATED: Get first child as a pair of tag/sexpr (if inner node),\nor just the node's own sexpr. (use explicit analysis of `children`\n`child-sexprs` instead) ",
                             :deprecated "0.4.0",
                             :type :var}
                            {:name var-node,
                             :file "rewrite_clj/node/reader_macro.cljc",
                             :line 104,
                             :arglists ([children]),
                             :doc "Create node representing a var with `children`.\nTakes either a seq of nodes or a single one.",
                             :type :var}
                            {:name vector-node,
                             :file "rewrite_clj/node/seq.cljc",
                             :line 47,
                             :arglists ([children]),
                             :doc "Create a node representing a vector with `children`.\n",
                             :type :var}
                            {:name whitespace-node,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 80,
                             :arglists ([s]),
                             :doc "Create whitespace node of string `s`.\n",
                             :type :var}
                            {:name whitespace-nodes,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 104,
                             :arglists ([s]),
                             :doc "Convert string `s` of whitespace to whitespace/newline nodes.\n",
                             :type :var}
                            {:name whitespace-or-comment?,
                             :file "rewrite_clj/node.cljc",
                             :line 111,
                             :arglists ([node]),
                             :doc "Return true when `node` represents whitespace or comment.\n",
                             :type :var}
                            {:name whitespace?,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 151,
                             :arglists ([node]),
                             :doc "Returns true if `node represents whitespace.\n",
                             :type :var})}
                 {:name rewrite-clj.node.coercer,
                  :no-doc true,
                  :publics ({:name node-with-meta,
                             :file "rewrite_clj/node/coercer.cljc",
                             :line 43,
                             :arglists ([n value]),
                             :type :var})}
                 {:name rewrite-clj.node.comment,
                  :no-doc true,
                  :publics ({:name comment-node,
                             :file "rewrite_clj/node/comment.cljc",
                             :line 25,
                             :arglists ([s]),
                             :doc "Create node representing a comment with text `s`.\n",
                             :type :var}
                            {:name comment?,
                             :file "rewrite_clj/node/comment.cljc",
                             :line 31,
                             :arglists ([node]),
                             :doc "Returns true if `node` is a comment.\n",
                             :type :var}
                            {:name CommentNode,
                             :file "rewrite_clj/node/comment.cljc",
                             :line 6,
                             :type :var})}
                 {:name rewrite-clj.node.fn,
                  :no-doc true,
                  :publics ({:name fn-node,
                             :file "rewrite_clj/node/fn.cljc",
                             :line 94,
                             :arglists ([children]),
                             :doc "Create node representing an anonymous function with `children`.\n",
                             :type :var}
                            {:name FnNode,
                             :file "rewrite_clj/node/fn.cljc",
                             :line 64,
                             :type :var})}
                 {:name rewrite-clj.node.forms,
                  :no-doc true,
                  :publics ({:name forms-node,
                             :file "rewrite_clj/node/forms.cljc",
                             :line 40,
                             :arglists ([children]),
                             :doc "Create top-level node wrapping multiple `children`\n(equivalent to an implicit `do` on the top-level).",
                             :type :var}
                            {:name FormsNode,
                             :file "rewrite_clj/node/forms.cljc",
                             :line 6,
                             :type :var})}
                 {:name rewrite-clj.node.indent,
                  :no-doc true,
                  :publics ({:name indent-spaces,
                             :file "rewrite_clj/node/indent.cljc",
                             :line 47,
                             :arglists ([node n]),
                             :type :var}
                            {:name indent-tabs,
                             :file "rewrite_clj/node/indent.cljc",
                             :line 52,
                             :arglists ([node n]),
                             :type :var}
                            {:name LinePrefixedNode,
                             :file "rewrite_clj/node/indent.cljc",
                             :line 19,
                             :type :var}
                            {:name prefix-lines,
                             :file "rewrite_clj/node/indent.cljc",
                             :line 43,
                             :arglists ([node prefix]),
                             :type :var})}
                 {:name rewrite-clj.node.integer,
                  :no-doc true,
                  :publics ({:name integer-node,
                             :file "rewrite_clj/node/integer.cljc",
                             :line 34,
                             :arglists ([value] [value base]),
                             :doc "Create node representing an integer `value` in `base`.\n\n`base` defaults to 10.",
                             :type :var}
                            {:name IntNode,
                             :file "rewrite_clj/node/integer.cljc",
                             :line 7,
                             :type :var})}
                 {:name rewrite-clj.node.keyword,
                  :no-doc true,
                  :publics ({:name keyword-node,
                             :file "rewrite_clj/node/keyword.cljc",
                             :line 40,
                             :arglists ([k & [namespaced?]]),
                             :doc "Create node representing a keyword `k`. If `namespaced?` is `true`\na keyword à la `::x` or `::ns/x` (i.e. namespaced/aliased) is generated.",
                             :type :var}
                            {:name KeywordNode,
                             :file "rewrite_clj/node/keyword.cljc",
                             :line 10,
                             :type :var})}
                 {:name rewrite-clj.node.meta,
                  :no-doc true,
                  :publics ({:name meta-node,
                             :file "rewrite_clj/node/meta.cljc",
                             :line 39,
                             :arglists ([children] [metadata data]),
                             :doc "Create node representing a form `data` and its `metadata`.\n",
                             :type :var}
                            {:name MetaNode,
                             :file "rewrite_clj/node/meta.cljc",
                             :line 8,
                             :type :var}
                            {:name raw-meta-node,
                             :file "rewrite_clj/node/meta.cljc",
                             :line 47,
                             :arglists ([children] [metadata data]),
                             :doc "Create node representing a form `data` and its `metadata` using the\n`#^` prefix.",
                             :type :var})}
                 {:name rewrite-clj.node.namespaced-map,
                  :no-doc true,
                  :publics ({:name namespaced-map-node,
                             :file "rewrite_clj/node/namespaced_map.cljc",
                             :line 80,
                             :arglists ([children]),
                             :doc "Create a node representing a namespaced map. There are 3 types of namespaced maps:\n\n 1. prefix namespaced map\n The prefix is a keyword which specifies to a namespace.\n Example: `#:my.name.space{:a 1}`\n\n 2. auto-resolve alias namespaced map\n The prefix is an auto-resolve keyword specifies a namespace alias.\n Example: `#::ns-alias{:b 3}`\n\n 3. auto-resolve namespaced map\n The prefix is `::` which specifies the current namespace.\n Example: `#::{:c 4}`\n\nFirst child is the prefix, followed by optional whitespace then map node.\nTODO: this still seems hacky to me.\nPrefix must be a token-node with a keyword value. Use (keyword ':') for auto-resolve.",
                             :type :var}
                            {:name NamespacedMapNode,
                             :file "rewrite_clj/node/namespaced_map.cljc",
                             :line 44,
                             :type :var})}
                 {:name rewrite-clj.node.protocols,
                  :no-doc true,
                  :added "0.4.0",
                  :publics ({:name +extent,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 162,
                             :arglists ([[row col]
                                         [row-extent col-extent]]),
                             :no-doc true,
                             :type :var}
                            {:name assert-sexpr-count,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 123,
                             :arglists ([nodes c]),
                             :no-doc true,
                             :type :var}
                            {:name assert-single-sexpr,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 130,
                             :arglists ([nodes]),
                             :no-doc true,
                             :type :var}
                            {:name child-sexprs,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 70,
                             :arglists ([node]),
                             :doc "Return all children converted to forms.\n",
                             :type :var}
                            {:name concat-strings,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 42,
                             :arglists ([nodes]),
                             :doc "Return string version of `nodes`.\n",
                             :no-doc true,
                             :type :var}
                            {:name extent,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 134,
                             :arglists ([node]),
                             :doc "A node's extent is how far it moves the \"cursor\".\nRows are simple - if we have x newlines in the string representation, we\nwill always move the \"cursor\" x rows.\nColumns are strange.  If we have *any* newlines at all in the textual\nrepresentation of a node, following nodes' column positions are not\naffected by our startting column position at all.  So the second number\nin the pair we return is interpreted as a relative column adjustment\nwhen the first number in the pair (rows) is zero, and as an absolute\ncolumn position when rows is non-zero.",
                             :no-doc true,
                             :type :var}
                            {:name InnerNode,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 49,
                             :doc "Protocol for non-leaf EDN/Clojure/ClojureScript nodes.\n",
                             :type :protocol,
                             :members ({:name children,
                                        :arglists ([node]),
                                        :doc "Returns child nodes for `node`.\n",
                                        :type :var}
                                       {:name inner?,
                                        :arglists ([node]),
                                        :doc "Returns true if `node` can have children.\n",
                                        :type :var}
                                       {:name leader-length,
                                        :arglists ([node]),
                                        :doc "Returns number of characters before children for `node`.\n",
                                        :type :var}
                                       {:name replace-children,
                                        :arglists ([node children]),
                                        :doc "Returns `node` replacing current children with `children`.\n",
                                        :type :var})}
                            {:name make-printable!,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 113,
                             :arglists ([obj]),
                             :type :var}
                            {:name make-printable-cljs!,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 106,
                             :arglists ([obj]),
                             :no-doc true,
                             :type :var}
                            {:name Node,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 9,
                             :doc "Protocol for EDN/Clojure/ClojureScript nodes.\n",
                             :type :protocol,
                             :members ({:name length,
                                        :arglists ([node]),
                                        :doc "Return number of characters for the string version of `node`.\n",
                                        :type :var}
                                       {:name printable-only?,
                                        :arglists ([node]),
                                        :doc "Return true if `node` cannot be converted to an s-expression element.\n",
                                        :type :var}
                                       {:name sexpr,
                                        :arglists ([node]),
                                        :doc "Return `node` converted to form.\n",
                                        :type :var}
                                       {:name string,
                                        :arglists ([node]),
                                        :doc "Return the string version of `node`.\n",
                                        :type :var}
                                       {:name tag,
                                        :arglists ([node]),
                                        :doc "Returns keyword representing type of `node`.\n",
                                        :type :var})}
                            {:name NodeCoerceable,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 78,
                             :doc "Protocol for values that can be coerced to nodes.\n",
                             :type :protocol,
                             :members ({:name coerce,
                                        :arglists ([form]),
                                        :doc "Coerce `form` to node.\n",
                                        :type :var})}
                            {:name sexprs,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 30,
                             :arglists ([nodes]),
                             :doc "Return forms for `nodes`. Nodes that do not represent s-expression are skipped.\n",
                             :type :var}
                            {:name sum-lengths,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 37,
                             :arglists ([nodes]),
                             :doc "Return total string length for `nodes`.\n",
                             :no-doc true,
                             :type :var}
                            {:name without-whitespace,
                             :file "rewrite_clj/node/protocols.cljc",
                             :line 119,
                             :arglists ([nodes]),
                             :no-doc true,
                             :type :var})}
                 {:name rewrite-clj.node.quote,
                  :no-doc true,
                  :publics ({:name quote-node,
                             :file "rewrite_clj/node/quote.cljc",
                             :line 39,
                             :arglists ([children]),
                             :doc "Create node representing a quoted form with `children`.\nTakes either a seq of nodes or a single one.",
                             :type :var}
                            {:name QuoteNode,
                             :file "rewrite_clj/node/quote.cljc",
                             :line 6,
                             :type :var}
                            {:name syntax-quote-node,
                             :file "rewrite_clj/node/quote.cljc",
                             :line 49,
                             :arglists ([children]),
                             :doc "Create node representing a syntax-quoted form with `children`.\nTakes either a seq of nodes or a single one.",
                             :type :var}
                            {:name unquote-node,
                             :file "rewrite_clj/node/quote.cljc",
                             :line 59,
                             :arglists ([children]),
                             :doc "Create node representing an unquoted form with `children`. (`~...`)\nTakes either a seq of nodes or a single one.",
                             :type :var}
                            {:name unquote-splicing-node,
                             :file "rewrite_clj/node/quote.cljc",
                             :line 69,
                             :arglists ([children]),
                             :doc "Create node representing an unquote-spliced form with `children`. (`~@...`)\nTakes either a seq of nodes or a single one.",
                             :type :var})}
                 {:name rewrite-clj.node.reader-macro,
                  :no-doc true,
                  :publics ({:name deref-node,
                             :file "rewrite_clj/node/reader_macro.cljc",
                             :line 130,
                             :arglists ([children]),
                             :doc "Create node representing the dereferencing of a form with `children`. (`@...`)\nTakes either a seq of nodes or a single one.",
                             :type :var}
                            {:name DerefNode,
                             :file "rewrite_clj/node/reader_macro.cljc",
                             :line 64,
                             :type :var}
                            {:name eval-node,
                             :file "rewrite_clj/node/reader_macro.cljc",
                             :line 112,
                             :arglists ([children]),
                             :doc "Create node representing an inline evaluation with `children`. (`#=...`)\nTakes either a seq of nodes or a single one.",
                             :type :var}
                            {:name reader-macro-node,
                             :file "rewrite_clj/node/reader_macro.cljc",
                             :line 123,
                             :arglists ([children]
                                        [macro-node form-node]),
                             :doc "Create node representing a reader macro with `children`. (`#... ...`)\n",
                             :type :var}
                            {:name ReaderMacroNode,
                             :file "rewrite_clj/node/reader_macro.cljc",
                             :line 39,
                             :type :var}
                            {:name ReaderNode,
                             :file "rewrite_clj/node/reader_macro.cljc",
                             :line 7,
                             :type :var}
                            {:name var-node,
                             :file "rewrite_clj/node/reader_macro.cljc",
                             :line 104,
                             :arglists ([children]),
                             :doc "Create node representing a var with `children`.\nTakes either a seq of nodes or a single one.",
                             :type :var})}
                 {:name rewrite-clj.node.regex,
                  :no-doc true,
                  :publics ({:name regex-node,
                             :file "rewrite_clj/node/regex.cljc",
                             :line 19,
                             :arglists ([pattern-string]),
                             :doc "Create node representing a regex with `pattern-string`\n",
                             :type :var}
                            {:name RegexNode,
                             :file "rewrite_clj/node/regex.cljc",
                             :line 7,
                             :type :var})}
                 {:name rewrite-clj.node.seq,
                  :no-doc true,
                  :publics ({:name list-node,
                             :file "rewrite_clj/node/seq.cljc",
                             :line 42,
                             :arglists ([children]),
                             :doc "Create a node representing a list with `children`.\n",
                             :type :var}
                            {:name map-node,
                             :file "rewrite_clj/node/seq.cljc",
                             :line 57,
                             :arglists ([children]),
                             :doc "Create a node representing an map with `children`.\n",
                             :type :var}
                            {:name SeqNode,
                             :file "rewrite_clj/node/seq.cljc",
                             :line 7,
                             :type :var}
                            {:name set-node,
                             :file "rewrite_clj/node/seq.cljc",
                             :line 52,
                             :arglists ([children]),
                             :doc "Create a node representing a set with `children`.\n",
                             :type :var}
                            {:name vector-node,
                             :file "rewrite_clj/node/seq.cljc",
                             :line 47,
                             :arglists ([children]),
                             :doc "Create a node representing a vector with `children`.\n",
                             :type :var})}
                 {:name rewrite-clj.node.stringz,
                  :no-doc true,
                  :publics ({:name string-node,
                             :file "rewrite_clj/node/stringz.cljc",
                             :line 42,
                             :arglists ([lines]),
                             :doc "Create node representing a string value of `lines`.\n`lines` can be a seq of strings or a single one.",
                             :type :var}
                            {:name StringNode,
                             :file "rewrite_clj/node/stringz.cljc",
                             :line 16,
                             :type :var})}
                 {:name rewrite-clj.node.token,
                  :no-doc true,
                  :publics ({:name token-node,
                             :file "rewrite_clj/node/token.cljc",
                             :line 22,
                             :arglists ([value] [value string-value]),
                             :doc "Create node for an unspecified token of `value`.\n",
                             :type :var}
                            {:name TokenNode,
                             :file "rewrite_clj/node/token.cljc",
                             :line 6,
                             :type :var})}
                 {:name rewrite-clj.node.uneval,
                  :no-doc true,
                  :publics ({:name uneval-node,
                             :file "rewrite_clj/node/uneval.cljc",
                             :line 34,
                             :arglists ([children]),
                             :doc "Create node representing an uneval `#_` form with `children`.\n",
                             :type :var}
                            {:name UnevalNode,
                             :file "rewrite_clj/node/uneval.cljc",
                             :line 6,
                             :type :var})}
                 {:name rewrite-clj.node.whitespace,
                  :no-doc true,
                  :publics ({:name *count-fn*,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 12,
                             :doc "This function is applied to every newline string and should produce\nthe eventual character count.",
                             :dynamic true,
                             :type :var}
                            {:name *newline-fn*,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 8,
                             :doc "This function is applied to every newline string.\n",
                             :dynamic true,
                             :type :var}
                            {:name comma-node,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 86,
                             :arglists ([s]),
                             :doc "Create comma node of string `s`.\n",
                             :type :var}
                            {:name comma-separated,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 130,
                             :arglists ([nodes]),
                             :doc "Interleave `nodes` with `\", \"` nodes.\n",
                             :type :var}
                            {:name comma?,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 165,
                             :arglists ([node]),
                             :doc "Returns true if `node` represents a comma.\n",
                             :type :var}
                            {:name CommaNode,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 43,
                             :type :var}
                            {:name line-separated,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 138,
                             :arglists ([nodes]),
                             :doc "Interleave `nodes` with newline nodes.\n",
                             :type :var}
                            {:name linebreak?,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 160,
                             :arglists ([node]),
                             :doc "Returns true if `node` represents linebreak(s).\n",
                             :type :var}
                            {:name newline-node,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 92,
                             :arglists ([s]),
                             :doc "Create newline node of string `s`.\n",
                             :type :var}
                            {:name NewlineNode,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 55,
                             :type :var}
                            {:name newlines,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 124,
                             :arglists ([n]),
                             :doc "Create node representing `n` newline characters.\n",
                             :type :var}
                            {:name space-separated,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 144,
                             :arglists ([nodes]),
                             :doc "Interleave `nodes` with `\" \"` nodes.\n",
                             :type :var}
                            {:name spaces,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 119,
                             :arglists ([n]),
                             :doc "Create node representing `n` spaces.\n",
                             :type :var}
                            {:name whitespace-node,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 80,
                             :arglists ([s]),
                             :doc "Create whitespace node of string `s`.\n",
                             :type :var}
                            {:name whitespace-nodes,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 104,
                             :arglists ([s]),
                             :doc "Convert string `s` of whitespace to whitespace/newline nodes.\n",
                             :type :var}
                            {:name whitespace?,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 151,
                             :arglists ([node]),
                             :doc "Returns true if `node represents whitespace.\n",
                             :type :var}
                            {:name WhitespaceNode,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 31,
                             :type :var}
                            {:name with-count-fn,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 24,
                             :arglists ([f & body]),
                             :type :macro}
                            {:name with-newline-fn,
                             :file "rewrite_clj/node/whitespace.cljc",
                             :line 18,
                             :arglists ([f & body]),
                             :type :macro})}
                 {:name rewrite-clj.paredit,
                  :doc "Paredit zipper operations for Clojure/ClojureScript/EDN.\n\nYou might find inspiration from examples here: http://pub.gajendra.net/src/paredit-refcard.pdf",
                  :publics ({:name barf-backward,
                             :file "rewrite_clj/paredit.cljc",
                             :line 339,
                             :arglists ([zloc]),
                             :doc "Push out the leftmost node of the current S-expression into outer left form\n\n- `[1 2 [3 |4] 5] => [1 2 3 [|4] 5]`",
                             :type :var}
                            {:name barf-forward,
                             :file "rewrite_clj/paredit.cljc",
                             :line 315,
                             :arglists ([zloc]),
                             :doc "Push out the rightmost node of the current S-expression into outer right form\n\n- `[1 2 [|3 4] 5] => [1 2 [|3] 4 5]`",
                             :type :var}
                            {:name join,
                             :file "rewrite_clj/paredit.cljc",
                             :line 499,
                             :arglists ([zloc]),
                             :doc "Join S-expression to the left and right of current loc. Also works for strings.\n\n- `[[1 2] |[3 4]] => [[1 2 3 4]]`\n- `[\"Hello \" | \"World\"] => [\"Hello World\"]",
                             :type :var}
                            {:name kill,
                             :file "rewrite_clj/paredit.cljc",
                             :line 82,
                             :arglists ([zloc]),
                             :doc "Kill all sibling nodes to the right of the current node in `zloc`.\n\n- [1 2| 3 4] => [1 2|]",
                             :type :var}
                            {:name kill-at-pos,
                             :file "rewrite_clj/paredit.cljc",
                             :line 127,
                             :arglists ([zloc pos]),
                             :doc "In string and comment aware kill\n\nPerform kill for given position `pos` Like [[kill]], but:\n\n- if inside string kills to end of string and stops there\n- If inside comment kills to end of line (not including linebreak!)\n\n`pos` should provide `{:row :col }` which are relative to the start of the given form the zipper represents\n`zloc` must be positioned at a node previous (given depth first) to the node at given pos",
                             :type :var}
                            {:name kill-one-at-pos,
                             :file "rewrite_clj/paredit.cljc",
                             :line 196,
                             :arglists ([zloc pos]),
                             :doc "In string and comment aware kill for one node/word at `pos` in `zloc`.\n\n- `(+ |100 100) => (+ |100)`\n- `(for |(bar do)) => (foo)`\n- `\"|hello world\" => \"| world\"`\n- ` ; |hello world => ;  |world`",
                             :type :var}
                            {:name move-n,
                             :file "rewrite_clj/paredit.cljc",
                             :line 19,
                             :arglists ([loc f n]),
                             :no-doc true,
                             :type :var}
                            {:name move-to-prev,
                             :file "rewrite_clj/paredit.cljc",
                             :line 528,
                             :arglists ([zloc]),
                             :doc "Move node at current location to the position of previous location given a depth first traversal\n\n  -  `(+ 1 (+ 2 |3) 4) => (+ 1 (+ |3 2) 4)`\n  - `(+ 1 (+ 2 3) |4) => (+ 1 (+ 2 3 |4))`\n\nreturns zloc after move or given zloc if a move isn't possible",
                             :type :var}
                            {:name raise,
                             :file "rewrite_clj/paredit.cljc",
                             :line 517,
                             :arglists ([zloc]),
                             :doc "Delete siblings and raise node at zloc one level up\n\n- `[1 [2 |3 4]] => [1 |3]`",
                             :type :var}
                            {:name slurp-backward,
                             :file "rewrite_clj/paredit.cljc",
                             :line 273,
                             :arglists ([zloc]),
                             :doc "Pull in prev left outer node (if none at first level, tries next etc) into\ncurrent S-expression\n\n- `[1 2 [|3] 4 5] => [1 [2 |3] 4 5]`",
                             :type :var}
                            {:name slurp-backward-fully,
                             :file "rewrite_clj/paredit.cljc",
                             :line 300,
                             :arglists ([zloc]),
                             :doc "Pull in all left outer-nodes into current S-expression, but only the ones at the same level\nas the the first one.\n\n- `[1 2 [|3] 4 5] => [[1 2 |3] 4 5]`",
                             :type :var}
                            {:name slurp-forward,
                             :file "rewrite_clj/paredit.cljc",
                             :line 235,
                             :arglists ([zloc]),
                             :doc "Pull in next right outer node (if none at first level, tries next etc) into\ncurrent S-expression\n\n- `[1 2 [|3] 4 5] => [1 2 [|3 4] 5]`",
                             :type :var}
                            {:name slurp-forward-fully,
                             :file "rewrite_clj/paredit.cljc",
                             :line 258,
                             :arglists ([zloc]),
                             :doc "Pull in all right outer-nodes into current S-expression, but only the ones at the same level\nas the the first one.\n\n- `[1 2 [|3] 4 5] => [1 2 [|3 4 5]]`",
                             :type :var}
                            {:name splice,
                             :file "rewrite_clj/paredit.cljc",
                             :line 385,
                             :doc "See rewrite-clj.zip/splice\n",
                             :type :var}
                            {:name splice-killing-backward,
                             :file "rewrite_clj/paredit.cljc",
                             :line 400,
                             :arglists ([zloc]),
                             :doc "Remove left siblings of current given node in S-Expression and unwrap remaining into enclosing S-expression\n\n- `(foo (let ((x 5)) |(sqrt n)) bar) => (foo (sqrt n) bar)`",
                             :type :var}
                            {:name splice-killing-forward,
                             :file "rewrite_clj/paredit.cljc",
                             :line 407,
                             :arglists ([zloc]),
                             :doc "Remove current given node and its right siblings in S-Expression and unwrap remaining into enclosing S-expression\n\n- `(a (b c |d e) f) => (a b |c f)`",
                             :type :var}
                            {:name split,
                             :file "rewrite_clj/paredit.cljc",
                             :line 419,
                             :arglists ([zloc]),
                             :doc "Split current s-sexpression in two at given node `zloc`\n\n-  `[1 2 |3 4 5] => [1 2 3] [4 5]`",
                             :type :var}
                            {:name split-at-pos,
                             :file "rewrite_clj/paredit.cljc",
                             :line 459,
                             :arglists ([zloc pos]),
                             :doc "In string aware split\n\nPerform split at given position `pos` Like split, but:\n\n- if inside string splits string into two strings\n\n`pos` should provide `{:row :col }` which are relative to the start of the given form the zipper represents\n`zloc` must be positioned at a node previous (given depth first) to the node at given pos",
                             :type :var}
                            {:name wrap-around,
                             :file "rewrite_clj/paredit.cljc",
                             :line 361,
                             :arglists ([zloc t]),
                             :doc "Wrap current node with a given type `t` (:vector, :list, :set, :map :fn)\n\n- `|123 => [|123] ; given :vector`\n- `|[1 [2]] => [|[1 [2]]]`",
                             :type :var}
                            {:name wrap-fully-forward-slurp,
                             :file "rewrite_clj/paredit.cljc",
                             :line 375,
                             :arglists ([zloc t]),
                             :doc "Create a new seq node of type `t` left of `zloc` then slurp fully into the new node\n\n- `[1 |2 3 4] => [1 [|2 3 4]]`",
                             :type :var})}
                 {:name rewrite-clj.parser,
                  :doc "Parse Clojure/ClojureScript/EDN source code to nodes.\n\nAfter parsing, the typical next step is [[rewrite-clj.zip/edn]] to create zipper.\n\nAlternatively consider parsing and zipping in one step from [[rewrite-clj.zip/of-string]] or [[rewrite-clj.zip/of-file]].",
                  :publics ({:name parse,
                             :file "rewrite_clj/parser.cljc",
                             :line 13,
                             :arglists ([reader]),
                             :doc "Parse next form from the given reader.\n",
                             :no-doc true,
                             :type :var}
                            {:name parse-all,
                             :file "rewrite_clj/parser.cljc",
                             :line 18,
                             :arglists ([reader]),
                             :doc "Parse all forms from the given reader.\n",
                             :no-doc true,
                             :type :var}
                            {:name parse-string,
                             :file "rewrite_clj/parser.cljc",
                             :line 30,
                             :arglists ([s]),
                             :doc "Parse first form in the given string.\n",
                             :type :var}
                            {:name parse-string-all,
                             :file "rewrite_clj/parser.cljc",
                             :line 35,
                             :arglists ([s]),
                             :doc "Parse all forms in the given string.\n",
                             :type :var})}
                 {:name rewrite-clj.parser.core,
                  :no-doc true,
                  :publics ({:name parse-next,
                             :file "rewrite_clj/parser/core.cljc",
                             :line 31,
                             :arglists ([reader]),
                             :type :var})}
                 {:name rewrite-clj.parser.keyword,
                  :no-doc true,
                  :publics ({:name parse-keyword,
                             :file "rewrite_clj/parser/keyword.cljc",
                             :line 7,
                             :arglists ([reader]),
                             :type :var})}
                 {:name rewrite-clj.parser.namespaced-map,
                  :no-doc true,
                  :publics ({:name parse-namespaced-map,
                             :file "rewrite_clj/parser/namespaced_map.cljc",
                             :line 54,
                             :arglists ([reader read-next]),
                             :type :var})}
                 {:name rewrite-clj.parser.string,
                  :no-doc true,
                  :publics ({:name parse-regex,
                             :file "rewrite_clj/parser/string.cljc",
                             :line 38,
                             :arglists ([reader]),
                             :type :var}
                            {:name parse-string,
                             :file "rewrite_clj/parser/string.cljc",
                             :line 34,
                             :arglists ([reader]),
                             :type :var})}
                 {:name rewrite-clj.parser.token,
                  :no-doc true,
                  :publics ({:name parse-token,
                             :file "rewrite_clj/parser/token.cljc",
                             :line 35,
                             :arglists ([reader]),
                             :doc "Parse a single token.\n",
                             :type :var})}
                 {:name rewrite-clj.parser.utils,
                  :no-doc true,
                  :publics ({:name ignore,
                             :file "rewrite_clj/parser/utils.cljc",
                             :line 20,
                             :arglists ([reader]),
                             :doc "Ignore next character of Reader.\n",
                             :type :var}
                            {:name linebreak?,
                             :file "rewrite_clj/parser/utils.cljc",
                             :line 10,
                             :arglists ([c]),
                             :doc "Check if a given character is a linebreak.\n",
                             :type :var}
                            {:name read-eol,
                             :file "rewrite_clj/parser/utils.cljc",
                             :line 33,
                             :arglists ([reader]),
                             :type :var}
                            {:name space?,
                             :file "rewrite_clj/parser/utils.cljc",
                             :line 15,
                             :arglists ([c]),
                             :doc "Check if a given character is a non-linebreak whitespace.\n",
                             :type :var}
                            {:name throw-reader,
                             :file "rewrite_clj/parser/utils.cljc",
                             :line 26,
                             :arglists ([reader & msg]),
                             :type :var}
                            {:name whitespace?,
                             :file "rewrite_clj/parser/utils.cljc",
                             :line 5,
                             :arglists ([c]),
                             :doc "Check if a given character is a whitespace.\n",
                             :type :var})}
                 {:name rewrite-clj.parser.whitespace,
                  :no-doc true,
                  :publics ({:name parse-whitespace,
                             :file "rewrite_clj/parser/whitespace.cljc",
                             :line 5,
                             :arglists ([reader]),
                             :doc "Parse as much whitespace as possible. The created node can either contain\nonly linebreaks or only space/tabs.",
                             :type :var})}
                 {:name rewrite-clj.potemkin.cljs,
                  :no-doc true,
                  :publics ({:name defprotocol+,
                             :file "rewrite_clj/potemkin/cljs.cljc",
                             :line 92,
                             :arglists ([name & body]),
                             :doc "Currently a no-op for cljs.\n",
                             :type :macro}
                            {:name import-vars,
                             :file "rewrite_clj/potemkin/cljs.cljc",
                             :line 75,
                             :arglists ([& raw-syms]),
                             :doc "Imports a list of vars from other namespaces with optional renaming and doc string altering.\n",
                             :type :macro})}
                 {:name rewrite-clj.potemkin.helper,
                  :no-doc true,
                  :publics ({:name new-meta,
                             :file "rewrite_clj/potemkin/helper.cljc",
                             :line 9,
                             :arglists ([orig-meta opts]),
                             :type :var}
                            {:name new-name,
                             :file "rewrite_clj/potemkin/helper.cljc",
                             :line 4,
                             :arglists ([orig-name opts]),
                             :type :var}
                            {:name syms->import-data,
                             :file "rewrite_clj/potemkin/helper.cljc",
                             :line 46,
                             :arglists ([syms resolve-fn meta-fn]),
                             :type :var}
                            {:name unravel-syms,
                             :file "rewrite_clj/potemkin/helper.cljc",
                             :line 22,
                             :arglists ([x]),
                             :type :var})}
                 {:name rewrite-clj.reader,
                  :no-doc true,
                  :publics ({:name boundary?,
                             :file "rewrite_clj/reader.cljc",
                             :line 24,
                             :arglists ([c]),
                             :doc "Check whether a given char is a token boundary.\n",
                             :type :var}
                            {:name comma?,
                             :file "rewrite_clj/reader.cljc",
                             :line 32,
                             :arglists ([c]),
                             :type :var}
                            {:name ignore,
                             :file "rewrite_clj/reader.cljc",
                             :line 105,
                             :arglists ([reader]),
                             :doc "Ignore the next character.\n",
                             :type :var}
                            {:name linebreak?,
                             :file "rewrite_clj/reader.cljc",
                             :line 42,
                             :arglists ([c]),
                             :doc "Checks whether the character is a newline\n",
                             :type :var}
                            {:name next,
                             :file "rewrite_clj/reader.cljc",
                             :line 111,
                             :arglists ([reader]),
                             :doc "Read next char.\n",
                             :type :var}
                            {:name peek,
                             :file "rewrite_clj/reader.cljc",
                             :line 121,
                             :arglists ([reader]),
                             :doc "Peek next char.\n",
                             :type :var}
                            {:name position,
                             :file "rewrite_clj/reader.cljc",
                             :line 126,
                             :arglists ([reader row-k col-k]),
                             :doc "Create map of `row-k` and `col-k` representing the current reader position.\n",
                             :type :var}
                            {:name read-include-linebreak,
                             :file "rewrite_clj/reader.cljc",
                             :line 91,
                             :arglists ([reader]),
                             :doc "Read until linebreak and include it.\n",
                             :type :var}
                            {:name read-n,
                             :file "rewrite_clj/reader.cljc",
                             :line 149,
                             :arglists ([reader node-tag read-fn p? n]),
                             :doc "Call the given function on the given reader until `n` values matching `p?` have been\ncollected.",
                             :type :var}
                            {:name read-repeatedly,
                             :file "rewrite_clj/reader.cljc",
                             :line 141,
                             :arglists ([reader read-fn]),
                             :doc "Call the given function on the given reader until it returns\na non-truthy value.",
                             :type :var}
                            {:name read-until,
                             :file "rewrite_clj/reader.cljc",
                             :line 82,
                             :arglists ([reader p?]),
                             :doc "Read until a char fulfills the given condition. Ignores the\nmatching char.",
                             :type :var}
                            {:name read-while,
                             :file "rewrite_clj/reader.cljc",
                             :line 61,
                             :arglists ([reader p?] [reader p? eof?]),
                             :doc "Read while the chars fulfill the given condition. Ignores\nthe unmatching char.",
                             :type :var}
                            {:name read-with-meta,
                             :file "rewrite_clj/reader.cljc",
                             :line 132,
                             :arglists ([reader read-fn]),
                             :doc "Use the given function to read value, then attach row/col metadata.\n",
                             :type :var}
                            {:name space?,
                             :file "rewrite_clj/reader.cljc",
                             :line 47,
                             :arglists ([c]),
                             :doc "Checks whether the character is a space\n",
                             :type :var}
                            {:name string->edn,
                             :file "rewrite_clj/reader.cljc",
                             :line 100,
                             :arglists ([s]),
                             :doc "Convert string to EDN value.\n",
                             :type :var}
                            {:name string-reader,
                             :file "rewrite_clj/reader.cljc",
                             :line 171,
                             :arglists ([s]),
                             :doc "Create reader for strings.\n",
                             :type :var}
                            {:name throw-reader,
                             :file "rewrite_clj/reader.cljc",
                             :line 12,
                             :arglists ([reader fmt & data]),
                             :doc "Throw reader exception, including line line/column.\n",
                             :type :var}
                            {:name unread,
                             :file "rewrite_clj/reader.cljc",
                             :line 116,
                             :arglists ([reader ch]),
                             :doc "Unreads a char. Puts the char back on the reader.\n",
                             :type :var}
                            {:name whitespace-or-boundary?,
                             :file "rewrite_clj/reader.cljc",
                             :line 54,
                             :arglists ([c]),
                             :type :var}
                            {:name whitespace?,
                             :file "rewrite_clj/reader.cljc",
                             :line 36,
                             :arglists ([c]),
                             :doc "Checks whether a given character is whitespace\n",
                             :type :var})}
                 {:name rewrite-clj.zip,
                  :doc "A rich API for navigating and updating Clojure/ClojureScripti/EDN source code via a zipper tree.\n\nThe zipper holds a tree of nodes representing source code. It also holds your current location while navigating\nthrough the tree and any pending changes you have made. Changes are applied back into the tree\nwhen invoking root functions.\n\nAlthough they are preserved, whitespace and comment nodes are normally skipped when navigating through the tree.\nThere are times when you will want to include whitespace and comment nodes, and as you see below, provisions are\navailable to do so.\n\nIt is good to remember that while some function names convey mutation, we are never changing anything, we are\ninstead returning modified copies.\n\nSome conventions in the code and docstrings:\n- `zloc` is the used as the argument name for our zipper\n- \"current node in `zloc`\" is shorthand for: node at current location in zipper `zloc`\n\nBecause this API contains many functions, we offer the following categorized listing:\n\n**Create a zipper**\n[[edn]]\n[[edn*]]\n[[of-string]]\n[[of-file]]\n\n**Move**\n[[left]]\n[[right]]\n[[up]]\n[[down]]\n[[prev]]\n[[next]]\n[[leftmost]]\n[[rightmost]]\n\n**Move without skipping whitespace and comments**\n[[left*]]\n[[right*]]\n[[up*]]\n[[down*]]\n[[prev*]]\n[[next*]]\n[[leftmost*]]\n[[rightmost*]]\n\n**Whitespace/comment aware skip**\n[[skip]]\n[[skip-whitespace]]\n[[skip-whitespace-left]]\n\n**Test for whitespace**\n[[whitespace?]]\n[[linebreak?]]\n[[whitespace-or-comment?]]\n\n**Test location**\n[[leftmost?]]\n[[rightmost?]]\n[[end?]]\n\n**Test data type**\n[[seq?]]\n[[list?]]\n[[vector?]]\n[[set?]]\n[[map?]]\n\n**Find**\n[[find]]\n[[find-next]]\n[[find-depth-first]]\n[[find-next-depth-first]]\n[[find-tag]]\n[[find-next-tag]]\n[[find-value]]\n[[find-next-value]]\n[[find-token]]\n[[find-next-token]]\n[[find-last-by-pos]]\n[[find-tag-by-pos]]\n\n**Inspect**\n[[node]]\n[[position]]\n[[position-span]]\n[[tag]]\n[[length]]\n\n**Convert**\n[[sexpr]]\n[[child-sexpr]]\n\n**Update**\n[[replace]]\n[[edit]]\n[[splice]]\n[[prefix]]\n[[suffix]]\n[[insert-right]]\n[[insert-left]]\n[[insert-child]]\n[[insert-space-left]]\n[[insert-space-right]]\n[[insert-newline-left]]\n[[insert-newline-right]]\n[[append-child]]\n[[remove]]\n[[remove-preserve-newline]]\n[[root]]\n\n**Update without whitespace treatment**\n[[replace*]]\n[[edit*]]\n[[insert-left*]]\n[[insert-right*]]\n[[append-child*]]\n[[remove*]]\n\n**Isolated update without changing location**\n[[edit-node]]\n[[subedit-node]]\n[[subzip]]\n[[prewalk]]\n[[postwalk]]\n[[edit->]]\n[[edit->>]]\n[[subedit->]]\n[[subedit->>]]\n\n**Sequence operations**\n[[map]]\n[[map-keys]]\n[[map-vals]]\n[[get]]\n[[assoc]]\n\n**Stringify**\n[[string]]\n[[root-string]]\n\n**Output**\n[[print]]\n[[print-root]]",
                  :publics ({:name ->root-string,
                             :file "rewrite_clj/zip.cljc",
                             :line 249,
                             :arglists ([zloc]),
                             :doc "DEPRECATED. Renamed to [[root-string]].\n",
                             :deprecated "0.4.0",
                             :type :var}
                            {:name ->string,
                             :file "rewrite_clj/zip.cljc",
                             :line 244,
                             :arglists ([zloc]),
                             :doc "DEPRECATED. Renamed to [[string]].\n",
                             :deprecated "0.4.0",
                             :type :var}
                            {:name append-child,
                             :file "rewrite_clj/zip/insert.cljc",
                             :line 52,
                             :arglists ([zloc item]),
                             :doc "Return zipper with `item` appended as last child of the current node in `zloc`.\nWill insert a space if necessary.",
                             :type :var}
                            {:name append-child*,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 219,
                             :arglists ([zloc item]),
                             :doc "Raw version of [[append-child]].\n\nReturns zipper with `item` inserted as the rightmost child of the current node in `zloc`,\n  without moving.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                             :type :var}
                            {:name append-newline,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 113,
                             :arglists ([zloc & [n]]),
                             :doc "DEPRECATED: renamed to [[insert-newline-right]].\n",
                             :deprecated "0.5.0",
                             :type :var}
                            {:name append-space,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 103,
                             :arglists ([zloc & [n]]),
                             :doc "DEPRECATED: renamed to [[insert-space-right]].\n",
                             :deprecated "0.5.0",
                             :type :var}
                            {:name assoc,
                             :file "rewrite_clj/zip/seqz.cljc",
                             :line 111,
                             :arglists ([zloc k v]),
                             :doc "Returns zipper with key `k` set to value `v` when current node in `zloc` is a map node.\nReturns zipper with index `k` set to value `v` when current node in `zloc` is a sequence.",
                             :type :var}
                            {:name child-sexprs,
                             :file "rewrite_clj/zip/base.cljc",
                             :line 51,
                             :arglists ([zloc]),
                             :doc "Return s-expression of children of current node in `zloc`.\n",
                             :added "0.4.4",
                             :type :var}
                            {:name down,
                             :file "rewrite_clj/zip/move.cljc",
                             :line 16,
                             :arglists ([zloc]),
                             :doc "Return zipper with location moved down to next non-whitespace/non-comment node in `zloc`.\n",
                             :type :var}
                            {:name down*,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 96,
                             :arglists ([zloc]),
                             :doc "Raw version of [[down]].\n\nReturns zipper with the location at the leftmost child of current node in `zloc`, or\n  nil if no children.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                             :type :var}
                            {:name edit,
                             :file "rewrite_clj/zip/editz.cljc",
                             :line 26,
                             :arglists ([zloc f & args]),
                             :doc "Return zipper with the current node in `zloc` replaced with the result of:\n\n(`f` (s-expression node) `args`)\n\nThe result of `f` will be coerced to a node if possible.",
                             :type :var}
                            {:name edit*,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 206,
                             :arglists ([zloc f & args]),
                             :doc "Raw version of [[edit]].\n\nReturns zipper with value of `(f current-node args)` replacing current node in `zloc`\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                             :type :var}
                            {:name edit->,
                             :file "rewrite_clj/zip/subedit.cljc",
                             :line 41,
                             :arglists ([zloc & body]),
                             :doc "Like `->`. Threads `zloc` through forms.\nThe resulting zipper will be located at the same path (i.e. the same\nnumber of downwards and right movements from the root) as incoming `zloc`.",
                             :type :macro}
                            {:name edit->>,
                             :file "rewrite_clj/zip/subedit.cljc",
                             :line 48,
                             :arglists ([zloc & body]),
                             :doc "Like `->>`. Threads `zloc` through forms.\nThe resulting zipper will be located at the same path (i.e. the same\nnumber of downwards and right movements from the root) as incoming `zloc`.",
                             :type :macro}
                            {:name edit-node,
                             :file "rewrite_clj/zip/subedit.cljc",
                             :line 32,
                             :arglists ([zloc f]),
                             :doc "Return zipper applying function `f` to `zloc`. The resulting\nzipper will be located at the same path (i.e. the same number of\ndownwards and right movements from the root) incoming `zloc`.",
                             :type :var}
                            {:name edn,
                             :file "rewrite_clj/zip/base.cljc",
                             :line 23,
                             :arglists ([node] [node options]),
                             :doc "Create and return zipper from Clojure/ClojureScript/EDN `node` (likely parsed by [[rewrite-clj-.parse]])\nand move to the first non-whitespace/non-comment child.\n\nSet `:track-position?` in `options` to enable ones-based row/column tracking.\nSee [[rewrite-clj.zip/position]].\n\nNOTE: when position tracking is enabled, `clojure.zip` is not interchangeable with `rewrite-clj.zip`, you must use `rewrite-clj.zip`.",
                             :type :var}
                            {:name edn*,
                             :file "rewrite_clj/zip/base.cljc",
                             :line 9,
                             :arglists ([node]
                                        [node
                                         {:keys [track-position?]}]),
                             :doc "Create and return zipper from Clojure/ClojureScript/EDN `node` (likely parsed by [[rewrite-clj.parse]]).\n\nSet `:track-position?` in `options` to enable ones-based row/column tracking.\nSee [[rewrite-clj.zip/position]].\n\nNOTE: when position tracking is enabled, `clojure.zip` is not interchangeable with `rewrite-clj.zip`, you must use `rewrite-clj.zip`.",
                             :type :var}
                            {:name end?,
                             :file "rewrite_clj/zip/move.cljc",
                             :line 35,
                             :arglists ([zloc]),
                             :doc "Return true if `zloc` is at end of depth-first traversal.\n",
                             :type :var}
                            {:name find,
                             :file "rewrite_clj/zip/findz.cljc",
                             :line 29,
                             :arglists ([zloc p?] [zloc f p?]),
                             :doc "Return the first node satisfying predicate `p?` seaching from the current node\nin `zloc` traversing by function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                             :type :var}
                            {:name find-depth-first,
                             :file "rewrite_clj/zip/findz.cljc",
                             :line 59,
                             :arglists ([zloc p?]),
                             :doc "Return first node satisfying predicate `p?` searching depth-first from\nthe current node in `zloc`.",
                             :type :var}
                            {:name find-last-by-pos,
                             :file "rewrite_clj/zip/findz.cljc",
                             :line 44,
                             :arglists ([zloc pos] [zloc pos p?]),
                             :doc "Return the last node spanning position `pos` that satisfies predicate `p?`\n searching depth-first from the current node in `zloc`.\n\nNOTE: Does not ignore whitespace/comment nodes.",
                             :type :var}
                            {:name find-next,
                             :file "rewrite_clj/zip/findz.cljc",
                             :line 65,
                             :arglists ([zloc p?] [zloc f p?]),
                             :doc "Return the first node satisfying predicate `p?` searching one movement `f` from the current\nnode in `zloc` traversing by function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                             :type :var}
                            {:name find-next-depth-first,
                             :file "rewrite_clj/zip/findz.cljc",
                             :line 75,
                             :arglists ([zloc p?]),
                             :doc "Return the first node satisfying predicate `p?` searching depth-first from one\nnode after the current node in `zloc`",
                             :type :var}
                            {:name find-next-tag,
                             :file "rewrite_clj/zip/findz.cljc",
                             :line 91,
                             :arglists ([zloc t] [zloc f t]),
                             :doc "Return the first node with tag `t` searching one movement `f` from the current\nnode in `zloc` traversing by function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                             :type :var}
                            {:name find-next-token,
                             :file "rewrite_clj/zip/findz.cljc",
                             :line 118,
                             :arglists ([zloc p?] [zloc f p?]),
                             :doc "Return the first token node satisfying predicate `p?` searching from the current node in `zloc` traversing\nby function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                             :type :var}
                            {:name find-next-value,
                             :file "rewrite_clj/zip/findz.cljc",
                             :line 141,
                             :arglists ([zloc v] [zloc f v]),
                             :doc "Return the first token node with value `v` searching one movement `f` from the current node in `zloc` traversing\nby function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                             :type :var}
                            {:name find-tag,
                             :file "rewrite_clj/zip/findz.cljc",
                             :line 81,
                             :arglists ([zloc t] [zloc f t]),
                             :doc "Return the first node with tag `t` searching from the current node in `zloc` traversing by\nfunction `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                             :type :var}
                            {:name find-tag-by-pos,
                             :file "rewrite_clj/zip/findz.cljc",
                             :line 102,
                             :arglists ([zloc pos t]),
                             :doc "Return the last node spanning position `pos` with tag `t` searching depth-first from the current node in `zloc`.\n",
                             :type :var}
                            {:name find-token,
                             :file "rewrite_clj/zip/findz.cljc",
                             :line 107,
                             :arglists ([zloc p?] [zloc f p?]),
                             :doc "Return the first token node satisfying predicate `p?` searching from the current node in `zloc` traversing\nby function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                             :type :var}
                            {:name find-value,
                             :file "rewrite_clj/zip/findz.cljc",
                             :line 128,
                             :arglists ([zloc v] [zloc f v]),
                             :doc "Return the first token node with value `v` searching one movement `f` from the current node in `zloc` traversing\nby function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                             :type :var}
                            {:name get,
                             :file "rewrite_clj/zip/seqz.cljc",
                             :line 98,
                             :arglists ([zloc k]),
                             :doc "Returns value node mapped to key `k` when current node in `zloc` is a map node.\nReturns nth `k` value node when current node in `zloc` is a sequence node.",
                             :type :var}
                            {:name insert-child,
                             :file "rewrite_clj/zip/insert.cljc",
                             :line 43,
                             :arglists ([zloc item]),
                             :doc "Return zipper with `item` inserted as the first child of the current node in `zloc`.\n",
                             :type :var}
                            {:name insert-left,
                             :file "rewrite_clj/zip/insert.cljc",
                             :line 33,
                             :arglists ([zloc item]),
                             :doc "Return zipper with `item` inserted to the left of the current node in `zloc`.\nWill insert a space if necessary.",
                             :type :var}
                            {:name insert-left*,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 178,
                             :arglists ([zloc item]),
                             :doc "Raw version of [[insert-left]].\n\nReturns zipper with `item` inserted as the left sibling of current node in `zloc`,\n without moving location.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                             :type :var}
                            {:name insert-newline-left,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 82,
                             :arglists ([zloc] [zloc n]),
                             :doc "Return zipper with `n` newlines node inserted to the left of the current node in `zloc`.\n`n` defaults to 1.",
                             :added "0.5.0",
                             :type :var}
                            {:name insert-newline-right,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 89,
                             :arglists ([zloc] [zloc n]),
                             :doc "Return zipper with `n` newlines node inserted to the right of the current node in `zloc`.\n`n` defaults to 1.",
                             :added "0.5.0",
                             :type :var}
                            {:name insert-right,
                             :file "rewrite_clj/zip/insert.cljc",
                             :line 23,
                             :arglists ([zloc item]),
                             :doc "Return zipper with `item` inserted to the right of the current node in `zloc`.\nWill insert a space if necessary.",
                             :type :var}
                            {:name insert-right*,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 190,
                             :arglists ([zloc item]),
                             :doc "Raw version of [[insert-right]].\n\nReturns zipper with `item` inserted as the right sibling of the current node in `zloc`,\n  without moving location.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                             :type :var}
                            {:name insert-space-left,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 62,
                             :arglists ([zloc] [zloc n]),
                             :doc "Return zipper with `n` space whitespace node inserted to the left of the current node in `zloc`.\n`n` defaults to 1.",
                             :added "0.5.0",
                             :type :var}
                            {:name insert-space-right,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 72,
                             :arglists ([zloc] [zloc n]),
                             :doc "Return zipper with `n` space whitespace node inserted to the right of the current node in `zloc`.\n`n` defaults to 1.",
                             :added "0.5.0",
                             :type :var}
                            {:name left,
                             :file "rewrite_clj/zip/move.cljc",
                             :line 11,
                             :arglists ([zloc]),
                             :doc "Return zipper with location moved left to next non-whitespace/non-comment node in `zloc`.\n",
                             :type :var}
                            {:name left*,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 153,
                             :arglists ([zloc]),
                             :doc "Raw version of [[left]].\n\nReturns zipper with location at the left sibling of the current node in `zloc`, or nil.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                             :type :var}
                            {:name leftmost,
                             :file "rewrite_clj/zip/move.cljc",
                             :line 59,
                             :arglists ([zloc]),
                             :doc "Return zipper with location moved to the leftmost non-whitespace/non-comment node in `zloc`.\n",
                             :type :var}
                            {:name leftmost*,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 165,
                             :arglists ([zloc]),
                             :doc "Raw version of [[leftmost]].\n\nReturns zipper with location at the leftmost sibling of the current node in `zloc`, or self.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                             :type :var}
                            {:name leftmost?,
                             :file "rewrite_clj/zip/move.cljc",
                             :line 47,
                             :arglists ([zloc]),
                             :doc "Return true if at leftmost non-whitespace/non-comment node in `zloc`.\n",
                             :type :var}
                            {:name length,
                             :file "rewrite_clj/zip/base.cljc",
                             :line 56,
                             :arglists ([zloc]),
                             :doc "Return length of printable string of current node in `zloc`.\n",
                             :type :var}
                            {:name linebreak?,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 12,
                             :arglists ([zloc]),
                             :doc "Returns true when the current node in `zloc` is a linebreak.\n",
                             :type :var}
                            {:name list?,
                             :file "rewrite_clj/zip/seqz.cljc",
                             :line 19,
                             :arglists ([zloc]),
                             :doc "Returns true if current node in `zloc` is a list.\n",
                             :type :var}
                            {:name map,
                             :file "rewrite_clj/zip/seqz.cljc",
                             :line 83,
                             :arglists ([f zloc]),
                             :doc "Returns zipper with function `f` applied to all value nodes of current node in `zloc`.\nCurrent node must be a sequence node.\n\nIterates over:\n- value nodes of maps\n- each element of a seq",
                             :type :var}
                            {:name map-keys,
                             :file "rewrite_clj/zip/seqz.cljc",
                             :line 70,
                             :arglists ([f zloc]),
                             :doc "Returns zipper with function `f` applied to all key nodes of the current node in `zloc`.\nCurrent node must be map node.",
                             :type :var}
                            {:name map-vals,
                             :file "rewrite_clj/zip/seqz.cljc",
                             :line 55,
                             :arglists ([f zloc]),
                             :doc "Returns zipper with function `f` applied to all value current node in `zloc`.\nCurrent node must be map node.",
                             :type :var}
                            {:name map?,
                             :file "rewrite_clj/zip/seqz.cljc",
                             :line 34,
                             :arglists ([zloc]),
                             :doc "Returns true if current node in `zloc` is a map.\n",
                             :type :var}
                            {:name next,
                             :file "rewrite_clj/zip/move.cljc",
                             :line 26,
                             :arglists ([zloc]),
                             :doc "Return zipper with location moved to the next depth-first non-whitespace/non-comment node in `zloc`.\n",
                             :type :var}
                            {:name next*,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 225,
                             :arglists ([{:keys [end?], :as zloc}]),
                             :doc "Raw version of [[next]].\n\nReturns zipper with location at the next depth-first location in the hierarchy in `zloc`.\n  When reaching the end, returns a distinguished zipper detectable via [[end?]]. If already\n  at the end, stays there.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                             :type :var}
                            {:name node,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 51,
                             :arglists ([zloc]),
                             :doc "Returns the current node in `zloc`.\n",
                             :type :var}
                            {:name of-string,
                             :file "rewrite_clj/zip/base.cljc",
                             :line 68,
                             :arglists ([s] [s options]),
                             :doc "Create and return zipper from all forms in Clojure/ClojureScript/EDN string `s`.\n\nSet `:track-position?` in `options` to enable ones-based row/column tracking.\nSee [[rewrite-clj.zip/position]].\n\nNOTE: when position tracking is enabled, `clojure.zip` is not interchangeable with `rewrite-clj.zip`, you must use `rewrite-clj.zip`.",
                             :type :var}
                            {:name position,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 74,
                             :arglists ([zloc]),
                             :doc "Returns the ones-based `[row col]` of the start of the current node in `zloc`.\n",
                             :type :var}
                            {:name position-span,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 84,
                             :arglists ([zloc]),
                             :doc "Returns the ones-based `[[start-row start-col] [end-row end-col]]` of the current node in `zloc`.\n",
                             :type :var}
                            {:name postwalk,
                             :file "rewrite_clj/zip/walk.cljc",
                             :line 38,
                             :arglists ([zloc f] [zloc p? f]),
                             :doc "Return zipper modified by an isolated depth-first post-order traversal.\nTraversal starts at the current node in `zloc` and continues to the end of the isolated sub-tree.\nFunction `f` is called on the zipper locations satisfying predicate `p?`, or all locations when `p?` is absent,\nand must return a valid zipper - modified or not.\n\nWARNING: when function `f` changes the location in the zipper, normal traversal will be affected.",
                             :added "0.4.9",
                             :type :var}
                            {:name prefix,
                             :file "rewrite_clj/zip/editz.cljc",
                             :line 75,
                             :arglists ([zloc s]),
                             :doc "Return zipper with the current node in `zloc` prefixed with string `s`.\nOperates on token node or a multi-line node, else exception is thrown.\nWhen multi-line, all lines are prefixed.\n\nTODO: either multi-line handling is broken or I don't understand intent of code.",
                             :type :var}
                            {:name prepend-newline,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 108,
                             :arglists ([zloc & [n]]),
                             :doc "DEPRECATED: renamed to [[insert-newline-left]].\n",
                             :deprecated "0.5.0",
                             :type :var}
                            {:name prepend-space,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 98,
                             :arglists ([zloc & [n]]),
                             :doc "DEPRECATED: renamed to [[insert-space-left]].\n",
                             :deprecated "0.5.0",
                             :type :var}
                            {:name prev,
                             :file "rewrite_clj/zip/move.cljc",
                             :line 52,
                             :arglists ([zloc]),
                             :doc "Return zipper with location moved to the previous depth-first non-whitespace/non-comment node in `zloc`.\n",
                             :type :var}
                            {:name prev*,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 240,
                             :arglists ([zloc]),
                             :doc "Raw version of [[prev]].\n\nReturns zipper with location at the previous depth-first location in the hierarchy in `zloc`.\n  If already at the root, returns nil.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                             :type :var}
                            {:name prewalk,
                             :file "rewrite_clj/zip/walk.cljc",
                             :line 16,
                             :arglists ([zloc f] [zloc p? f]),
                             :doc "Return zipper modified by an isolated depth-first pre-order traversal.\nTraversal starts at the current node in `zloc` and continues to the end of the isolated sub-tree.\nFunction `f` is called on the zipper locations satisfying predicate `p?`, or all locations when `p?` is absent,\nand must return a valid zipper - modified or not.\n\nWARNING: when function `f` changes the location in the zipper, normal traversal will be affected.",
                             :type :var}
                            {:name print,
                             :file "rewrite_clj/zip/base.cljc",
                             :line 112,
                             :arglists ([zloc & [writer]]),
                             :doc "Print current node in `zloc`.\n\nNOTE: Optional `writer` is currently ignored for ClojureScript.",
                             :type :var}
                            {:name print-root,
                             :file "rewrite_clj/zip/base.cljc",
                             :line 121,
                             :arglists ([zloc & [writer]]),
                             :doc "Zip up and print `zloc` from root node.\n\nNOTE: Optional `writer` is currently ignored for ClojureScript.",
                             :type :var}
                            {:name remove,
                             :file "rewrite_clj/zip/removez.cljc",
                             :line 28,
                             :arglists ([zloc]),
                             :doc "Return zipper with current node in `zloc` removed. Returned zipper location\n is moved to the first non-whitespace node preceding removed node in a depth-first walk.\n Removes whitespace appropriately.\n\n- `[1  2  3]   => [1  3]`\n- `[1 2]       => [1]`\n- `[1 2]       => [2]`\n- `[1]         => []`\n- `[  1  ]     => []`\n- `[1 [2 3] 4] => [1 [2 3]]`\n- `[1 [2 3] 4] => [[2 3] 4]`\n\n If the removed node is at the rightmost location, both preceding and trailing spaces are removed,\n otherwise only trailing spaces are removed. This means that a following element\n (no matter whether on the same line or not) will end up in the same position\n (line/column) as the removed one, _unless_ a comment lies between the original\n node and the neighbour.",
                             :type :var}
                            {:name remove*,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 256,
                             :arglists ([zloc]),
                             :doc "Raw version of [[remove]].\n\nReturns zipper with current node in `zloc` removed, with location at node that would have preceded\n  it in a depth-first walk.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                             :type :var}
                            {:name remove-preserve-newline,
                             :file "rewrite_clj/zip/removez.cljc",
                             :line 51,
                             :arglists ([zloc]),
                             :doc "Same as [[remove]] but preserves newlines.\n",
                             :type :var}
                            {:name replace,
                             :file "rewrite_clj/zip/editz.cljc",
                             :line 12,
                             :arglists ([zloc value]),
                             :doc "Return zipper with the current node in `zloc` replaced with one representing `value`.\n`value` will be coerced to a node if possible.",
                             :type :var}
                            {:name replace*,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 201,
                             :arglists ([zloc node]),
                             :doc "Raw version of [[replace]].\n\nReturns zipper with `node` replacing current node in `zloc`, without moving location.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                             :type :var}
                            {:name right,
                             :file "rewrite_clj/zip/move.cljc",
                             :line 6,
                             :arglists ([zloc]),
                             :doc "Return zipper with location moved right to next non-whitespace/non-comment node in `zloc`.\n",
                             :type :var}
                            {:name right*,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 135,
                             :arglists ([zloc]),
                             :doc "Raw version of [[right]].\n\nReturns zipper with location at the right sibling of the current node in `zloc`, or nil.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                             :type :var}
                            {:name rightmost,
                             :file "rewrite_clj/zip/move.cljc",
                             :line 66,
                             :arglists ([zloc]),
                             :doc "Return zipper with location moved to the rightmost non-whitespace/non-comment node in `zloc`.\n",
                             :type :var}
                            {:name rightmost*,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 146,
                             :arglists ([zloc]),
                             :doc "Raw version of [[rightmost]].\n\nReturns zipper with location at the rightmost sibling of the current node in `zloc`, or self.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                             :type :var}
                            {:name rightmost?,
                             :file "rewrite_clj/zip/move.cljc",
                             :line 42,
                             :arglists ([zloc]),
                             :doc "Return true if at rightmost non-whitespace/non-comment node in `zloc`.\n",
                             :type :var}
                            {:name root,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 125,
                             :arglists ([{:keys [end?], :as zloc}]),
                             :doc "Zips all the way up `zloc` and returns zipper at the root node, reflecting any changes.\n",
                             :type :var}
                            {:name root-string,
                             :file "rewrite_clj/zip/base.cljc",
                             :line 98,
                             :arglists ([zloc]),
                             :doc "Return string representing the zipped-up `zloc` zipper.\n",
                             :added "0.4.0",
                             :type :var}
                            {:name seq?,
                             :file "rewrite_clj/zip/seqz.cljc",
                             :line 12,
                             :arglists ([zloc]),
                             :doc "Returns true if current node in `zloc` is a sequence.\n",
                             :type :var}
                            {:name set?,
                             :file "rewrite_clj/zip/seqz.cljc",
                             :line 29,
                             :arglists ([zloc]),
                             :doc "Returns true if current node in `zloc` is a set.\n",
                             :type :var}
                            {:name sexpr,
                             :file "rewrite_clj/zip/base.cljc",
                             :line 46,
                             :arglists ([zloc]),
                             :doc "Return s-expression of current node in `zloc`.\n",
                             :type :var}
                            {:name skip,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 37,
                             :arglists ([f p? zloc]),
                             :doc "Return zipper with location moved to first location not satisfying predicate `p?` starting from the node in\n`zloc` and traversing by function `f`.",
                             :type :var}
                            {:name skip-whitespace,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 47,
                             :arglists ([zloc] [f zloc]),
                             :doc "Return zipper with location moved to first non-whitespace/non-comment starting from current node in `zloc`\nand traversing by function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                             :type :var}
                            {:name skip-whitespace-left,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 55,
                             :arglists ([zloc]),
                             :doc "Return zipper with location moved to first non-whitespace/non-comment starting from current node in `zloc` traversing left.\n",
                             :type :var}
                            {:name splice,
                             :file "rewrite_clj/zip/editz.cljc",
                             :line 37,
                             :arglists ([zloc]),
                             :doc "Return zipper with the children of the current node in `zloc` merged into itself.\n(akin to Clojure's `unquote-splicing` macro: `~@...`).\n- if the node is not one that can have children, no modification will\n  be performed.\n- if the node has no or only whitespace children, it will be removed.\n- otherwise, splicing will be performed, moving the zipper to the first\n  non-whitespace child afterwards.",
                             :type :var}
                            {:name string,
                             :file "rewrite_clj/zip/base.cljc",
                             :line 93,
                             :arglists ([zloc]),
                             :doc "Return string representing the current node in `zloc`.\n",
                             :added "0.4.0",
                             :type :var}
                            {:name subedit->,
                             :file "rewrite_clj/zip/subedit.cljc",
                             :line 72,
                             :arglists ([zloc & body]),
                             :doc "Like `->`. Threads `zloc`, as an isolated sub-tree through forms, then zips\nup to, and locates at, the root of the modified sub-tree.",
                             :type :macro}
                            {:name subedit->>,
                             :file "rewrite_clj/zip/subedit.cljc",
                             :line 78,
                             :arglists ([zloc & body]),
                             :doc "Like `->`. Threads `zloc`, as an isolated sub-tree through forms, then zips\nup to, and locates at, the root of the modified sub-tree.",
                             :type :macro}
                            {:name subedit-node,
                             :file "rewrite_clj/zip/subedit.cljc",
                             :line 64,
                             :arglists ([zloc f]),
                             :doc "Return zipper replacing current node in `zloc` with result of `f` applied to said node as an isolated sub-tree.\nThe resulting zipper will be located on the root of the modified sub-tree.",
                             :type :var}
                            {:name subzip,
                             :file "rewrite_clj/zip/subedit.cljc",
                             :line 57,
                             :arglists ([zloc]),
                             :doc "Create and return a zipper whose root is the current node in `zloc`.\n",
                             :type :var}
                            {:name suffix,
                             :file "rewrite_clj/zip/editz.cljc",
                             :line 90,
                             :arglists ([zloc s]),
                             :doc "Return zipper with the current node in `zloc` suffixed with string `s`.\nOperates on token node or a multi-line node, else exception is thrown.\nWhen multi-line, all lines are suffixed.\n\nTODO: either multi-line handling is broken or I don't understand intent of code.",
                             :type :var}
                            {:name tag,
                             :file "rewrite_clj/zip/base.cljc",
                             :line 41,
                             :arglists ([zloc]),
                             :doc "Return tag of current node in `zloc`.\n",
                             :type :var}
                            {:name up,
                             :file "rewrite_clj/zip/move.cljc",
                             :line 21,
                             :arglists ([zloc]),
                             :doc "Return zipper with location moved up to next non-whitespace/non-comment node in `zloc`.\n",
                             :type :var}
                            {:name up*,
                             :file "rewrite_clj/custom_zipper/core.cljc",
                             :line 111,
                             :arglists ([zloc]),
                             :doc "Raw version of [[up]].\n\nReturns zipper with the location at the parent of current node in `zloc`, or nil if at\n  the top.\n\nNOTE: This function does not skip, nor provide any special handling for whitespace/comment nodes.",
                             :type :var}
                            {:name value,
                             :file "rewrite_clj/zip/base.cljc",
                             :line 61,
                             :arglists ([zloc]),
                             :doc "DEPRECATED. Return a tag/s-expression pair for inner nodes, or\nthe s-expression itself for leaves.",
                             :deprecated "0.4.0",
                             :type :var}
                            {:name vector?,
                             :file "rewrite_clj/zip/seqz.cljc",
                             :line 24,
                             :arglists ([zloc]),
                             :doc "Returns true if current node in `zloc` is a vector.\n",
                             :type :var}
                            {:name whitespace-or-comment?,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 29,
                             :arglists ([zloc]),
                             :doc "Returns true when current node in `zloc` is whitespace or a comment.\n",
                             :type :var}
                            {:name whitespace?,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 7,
                             :arglists ([zloc]),
                             :doc "Returns true when the current the node in `zloc` is a Clojure whitespace (which includes the comma).\n",
                             :type :var})}
                 {:name rewrite-clj.zip.base,
                  :no-doc true,
                  :publics ({:name child-sexprs,
                             :file "rewrite_clj/zip/base.cljc",
                             :line 51,
                             :arglists ([zloc]),
                             :doc "Return s-expression of children of current node in `zloc`.\n",
                             :added "0.4.4",
                             :type :var}
                            {:name edn,
                             :file "rewrite_clj/zip/base.cljc",
                             :line 23,
                             :arglists ([node] [node options]),
                             :doc "Create and return zipper from Clojure/ClojureScript/EDN `node` (likely parsed by [[rewrite-clj-.parse]])\nand move to the first non-whitespace/non-comment child.\n\nSet `:track-position?` in `options` to enable ones-based row/column tracking.\nSee [[rewrite-clj.zip/position]].\n\nNOTE: when position tracking is enabled, `clojure.zip` is not interchangeable with `rewrite-clj.zip`, you must use `rewrite-clj.zip`.",
                             :type :var}
                            {:name edn*,
                             :file "rewrite_clj/zip/base.cljc",
                             :line 9,
                             :arglists ([node]
                                        [node
                                         {:keys [track-position?]}]),
                             :doc "Create and return zipper from Clojure/ClojureScript/EDN `node` (likely parsed by [[rewrite-clj.parse]]).\n\nSet `:track-position?` in `options` to enable ones-based row/column tracking.\nSee [[rewrite-clj.zip/position]].\n\nNOTE: when position tracking is enabled, `clojure.zip` is not interchangeable with `rewrite-clj.zip`, you must use `rewrite-clj.zip`.",
                             :type :var}
                            {:name length,
                             :file "rewrite_clj/zip/base.cljc",
                             :line 56,
                             :arglists ([zloc]),
                             :doc "Return length of printable string of current node in `zloc`.\n",
                             :type :var}
                            {:name of-string,
                             :file "rewrite_clj/zip/base.cljc",
                             :line 68,
                             :arglists ([s] [s options]),
                             :doc "Create and return zipper from all forms in Clojure/ClojureScript/EDN string `s`.\n\nSet `:track-position?` in `options` to enable ones-based row/column tracking.\nSee [[rewrite-clj.zip/position]].\n\nNOTE: when position tracking is enabled, `clojure.zip` is not interchangeable with `rewrite-clj.zip`, you must use `rewrite-clj.zip`.",
                             :type :var}
                            {:name print,
                             :file "rewrite_clj/zip/base.cljc",
                             :line 112,
                             :arglists ([zloc & [writer]]),
                             :doc "Print current node in `zloc`.\n\nNOTE: Optional `writer` is currently ignored for ClojureScript.",
                             :type :var}
                            {:name print-root,
                             :file "rewrite_clj/zip/base.cljc",
                             :line 121,
                             :arglists ([zloc & [writer]]),
                             :doc "Zip up and print `zloc` from root node.\n\nNOTE: Optional `writer` is currently ignored for ClojureScript.",
                             :type :var}
                            {:name root-string,
                             :file "rewrite_clj/zip/base.cljc",
                             :line 98,
                             :arglists ([zloc]),
                             :doc "Return string representing the zipped-up `zloc` zipper.\n",
                             :added "0.4.0",
                             :type :var}
                            {:name sexpr,
                             :file "rewrite_clj/zip/base.cljc",
                             :line 46,
                             :arglists ([zloc]),
                             :doc "Return s-expression of current node in `zloc`.\n",
                             :type :var}
                            {:name string,
                             :file "rewrite_clj/zip/base.cljc",
                             :line 93,
                             :arglists ([zloc]),
                             :doc "Return string representing the current node in `zloc`.\n",
                             :added "0.4.0",
                             :type :var}
                            {:name tag,
                             :file "rewrite_clj/zip/base.cljc",
                             :line 41,
                             :arglists ([zloc]),
                             :doc "Return tag of current node in `zloc`.\n",
                             :type :var}
                            {:name value,
                             :file "rewrite_clj/zip/base.cljc",
                             :line 61,
                             :arglists ([zloc]),
                             :doc "DEPRECATED. Return a tag/s-expression pair for inner nodes, or\nthe s-expression itself for leaves.",
                             :deprecated "0.4.0",
                             :type :var})}
                 {:name rewrite-clj.zip.editz,
                  :no-doc true,
                  :publics ({:name edit,
                             :file "rewrite_clj/zip/editz.cljc",
                             :line 26,
                             :arglists ([zloc f & args]),
                             :doc "Return zipper with the current node in `zloc` replaced with the result of:\n\n(`f` (s-expression node) `args`)\n\nThe result of `f` will be coerced to a node if possible.",
                             :type :var}
                            {:name prefix,
                             :file "rewrite_clj/zip/editz.cljc",
                             :line 75,
                             :arglists ([zloc s]),
                             :doc "Return zipper with the current node in `zloc` prefixed with string `s`.\nOperates on token node or a multi-line node, else exception is thrown.\nWhen multi-line, all lines are prefixed.\n\nTODO: either multi-line handling is broken or I don't understand intent of code.",
                             :type :var}
                            {:name replace,
                             :file "rewrite_clj/zip/editz.cljc",
                             :line 12,
                             :arglists ([zloc value]),
                             :doc "Return zipper with the current node in `zloc` replaced with one representing `value`.\n`value` will be coerced to a node if possible.",
                             :type :var}
                            {:name splice,
                             :file "rewrite_clj/zip/editz.cljc",
                             :line 37,
                             :arglists ([zloc]),
                             :doc "Return zipper with the children of the current node in `zloc` merged into itself.\n(akin to Clojure's `unquote-splicing` macro: `~@...`).\n- if the node is not one that can have children, no modification will\n  be performed.\n- if the node has no or only whitespace children, it will be removed.\n- otherwise, splicing will be performed, moving the zipper to the first\n  non-whitespace child afterwards.",
                             :type :var}
                            {:name suffix,
                             :file "rewrite_clj/zip/editz.cljc",
                             :line 90,
                             :arglists ([zloc s]),
                             :doc "Return zipper with the current node in `zloc` suffixed with string `s`.\nOperates on token node or a multi-line node, else exception is thrown.\nWhen multi-line, all lines are suffixed.\n\nTODO: either multi-line handling is broken or I don't understand intent of code.",
                             :type :var})}
                 {:name rewrite-clj.zip.findz,
                  :no-doc true,
                  :publics ({:name find,
                             :file "rewrite_clj/zip/findz.cljc",
                             :line 29,
                             :arglists ([zloc p?] [zloc f p?]),
                             :doc "Return the first node satisfying predicate `p?` seaching from the current node\nin `zloc` traversing by function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                             :type :var}
                            {:name find-depth-first,
                             :file "rewrite_clj/zip/findz.cljc",
                             :line 59,
                             :arglists ([zloc p?]),
                             :doc "Return first node satisfying predicate `p?` searching depth-first from\nthe current node in `zloc`.",
                             :type :var}
                            {:name find-last-by-pos,
                             :file "rewrite_clj/zip/findz.cljc",
                             :line 44,
                             :arglists ([zloc pos] [zloc pos p?]),
                             :doc "Return the last node spanning position `pos` that satisfies predicate `p?`\n searching depth-first from the current node in `zloc`.\n\nNOTE: Does not ignore whitespace/comment nodes.",
                             :type :var}
                            {:name find-next,
                             :file "rewrite_clj/zip/findz.cljc",
                             :line 65,
                             :arglists ([zloc p?] [zloc f p?]),
                             :doc "Return the first node satisfying predicate `p?` searching one movement `f` from the current\nnode in `zloc` traversing by function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                             :type :var}
                            {:name find-next-depth-first,
                             :file "rewrite_clj/zip/findz.cljc",
                             :line 75,
                             :arglists ([zloc p?]),
                             :doc "Return the first node satisfying predicate `p?` searching depth-first from one\nnode after the current node in `zloc`",
                             :type :var}
                            {:name find-next-tag,
                             :file "rewrite_clj/zip/findz.cljc",
                             :line 91,
                             :arglists ([zloc t] [zloc f t]),
                             :doc "Return the first node with tag `t` searching one movement `f` from the current\nnode in `zloc` traversing by function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                             :type :var}
                            {:name find-next-token,
                             :file "rewrite_clj/zip/findz.cljc",
                             :line 118,
                             :arglists ([zloc p?] [zloc f p?]),
                             :doc "Return the first token node satisfying predicate `p?` searching from the current node in `zloc` traversing\nby function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                             :type :var}
                            {:name find-next-value,
                             :file "rewrite_clj/zip/findz.cljc",
                             :line 141,
                             :arglists ([zloc v] [zloc f v]),
                             :doc "Return the first token node with value `v` searching one movement `f` from the current node in `zloc` traversing\nby function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                             :type :var}
                            {:name find-tag,
                             :file "rewrite_clj/zip/findz.cljc",
                             :line 81,
                             :arglists ([zloc t] [zloc f t]),
                             :doc "Return the first node with tag `t` searching from the current node in `zloc` traversing by\nfunction `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                             :type :var}
                            {:name find-tag-by-pos,
                             :file "rewrite_clj/zip/findz.cljc",
                             :line 102,
                             :arglists ([zloc pos t]),
                             :doc "Return the last node spanning position `pos` with tag `t` searching depth-first from the current node in `zloc`.\n",
                             :type :var}
                            {:name find-token,
                             :file "rewrite_clj/zip/findz.cljc",
                             :line 107,
                             :arglists ([zloc p?] [zloc f p?]),
                             :doc "Return the first token node satisfying predicate `p?` searching from the current node in `zloc` traversing\nby function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                             :type :var}
                            {:name find-value,
                             :file "rewrite_clj/zip/findz.cljc",
                             :line 128,
                             :arglists ([zloc v] [zloc f v]),
                             :doc "Return the first token node with value `v` searching one movement `f` from the current node in `zloc` traversing\nby function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                             :type :var})}
                 {:name rewrite-clj.zip.insert,
                  :no-doc true,
                  :publics ({:name append-child,
                             :file "rewrite_clj/zip/insert.cljc",
                             :line 52,
                             :arglists ([zloc item]),
                             :doc "Return zipper with `item` appended as last child of the current node in `zloc`.\nWill insert a space if necessary.",
                             :type :var}
                            {:name insert-child,
                             :file "rewrite_clj/zip/insert.cljc",
                             :line 43,
                             :arglists ([zloc item]),
                             :doc "Return zipper with `item` inserted as the first child of the current node in `zloc`.\n",
                             :type :var}
                            {:name insert-left,
                             :file "rewrite_clj/zip/insert.cljc",
                             :line 33,
                             :arglists ([zloc item]),
                             :doc "Return zipper with `item` inserted to the left of the current node in `zloc`.\nWill insert a space if necessary.",
                             :type :var}
                            {:name insert-right,
                             :file "rewrite_clj/zip/insert.cljc",
                             :line 23,
                             :arglists ([zloc item]),
                             :doc "Return zipper with `item` inserted to the right of the current node in `zloc`.\nWill insert a space if necessary.",
                             :type :var})}
                 {:name rewrite-clj.zip.move,
                  :no-doc true,
                  :publics ({:name down,
                             :file "rewrite_clj/zip/move.cljc",
                             :line 16,
                             :arglists ([zloc]),
                             :doc "Return zipper with location moved down to next non-whitespace/non-comment node in `zloc`.\n",
                             :type :var}
                            {:name end?,
                             :file "rewrite_clj/zip/move.cljc",
                             :line 35,
                             :arglists ([zloc]),
                             :doc "Return true if `zloc` is at end of depth-first traversal.\n",
                             :type :var}
                            {:name left,
                             :file "rewrite_clj/zip/move.cljc",
                             :line 11,
                             :arglists ([zloc]),
                             :doc "Return zipper with location moved left to next non-whitespace/non-comment node in `zloc`.\n",
                             :type :var}
                            {:name leftmost,
                             :file "rewrite_clj/zip/move.cljc",
                             :line 59,
                             :arglists ([zloc]),
                             :doc "Return zipper with location moved to the leftmost non-whitespace/non-comment node in `zloc`.\n",
                             :type :var}
                            {:name leftmost?,
                             :file "rewrite_clj/zip/move.cljc",
                             :line 47,
                             :arglists ([zloc]),
                             :doc "Return true if at leftmost non-whitespace/non-comment node in `zloc`.\n",
                             :type :var}
                            {:name next,
                             :file "rewrite_clj/zip/move.cljc",
                             :line 26,
                             :arglists ([zloc]),
                             :doc "Return zipper with location moved to the next depth-first non-whitespace/non-comment node in `zloc`.\n",
                             :type :var}
                            {:name prev,
                             :file "rewrite_clj/zip/move.cljc",
                             :line 52,
                             :arglists ([zloc]),
                             :doc "Return zipper with location moved to the previous depth-first non-whitespace/non-comment node in `zloc`.\n",
                             :type :var}
                            {:name right,
                             :file "rewrite_clj/zip/move.cljc",
                             :line 6,
                             :arglists ([zloc]),
                             :doc "Return zipper with location moved right to next non-whitespace/non-comment node in `zloc`.\n",
                             :type :var}
                            {:name rightmost,
                             :file "rewrite_clj/zip/move.cljc",
                             :line 66,
                             :arglists ([zloc]),
                             :doc "Return zipper with location moved to the rightmost non-whitespace/non-comment node in `zloc`.\n",
                             :type :var}
                            {:name rightmost?,
                             :file "rewrite_clj/zip/move.cljc",
                             :line 42,
                             :arglists ([zloc]),
                             :doc "Return true if at rightmost non-whitespace/non-comment node in `zloc`.\n",
                             :type :var}
                            {:name up,
                             :file "rewrite_clj/zip/move.cljc",
                             :line 21,
                             :arglists ([zloc]),
                             :doc "Return zipper with location moved up to next non-whitespace/non-comment node in `zloc`.\n",
                             :type :var})}
                 {:name rewrite-clj.zip.removez,
                  :no-doc true,
                  :publics ({:name remove,
                             :file "rewrite_clj/zip/removez.cljc",
                             :line 28,
                             :arglists ([zloc]),
                             :doc "Return zipper with current node in `zloc` removed. Returned zipper location\n is moved to the first non-whitespace node preceding removed node in a depth-first walk.\n Removes whitespace appropriately.\n\n- `[1  2  3]   => [1  3]`\n- `[1 2]       => [1]`\n- `[1 2]       => [2]`\n- `[1]         => []`\n- `[  1  ]     => []`\n- `[1 [2 3] 4] => [1 [2 3]]`\n- `[1 [2 3] 4] => [[2 3] 4]`\n\n If the removed node is at the rightmost location, both preceding and trailing spaces are removed,\n otherwise only trailing spaces are removed. This means that a following element\n (no matter whether on the same line or not) will end up in the same position\n (line/column) as the removed one, _unless_ a comment lies between the original\n node and the neighbour.",
                             :type :var}
                            {:name remove-preserve-newline,
                             :file "rewrite_clj/zip/removez.cljc",
                             :line 51,
                             :arglists ([zloc]),
                             :doc "Same as [[remove]] but preserves newlines.\n",
                             :type :var})}
                 {:name rewrite-clj.zip.seqz,
                  :no-doc true,
                  :publics ({:name assoc,
                             :file "rewrite_clj/zip/seqz.cljc",
                             :line 111,
                             :arglists ([zloc k v]),
                             :doc "Returns zipper with key `k` set to value `v` when current node in `zloc` is a map node.\nReturns zipper with index `k` set to value `v` when current node in `zloc` is a sequence.",
                             :type :var}
                            {:name get,
                             :file "rewrite_clj/zip/seqz.cljc",
                             :line 98,
                             :arglists ([zloc k]),
                             :doc "Returns value node mapped to key `k` when current node in `zloc` is a map node.\nReturns nth `k` value node when current node in `zloc` is a sequence node.",
                             :type :var}
                            {:name list?,
                             :file "rewrite_clj/zip/seqz.cljc",
                             :line 19,
                             :arglists ([zloc]),
                             :doc "Returns true if current node in `zloc` is a list.\n",
                             :type :var}
                            {:name map,
                             :file "rewrite_clj/zip/seqz.cljc",
                             :line 83,
                             :arglists ([f zloc]),
                             :doc "Returns zipper with function `f` applied to all value nodes of current node in `zloc`.\nCurrent node must be a sequence node.\n\nIterates over:\n- value nodes of maps\n- each element of a seq",
                             :type :var}
                            {:name map-keys,
                             :file "rewrite_clj/zip/seqz.cljc",
                             :line 70,
                             :arglists ([f zloc]),
                             :doc "Returns zipper with function `f` applied to all key nodes of the current node in `zloc`.\nCurrent node must be map node.",
                             :type :var}
                            {:name map-vals,
                             :file "rewrite_clj/zip/seqz.cljc",
                             :line 55,
                             :arglists ([f zloc]),
                             :doc "Returns zipper with function `f` applied to all value current node in `zloc`.\nCurrent node must be map node.",
                             :type :var}
                            {:name map?,
                             :file "rewrite_clj/zip/seqz.cljc",
                             :line 34,
                             :arglists ([zloc]),
                             :doc "Returns true if current node in `zloc` is a map.\n",
                             :type :var}
                            {:name seq?,
                             :file "rewrite_clj/zip/seqz.cljc",
                             :line 12,
                             :arglists ([zloc]),
                             :doc "Returns true if current node in `zloc` is a sequence.\n",
                             :type :var}
                            {:name set?,
                             :file "rewrite_clj/zip/seqz.cljc",
                             :line 29,
                             :arglists ([zloc]),
                             :doc "Returns true if current node in `zloc` is a set.\n",
                             :type :var}
                            {:name vector?,
                             :file "rewrite_clj/zip/seqz.cljc",
                             :line 24,
                             :arglists ([zloc]),
                             :doc "Returns true if current node in `zloc` is a vector.\n",
                             :type :var})}
                 {:name rewrite-clj.zip.subedit,
                  :no-doc true,
                  :publics ({:name edit->,
                             :file "rewrite_clj/zip/subedit.cljc",
                             :line 41,
                             :arglists ([zloc & body]),
                             :doc "Like `->`. Threads `zloc` through forms.\nThe resulting zipper will be located at the same path (i.e. the same\nnumber of downwards and right movements from the root) as incoming `zloc`.",
                             :type :macro}
                            {:name edit->>,
                             :file "rewrite_clj/zip/subedit.cljc",
                             :line 48,
                             :arglists ([zloc & body]),
                             :doc "Like `->>`. Threads `zloc` through forms.\nThe resulting zipper will be located at the same path (i.e. the same\nnumber of downwards and right movements from the root) as incoming `zloc`.",
                             :type :macro}
                            {:name edit-node,
                             :file "rewrite_clj/zip/subedit.cljc",
                             :line 32,
                             :arglists ([zloc f]),
                             :doc "Return zipper applying function `f` to `zloc`. The resulting\nzipper will be located at the same path (i.e. the same number of\ndownwards and right movements from the root) incoming `zloc`.",
                             :type :var}
                            {:name subedit->,
                             :file "rewrite_clj/zip/subedit.cljc",
                             :line 72,
                             :arglists ([zloc & body]),
                             :doc "Like `->`. Threads `zloc`, as an isolated sub-tree through forms, then zips\nup to, and locates at, the root of the modified sub-tree.",
                             :type :macro}
                            {:name subedit->>,
                             :file "rewrite_clj/zip/subedit.cljc",
                             :line 78,
                             :arglists ([zloc & body]),
                             :doc "Like `->`. Threads `zloc`, as an isolated sub-tree through forms, then zips\nup to, and locates at, the root of the modified sub-tree.",
                             :type :macro}
                            {:name subedit-node,
                             :file "rewrite_clj/zip/subedit.cljc",
                             :line 64,
                             :arglists ([zloc f]),
                             :doc "Return zipper replacing current node in `zloc` with result of `f` applied to said node as an isolated sub-tree.\nThe resulting zipper will be located on the root of the modified sub-tree.",
                             :type :var}
                            {:name subzip,
                             :file "rewrite_clj/zip/subedit.cljc",
                             :line 57,
                             :arglists ([zloc]),
                             :doc "Create and return a zipper whose root is the current node in `zloc`.\n",
                             :type :var})}
                 {:name rewrite-clj.zip.walk,
                  :no-doc true,
                  :publics ({:name postwalk,
                             :file "rewrite_clj/zip/walk.cljc",
                             :line 38,
                             :arglists ([zloc f] [zloc p? f]),
                             :doc "Return zipper modified by an isolated depth-first post-order traversal.\nTraversal starts at the current node in `zloc` and continues to the end of the isolated sub-tree.\nFunction `f` is called on the zipper locations satisfying predicate `p?`, or all locations when `p?` is absent,\nand must return a valid zipper - modified or not.\n\nWARNING: when function `f` changes the location in the zipper, normal traversal will be affected.",
                             :added "0.4.9",
                             :type :var}
                            {:name postwalk-subtree,
                             :file "rewrite_clj/zip/walk.cljc",
                             :line 28,
                             :arglists ([p? f loc]),
                             :type :var}
                            {:name prewalk,
                             :file "rewrite_clj/zip/walk.cljc",
                             :line 16,
                             :arglists ([zloc f] [zloc p? f]),
                             :doc "Return zipper modified by an isolated depth-first pre-order traversal.\nTraversal starts at the current node in `zloc` and continues to the end of the isolated sub-tree.\nFunction `f` is called on the zipper locations satisfying predicate `p?`, or all locations when `p?` is absent,\nand must return a valid zipper - modified or not.\n\nWARNING: when function `f` changes the location in the zipper, normal traversal will be affected.",
                             :type :var})}
                 {:name rewrite-clj.zip.whitespace,
                  :no-doc true,
                  :publics ({:name append-newline,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 113,
                             :arglists ([zloc & [n]]),
                             :doc "DEPRECATED: renamed to [[insert-newline-right]].\n",
                             :deprecated "0.5.0",
                             :type :var}
                            {:name append-space,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 103,
                             :arglists ([zloc & [n]]),
                             :doc "DEPRECATED: renamed to [[insert-space-right]].\n",
                             :deprecated "0.5.0",
                             :type :var}
                            {:name comment?,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 17,
                             :arglists ([zloc]),
                             :doc "Returns true when the current node in `zloc` is a comment.\n",
                             :type :var}
                            {:name insert-newline-left,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 82,
                             :arglists ([zloc] [zloc n]),
                             :doc "Return zipper with `n` newlines node inserted to the left of the current node in `zloc`.\n`n` defaults to 1.",
                             :added "0.5.0",
                             :type :var}
                            {:name insert-newline-right,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 89,
                             :arglists ([zloc] [zloc n]),
                             :doc "Return zipper with `n` newlines node inserted to the right of the current node in `zloc`.\n`n` defaults to 1.",
                             :added "0.5.0",
                             :type :var}
                            {:name insert-space-left,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 62,
                             :arglists ([zloc] [zloc n]),
                             :doc "Return zipper with `n` space whitespace node inserted to the left of the current node in `zloc`.\n`n` defaults to 1.",
                             :added "0.5.0",
                             :type :var}
                            {:name insert-space-right,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 72,
                             :arglists ([zloc] [zloc n]),
                             :doc "Return zipper with `n` space whitespace node inserted to the right of the current node in `zloc`.\n`n` defaults to 1.",
                             :added "0.5.0",
                             :type :var}
                            {:name linebreak?,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 12,
                             :arglists ([zloc]),
                             :doc "Returns true when the current node in `zloc` is a linebreak.\n",
                             :type :var}
                            {:name prepend-newline,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 108,
                             :arglists ([zloc & [n]]),
                             :doc "DEPRECATED: renamed to [[insert-newline-left]].\n",
                             :deprecated "0.5.0",
                             :type :var}
                            {:name prepend-space,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 98,
                             :arglists ([zloc & [n]]),
                             :doc "DEPRECATED: renamed to [[insert-space-left]].\n",
                             :deprecated "0.5.0",
                             :type :var}
                            {:name skip,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 37,
                             :arglists ([f p? zloc]),
                             :doc "Return zipper with location moved to first location not satisfying predicate `p?` starting from the node in\n`zloc` and traversing by function `f`.",
                             :type :var}
                            {:name skip-whitespace,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 47,
                             :arglists ([zloc] [f zloc]),
                             :doc "Return zipper with location moved to first non-whitespace/non-comment starting from current node in `zloc`\nand traversing by function `f`.\n\n`f` defaults to [[rewrite-clj.zip/right]]",
                             :type :var}
                            {:name skip-whitespace-left,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 55,
                             :arglists ([zloc]),
                             :doc "Return zipper with location moved to first non-whitespace/non-comment starting from current node in `zloc` traversing left.\n",
                             :type :var}
                            {:name whitespace-not-linebreak?,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 22,
                             :arglists ([zloc]),
                             :doc "Returns true when current node in `zloc` is a whitespace but not a linebreak.\n",
                             :type :var}
                            {:name whitespace-or-comment?,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 29,
                             :arglists ([zloc]),
                             :doc "Returns true when current node in `zloc` is whitespace or a comment.\n",
                             :type :var}
                            {:name whitespace?,
                             :file "rewrite_clj/zip/whitespace.cljc",
                             :line 7,
                             :arglists ([zloc]),
                             :doc "Returns true when the current the node in `zloc` is a Clojure whitespace (which includes the comma).\n",
                             :type :var})})},
 :pom-str "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>lread</groupId>\n  <artifactId>rewrite-cljs-playground</artifactId>\n  <version>1.0.0-alpha</version>\n  <name>rewrite-cljs-playground</name>\n  <dependencies>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>clojure</artifactId>\n      <version>1.10.1</version>\n    </dependency>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>clojurescript</artifactId>\n      <version>1.10.520</version>\n    </dependency>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>tools.reader</artifactId>\n      <version>1.3.2</version>\n    </dependency>\n  </dependencies>\n  <properties>\n      <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n  </properties>\n  <build>\n    <sourceDirectory>src</sourceDirectory>\n    <resources>\n        <resource>\n            <directory>src</directory>\n        </resource>\n    </resources>\n  </build>\n  <scm>\n      <connection>scm:git:git@github.com:lread/rewrite-cljs-playground.git</connection>\n      <developerConnection>scm:git:git@github.com:lread/rewrite-cljs-playground.git</developerConnection>\n      <tag>16e294ae4da565e8cb14261def2ee9af4d82c4d1</tag>\n      <url>git@github.com:lread/rewrite-cljs-playground</url>\n  </scm>\n  <repositories>\n    <repository>\n      <id>clojars</id>\n      <url>https://repo.clojars.org/</url>\n    </repository>\n  </repositories>\n  <distributionManagement>\n      <repository>\n          <id>clojars</id>\n          <name>Clojars repository</name>\n          <url>https://clojars.org/repo</url>\n      </repository>\n  </distributionManagement>\n</project>\n"}
