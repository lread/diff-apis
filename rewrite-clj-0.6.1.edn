{:group-id "rewrite-clj", :artifact-id "rewrite-clj", :version "0.6.1", :codox {"clj" ({:doc "Functional hierarchical zipper, with navigation, editing,\nand enumeration.  See Huet", :author "Rich Hickey", :name rewrite-clj.custom-zipper.core, :publics ({:name append-child, :file "rewrite_clj/custom_zipper/core.clj", :line 221, :arglists ([G__2700 G__2701]), :doc "Inserts the item as the rightmost child of the node at this loc,\nwithout moving", :type :var} {:name branch?, :file "rewrite_clj/custom_zipper/core.clj", :line 64, :arglists ([G__2633]), :doc "Returns true if the node at loc is a branch\n", :type :var} {:name children, :file "rewrite_clj/custom_zipper/core.clj", :line 69, :arglists ([G__2636]), :doc "Returns a seq of the children of node at loc, which must be a branch\n", :type :var} {:name custom-zipper, :file "rewrite_clj/custom_zipper/core.clj", :line 25, :arglists ([root]), :no-doc true, :type :var} {:name custom-zipper?, :file "rewrite_clj/custom_zipper/core.clj", :line 42, :arglists ([value]), :no-doc true, :type :var} {:name down, :file "rewrite_clj/custom_zipper/core.clj", :line 98, :arglists ([G__2646]), :doc "Returns the loc of the leftmost child of the node at this loc, or\nnil if no children", :type :var} {:name edit, :file "rewrite_clj/custom_zipper/core.clj", :line 208, :arglists ([loc f & args]), :doc "Replaces the node at this loc with the value of (f node args)\n", :type :var} {:name end?, :file "rewrite_clj/custom_zipper/core.clj", :line 253, :arglists ([G__2715]), :doc "Returns true if loc represents the end of a depth-first walk\n", :type :var} {:name insert-child, :file "rewrite_clj/custom_zipper/core.clj", :line 215, :arglists ([G__2697 G__2698]), :doc "Inserts the item as the leftmost child of the node at this loc,\nwithout moving", :type :var} {:name insert-left, :file "rewrite_clj/custom_zipper/core.clj", :line 180, :arglists ([G__2685 G__2686]), :doc "Inserts the item as the left sibling of the node at this loc,\nwithout moving", :type :var} {:name insert-right, :file "rewrite_clj/custom_zipper/core.clj", :line 192, :arglists ([G__2689 G__2690]), :doc "Inserts the item as the right sibling of the node at this loc,\nwithout moving", :type :var} {:name left, :file "rewrite_clj/custom_zipper/core.clj", :line 155, :arglists ([G__2671]), :doc "Returns the loc of the left sibling of the node at this loc, or nil\n", :type :var} {:name leftmost, :file "rewrite_clj/custom_zipper/core.clj", :line 167, :arglists ([G__2678]), :doc "Returns the loc of the leftmost sibling of the node at this loc, or self\n", :type :var} {:name lefts, :file "rewrite_clj/custom_zipper/core.clj", :line 93, :arglists ([G__2644]), :doc "Returns a seq of the left siblings of this loc\n", :type :var} {:name make-node, :file "rewrite_clj/custom_zipper/core.clj", :line 76, :arglists ([G__2639 G__2640 G__2641]), :doc "Returns a new branch node, given an existing node and new\nchildren. The loc is only used to supply the constructor.", :no-doc true, :type :var} {:name next, :file "rewrite_clj/custom_zipper/core.clj", :line 227, :arglists ([G__2703]), :doc "Moves to the next loc in the hierarchy, depth-first. When reaching\nthe end, returns a distinguished loc detectable via end?. If already\nat the end, stays there.", :type :var} {:name node, :file "rewrite_clj/custom_zipper/core.clj", :line 59, :arglists ([G__2630]), :doc "Returns the node at loc\n", :type :var} {:name position, :file "rewrite_clj/custom_zipper/core.clj", :line 82, :arglists ([loc]), :doc "Returns the ones-based [row col] of the start of the current node\n", :type :var} {:name prev, :file "rewrite_clj/custom_zipper/core.clj", :line 242, :arglists ([G__2710]), :doc "Moves to the previous loc in the hierarchy, depth-first. If already\nat the root, returns nil.", :type :var} {:name remove, :file "rewrite_clj/custom_zipper/core.clj", :line 258, :arglists ([G__2717]), :doc "Removes the node at loc, returning the loc that would have preceded\nit in a depth-first walk.", :type :var} {:name replace, :file "rewrite_clj/custom_zipper/core.clj", :line 203, :arglists ([G__2693 G__2694]), :doc "Replaces the node at this loc, without moving\n", :type :var} {:name right, :file "rewrite_clj/custom_zipper/core.clj", :line 137, :arglists ([G__2661]), :doc "Returns the loc of the right sibling of the node at this loc, or nil\n", :type :var} {:name rightmost, :file "rewrite_clj/custom_zipper/core.clj", :line 148, :arglists ([G__2668]), :doc "Returns the loc of the rightmost sibling of the node at this loc, or self\n", :type :var} {:name root, :file "rewrite_clj/custom_zipper/core.clj", :line 127, :arglists ([G__2658]), :doc "zips all the way up and returns the root node, reflecting any changes.\n", :type :var} {:name up, :file "rewrite_clj/custom_zipper/core.clj", :line 113, :arglists ([G__2655]), :doc "Returns the loc of the parent of the node at this loc, or nil if at\nthe top", :type :var} {:name zipper, :file "rewrite_clj/custom_zipper/core.clj", :line 34, :arglists ([root]), :no-doc true, :type :var})} {:no-doc true, :name rewrite-clj.custom-zipper.utils, :publics ({:name remove-and-move-left, :file "rewrite_clj/custom_zipper/utils.clj", :line 62, :arglists ([loc]), :doc "Remove current node and move left. If current node is at the leftmost\nlocation, returns `nil`.", :type :var} {:name remove-and-move-right, :file "rewrite_clj/custom_zipper/utils.clj", :line 83, :arglists ([loc]), :doc "Remove current node and move right. If current node is at the rightmost\nlocation, returns `nil`.", :type :var} {:name remove-left, :file "rewrite_clj/custom_zipper/utils.clj", :line 25, :arglists ([loc]), :doc "Remove left sibling of the current node (if there is one).\n", :type :var} {:name remove-left-while, :file "rewrite_clj/custom_zipper/utils.clj", :line 49, :arglists ([zloc p?]), :doc "Remove elements to the left of the current zipper location as long as\nthe given predicate matches.", :type :var} {:name remove-right, :file "rewrite_clj/custom_zipper/utils.clj", :line 15, :arglists ([loc]), :doc "Remove right sibling of the current node (if there is one).\n", :type :var} {:name remove-right-while, :file "rewrite_clj/custom_zipper/utils.clj", :line 38, :arglists ([zloc p?]), :doc "Remove elements to the right of the current zipper location as long as\nthe given predicate matches.", :type :var})} {:added "0.4.0", :name rewrite-clj.node, :publics ({:name child-sexprs, :file "rewrite_clj/node/protocols.clj", :line 72, :arglists ([node]), :doc "Get all child s-expressions for the given node.\n", :type :var} {:name children, :file "rewrite_clj/node.clj", :line 25, :arglists ([_]), :doc "Get child nodes.\n", :type :var} {:name coerce, :file "rewrite_clj/node.clj", :line 25, :arglists ([_]), :type :var} {:name comma-node, :file "rewrite_clj/node/whitespace.clj", :line 83, :arglists ([s]), :doc "Create comma node.\n", :type :var} {:name comma-separated, :file "rewrite_clj/node/whitespace.clj", :line 127, :arglists ([nodes]), :doc "Interleave the given seq of nodes with `\", \"` nodes.\n", :type :var} {:name comma?, :file "rewrite_clj/node/whitespace.clj", :line 162, :arglists ([node]), :doc "Check whether a node represents a comma.\n", :type :var} {:name comment-node, :file "rewrite_clj/node/comment.clj", :line 25, :arglists ([s]), :doc "Create node representing an EDN comment.\n", :type :var} {:name comment?, :file "rewrite_clj/node/comment.clj", :line 31, :arglists ([node]), :doc "Check whether a node represents a comment.\n", :type :var} {:name concat-strings, :file "rewrite_clj/node/protocols.clj", :line 44, :arglists ([nodes]), :doc "Convert nodes to strings and concatenate them.\n", :no-doc true, :type :var} {:name deref-node, :file "rewrite_clj/node/reader_macro.clj", :line 134, :arglists ([children]), :doc "Create node representing the dereferencing of a form. (`@...`)\nTakes either a seq of nodes or a single one.", :type :var} {:name eval-node, :file "rewrite_clj/node/reader_macro.clj", :line 116, :arglists ([children]), :doc "Create node representing an inline evaluation. (`#=...`)\nTakes either a seq of nodes or a single one.", :type :var} {:name fn-node, :file "rewrite_clj/node/fn.clj", :line 92, :arglists ([children]), :doc "Create node representing an anonymous function.\n", :type :var} {:name forms-node, :file "rewrite_clj/node/forms.clj", :line 40, :arglists ([children]), :doc "Create top-level node wrapping multiple children\n(equals an implicit `do` on the top-level).", :type :var} {:name inner?, :file "rewrite_clj/node.clj", :line 25, :arglists ([_]), :doc "Check whether the node can contain children.\n", :type :var} {:name integer-node, :file "rewrite_clj/node/integer.clj", :line 33, :arglists ([value] [value base]), :doc "Create node for an EDN integer with the given base.\n", :type :var} {:name keyword-node, :file "rewrite_clj/node/keyword.clj", :line 36, :arglists ([k & [namespaced?]]), :doc "Create node representing a keyword. If `namespaced?` is given as `true`\na keyword à la `::x` or `::ns/x` (i.e. namespaced/aliased) is generated.", :type :var} {:name leader-length, :file "rewrite_clj/node.clj", :line 25, :arglists ([_]), :doc "How many characters appear before children?\n", :type :var} {:name length, :file "rewrite_clj/node.clj", :line 25, :arglists ([_]), :doc "Get number of characters for the string version of this node.\n", :type :var} {:name line-separated, :file "rewrite_clj/node/whitespace.clj", :line 135, :arglists ([nodes]), :doc "Interleave the given seq of nodes with newline nodes.\n", :type :var} {:name linebreak?, :file "rewrite_clj/node/whitespace.clj", :line 157, :arglists ([node]), :doc "Check whether a ndoe represents linebreaks.\n", :type :var} {:name list-node, :file "rewrite_clj/node/seq.clj", :line 92, :arglists ([children]), :doc "Create a node representing an EDN list.\n", :type :var} {:name map-node, :file "rewrite_clj/node/seq.clj", :line 107, :arglists ([children]), :doc "Create a node representing an EDN map.\n", :type :var} {:name meta-node, :file "rewrite_clj/node/meta.clj", :line 39, :arglists ([children] [metadata data]), :doc "Create node representing a form and its metadata.\n", :type :var} {:name namespaced-map-node, :file "rewrite_clj/node/seq.clj", :line 112, :arglists ([children]), :doc "Create a node representing an EDN map namespace.\n", :type :var} {:name newline-node, :file "rewrite_clj/node/whitespace.clj", :line 89, :arglists ([s]), :doc "Create newline node.\n", :type :var} {:name newlines, :file "rewrite_clj/node/whitespace.clj", :line 121, :arglists ([n]), :doc "Create node representing the given number of newline characters.\n", :type :var} {:name printable-only?, :file "rewrite_clj/node.clj", :line 25, :arglists ([_]), :doc "Return true if the node cannot be converted to an s-expression\nelement.", :type :var} {:name quote-node, :file "rewrite_clj/node/quote.clj", :line 39, :arglists ([children]), :doc "Create node representing a quoted form.\nTakes either a seq of nodes or a single one.", :type :var} {:name raw-meta-node, :file "rewrite_clj/node/meta.clj", :line 47, :arglists ([children] [metadata data]), :doc "Create node representing a form and its metadata using the\n`#^` prefix.", :type :var} {:name reader-macro-node, :file "rewrite_clj/node/reader_macro.clj", :line 127, :arglists ([children] [macro-node form-node]), :doc "Create node representing a reader macro. (`#... ...`)\n", :type :var} {:name regex-node, :file "rewrite_clj/node/regex.clj", :line 19, :arglists ([pattern-string]), :doc "Create node representing a regex\n", :type :var} {:name replace-children, :file "rewrite_clj/node.clj", :line 25, :arglists ([_ children]), :doc "Replace the node's children.\n", :type :var} {:name set-node, :file "rewrite_clj/node/seq.clj", :line 102, :arglists ([children]), :doc "Create a node representing an EDN set.\n", :type :var} {:name sexpr, :file "rewrite_clj/node.clj", :line 25, :arglists ([_]), :doc "Convert node to s-expression.\n", :type :var} {:name sexprs, :file "rewrite_clj/node/protocols.clj", :line 31, :arglists ([nodes]), :doc "Given a seq of nodes, convert those that represent s-expressions\nto the respective forms.", :type :var} {:name spaces, :file "rewrite_clj/node/whitespace.clj", :line 116, :arglists ([n]), :doc "Create node representing the given number of spaces.\n", :type :var} {:name string, :file "rewrite_clj/node.clj", :line 25, :arglists ([_]), :doc "Convert node to printable string.\n", :type :var} {:name string-node, :file "rewrite_clj/node/string.clj", :line 42, :arglists ([lines]), :doc "Create node representing a string value.\nTakes either a seq of strings or a single one.", :type :var} {:name syntax-quote-node, :file "rewrite_clj/node/quote.clj", :line 49, :arglists ([children]), :doc "Create node representing a syntax-quoted form.\nTakes either a seq of nodes or a single one.", :type :var} {:name tag, :file "rewrite_clj/node.clj", :line 25, :arglists ([_]), :doc "Keyword representing the type of the node.\n", :type :var} {:name token-node, :file "rewrite_clj/node/token.clj", :line 22, :arglists ([value & [string-value]]), :doc "Create node for an unspecified EDN token.\n", :type :var} {:name uneval-node, :file "rewrite_clj/node/uneval.clj", :line 34, :arglists ([children]), :doc "Create node representing an EDN uneval `#_` form.\n", :type :var} {:name unquote-node, :file "rewrite_clj/node/quote.clj", :line 59, :arglists ([children]), :doc "Create node representing an unquoted form. (`~...`)\nTakes either a seq of nodes or a single one.", :type :var} {:name unquote-splicing-node, :file "rewrite_clj/node/quote.clj", :line 69, :arglists ([children]), :doc "Create node representing an unquote-spliced form. (`~@...`)\nTakes either a seq of nodes or a single one.", :type :var} {:name value, :file "rewrite_clj/node.clj", :line 115, :arglists ([node]), :doc "DEPRECATED: Get first child as a pair of tag/sexpr (if inner node),\nor just the node's own sexpr. (use explicit analysis of `children`\n`child-sexprs` instead) ", :deprecated "0.4.0", :type :var} {:name var-node, :file "rewrite_clj/node/reader_macro.clj", :line 108, :arglists ([children]), :doc "Create node representing a var.\nTakes either a seq of nodes or a single one.", :type :var} {:name vector-node, :file "rewrite_clj/node/seq.clj", :line 97, :arglists ([children]), :doc "Create a node representing an EDN vector.\n", :type :var} {:name whitespace-node, :file "rewrite_clj/node/whitespace.clj", :line 77, :arglists ([s]), :doc "Create whitespace node.\n", :type :var} {:name whitespace-nodes, :file "rewrite_clj/node/whitespace.clj", :line 101, :arglists ([s]), :doc "Convert a string of whitespace to whitespace/newline nodes.\n", :type :var} {:name whitespace-or-comment?, :file "rewrite_clj/node.clj", :line 107, :arglists ([node]), :doc "Check whether the given node represents whitespace or comment.\n", :type :var} {:name whitespace?, :file "rewrite_clj/node/whitespace.clj", :line 148, :arglists ([node]), :doc "Check whether a node represents whitespace.\n", :type :var})} {:no-doc true, :name rewrite-clj.node.coerce, :publics ()} {:no-doc true, :name rewrite-clj.node.comment, :publics ({:name comment-node, :file "rewrite_clj/node/comment.clj", :line 25, :arglists ([s]), :doc "Create node representing an EDN comment.\n", :type :var} {:name comment?, :file "rewrite_clj/node/comment.clj", :line 31, :arglists ([node]), :doc "Check whether a node represents a comment.\n", :type :var} {:name CommentNode, :file "rewrite_clj/node/comment.clj", :line 6, :type :var})} {:no-doc true, :name rewrite-clj.node.fn, :publics ({:name fn-node, :file "rewrite_clj/node/fn.clj", :line 92, :arglists ([children]), :doc "Create node representing an anonymous function.\n", :type :var} {:name FnNode, :file "rewrite_clj/node/fn.clj", :line 62, :type :var})} {:no-doc true, :name rewrite-clj.node.forms, :publics ({:name forms-node, :file "rewrite_clj/node/forms.clj", :line 40, :arglists ([children]), :doc "Create top-level node wrapping multiple children\n(equals an implicit `do` on the top-level).", :type :var} {:name FormsNode, :file "rewrite_clj/node/forms.clj", :line 6, :type :var})} {:no-doc true, :name rewrite-clj.node.indent, :publics ({:name indent-spaces, :file "rewrite_clj/node/indent.clj", :line 54, :arglists ([node n]), :type :var} {:name indent-tabs, :file "rewrite_clj/node/indent.clj", :line 59, :arglists ([node n]), :type :var} {:name LinePrefixedNode, :file "rewrite_clj/node/indent.clj", :line 26, :type :var} {:name prefix-lines, :file "rewrite_clj/node/indent.clj", :line 50, :arglists ([node prefix]), :type :var})} {:no-doc true, :name rewrite-clj.node.integer, :publics ({:name integer-node, :file "rewrite_clj/node/integer.clj", :line 33, :arglists ([value] [value base]), :doc "Create node for an EDN integer with the given base.\n", :type :var} {:name IntNode, :file "rewrite_clj/node/integer.clj", :line 6, :type :var})} {:no-doc true, :name rewrite-clj.node.keyword, :publics ({:name keyword-node, :file "rewrite_clj/node/keyword.clj", :line 36, :arglists ([k & [namespaced?]]), :doc "Create node representing a keyword. If `namespaced?` is given as `true`\na keyword à la `::x` or `::ns/x` (i.e. namespaced/aliased) is generated.", :type :var} {:name KeywordNode, :file "rewrite_clj/node/keyword.clj", :line 6, :type :var})} {:no-doc true, :name rewrite-clj.node.meta, :publics ({:name meta-node, :file "rewrite_clj/node/meta.clj", :line 39, :arglists ([children] [metadata data]), :doc "Create node representing a form and its metadata.\n", :type :var} {:name MetaNode, :file "rewrite_clj/node/meta.clj", :line 8, :type :var} {:name raw-meta-node, :file "rewrite_clj/node/meta.clj", :line 47, :arglists ([children] [metadata data]), :doc "Create node representing a form and its metadata using the\n`#^` prefix.", :type :var})} {:added "0.4.0", :name rewrite-clj.node.protocols, :publics ({:name +extent, :file "rewrite_clj/node/protocols.clj", :line 151, :arglists ([[row col] [row-extent col-extent]]), :no-doc true, :type :var} {:name assert-sexpr-count, :file "rewrite_clj/node/protocols.clj", :line 110, :arglists ([nodes c]), :no-doc true, :type :var} {:name assert-single-sexpr, :file "rewrite_clj/node/protocols.clj", :line 117, :arglists ([nodes]), :no-doc true, :type :var} {:name child-sexprs, :file "rewrite_clj/node/protocols.clj", :line 72, :arglists ([node]), :doc "Get all child s-expressions for the given node.\n", :type :var} {:name concat-strings, :file "rewrite_clj/node/protocols.clj", :line 44, :arglists ([nodes]), :doc "Convert nodes to strings and concatenate them.\n", :no-doc true, :type :var} {:name extent, :file "rewrite_clj/node/protocols.clj", :line 121, :arglists ([node]), :doc "A node's extent is how far it moves the \"cursor\".\n\nRows are simple - if we have x newlines in the string representation, we\nwill always move the \"cursor\" x rows.\n\nColumns are strange.  If we have *any* newlines at all in the textual\nrepresentation of a node, following nodes' column positions are not\naffected by our startting column position at all.  So the second number\nin the pair we return is interpreted as a relative column adjustment\nwhen the first number in the pair (rows) is zero, and as an absolute\ncolumn position when rows is non-zero.", :no-doc true, :type :var} {:name InnerNode, :file "rewrite_clj/node/protocols.clj", :line 51, :doc "Protocol for non-leaf EDN/Clojure nodes.\n", :type :protocol, :members ({:name children, :arglists ([_]), :doc "Get child nodes.\n", :type :var} {:name inner?, :arglists ([_]), :doc "Check whether the node can contain children.\n", :type :var} {:name leader-length, :arglists ([_]), :doc "How many characters appear before children?\n", :type :var} {:name replace-children, :arglists ([_ children]), :doc "Replace the node's children.\n", :type :var})} {:name make-printable!, :file "rewrite_clj/node/protocols.clj", :line 102, :arglists ([class]), :no-doc true, :type :macro} {:name Node, :file "rewrite_clj/node/protocols.clj", :line 9, :doc "Protocol for EDN/Clojure nodes.\n", :type :protocol, :members ({:name length, :arglists ([_]), :doc "Get number of characters for the string version of this node.\n", :type :var} {:name printable-only?, :arglists ([_]), :doc "Return true if the node cannot be converted to an s-expression\nelement.", :type :var} {:name sexpr, :arglists ([_]), :doc "Convert node to s-expression.\n", :type :var} {:name string, :arglists ([_]), :doc "Convert node to printable string.\n", :type :var} {:name tag, :arglists ([_]), :doc "Keyword representing the type of the node.\n", :type :var})} {:name NodeCoerceable, :file "rewrite_clj/node/protocols.clj", :line 80, :doc "Protocol for values that can be coerced to nodes.\n", :type :protocol, :members ({:name coerce, :arglists ([_]), :type :var})} {:name sexprs, :file "rewrite_clj/node/protocols.clj", :line 31, :arglists ([nodes]), :doc "Given a seq of nodes, convert those that represent s-expressions\nto the respective forms.", :type :var} {:name sum-lengths, :file "rewrite_clj/node/protocols.clj", :line 39, :arglists ([nodes]), :doc "Sum up lengths of the given nodes.\n", :no-doc true, :type :var} {:name write-node, :file "rewrite_clj/node/protocols.clj", :line 98, :arglists ([writer node]), :no-doc true, :type :var})} {:no-doc true, :name rewrite-clj.node.quote, :publics ({:name quote-node, :file "rewrite_clj/node/quote.clj", :line 39, :arglists ([children]), :doc "Create node representing a quoted form.\nTakes either a seq of nodes or a single one.", :type :var} {:name QuoteNode, :file "rewrite_clj/node/quote.clj", :line 6, :type :var} {:name syntax-quote-node, :file "rewrite_clj/node/quote.clj", :line 49, :arglists ([children]), :doc "Create node representing a syntax-quoted form.\nTakes either a seq of nodes or a single one.", :type :var} {:name unquote-node, :file "rewrite_clj/node/quote.clj", :line 59, :arglists ([children]), :doc "Create node representing an unquoted form. (`~...`)\nTakes either a seq of nodes or a single one.", :type :var} {:name unquote-splicing-node, :file "rewrite_clj/node/quote.clj", :line 69, :arglists ([children]), :doc "Create node representing an unquote-spliced form. (`~@...`)\nTakes either a seq of nodes or a single one.", :type :var})} {:no-doc true, :name rewrite-clj.node.reader-macro, :publics ({:name deref-node, :file "rewrite_clj/node/reader_macro.clj", :line 134, :arglists ([children]), :doc "Create node representing the dereferencing of a form. (`@...`)\nTakes either a seq of nodes or a single one.", :type :var} {:name DerefNode, :file "rewrite_clj/node/reader_macro.clj", :line 67, :type :var} {:name eval-node, :file "rewrite_clj/node/reader_macro.clj", :line 116, :arglists ([children]), :doc "Create node representing an inline evaluation. (`#=...`)\nTakes either a seq of nodes or a single one.", :type :var} {:name reader-macro-node, :file "rewrite_clj/node/reader_macro.clj", :line 127, :arglists ([children] [macro-node form-node]), :doc "Create node representing a reader macro. (`#... ...`)\n", :type :var} {:name ReaderMacroNode, :file "rewrite_clj/node/reader_macro.clj", :line 41, :type :var} {:name ReaderNode, :file "rewrite_clj/node/reader_macro.clj", :line 8, :type :var} {:name var-node, :file "rewrite_clj/node/reader_macro.clj", :line 108, :arglists ([children]), :doc "Create node representing a var.\nTakes either a seq of nodes or a single one.", :type :var})} {:no-doc true, :name rewrite-clj.node.regex, :publics ({:name regex-node, :file "rewrite_clj/node/regex.clj", :line 19, :arglists ([pattern-string]), :doc "Create node representing a regex\n", :type :var} {:name RegexNode, :file "rewrite_clj/node/regex.clj", :line 7, :type :var})} {:no-doc true, :name rewrite-clj.node.seq, :publics ({:name list-node, :file "rewrite_clj/node/seq.clj", :line 92, :arglists ([children]), :doc "Create a node representing an EDN list.\n", :type :var} {:name map-node, :file "rewrite_clj/node/seq.clj", :line 107, :arglists ([children]), :doc "Create a node representing an EDN map.\n", :type :var} {:name namespaced-map-node, :file "rewrite_clj/node/seq.clj", :line 112, :arglists ([children]), :doc "Create a node representing an EDN map namespace.\n", :type :var} {:name NamespacedMapNode, :file "rewrite_clj/node/seq.clj", :line 47, :type :var} {:name SeqNode, :file "rewrite_clj/node/seq.clj", :line 6, :type :var} {:name set-node, :file "rewrite_clj/node/seq.clj", :line 102, :arglists ([children]), :doc "Create a node representing an EDN set.\n", :type :var} {:name vector-node, :file "rewrite_clj/node/seq.clj", :line 97, :arglists ([children]), :doc "Create a node representing an EDN vector.\n", :type :var})} {:no-doc true, :name rewrite-clj.node.string, :publics ({:name string-node, :file "rewrite_clj/node/string.clj", :line 42, :arglists ([lines]), :doc "Create node representing a string value.\nTakes either a seq of strings or a single one.", :type :var} {:name StringNode, :file "rewrite_clj/node/string.clj", :line 16, :type :var})} {:no-doc true, :name rewrite-clj.node.token, :publics ({:name token-node, :file "rewrite_clj/node/token.clj", :line 22, :arglists ([value & [string-value]]), :doc "Create node for an unspecified EDN token.\n", :type :var} {:name TokenNode, :file "rewrite_clj/node/token.clj", :line 6, :type :var})} {:no-doc true, :name rewrite-clj.node.uneval, :publics ({:name uneval-node, :file "rewrite_clj/node/uneval.clj", :line 34, :arglists ([children]), :doc "Create node representing an EDN uneval `#_` form.\n", :type :var} {:name UnevalNode, :file "rewrite_clj/node/uneval.clj", :line 6, :type :var})} {:no-doc true, :name rewrite-clj.node.whitespace, :publics ({:name *count-fn*, :file "rewrite_clj/node/whitespace.clj", :line 11, :doc "This function is applied to every newline string and should produce\nthe eventual character count.", :dynamic true, :type :var} {:name *newline-fn*, :file "rewrite_clj/node/whitespace.clj", :line 7, :doc "This function is applied to every newline string.\n", :dynamic true, :type :var} {:name comma-node, :file "rewrite_clj/node/whitespace.clj", :line 83, :arglists ([s]), :doc "Create comma node.\n", :type :var} {:name comma-separated, :file "rewrite_clj/node/whitespace.clj", :line 127, :arglists ([nodes]), :doc "Interleave the given seq of nodes with `\", \"` nodes.\n", :type :var} {:name comma?, :file "rewrite_clj/node/whitespace.clj", :line 162, :arglists ([node]), :doc "Check whether a node represents a comma.\n", :type :var} {:name CommaNode, :file "rewrite_clj/node/whitespace.clj", :line 40, :type :var} {:name line-separated, :file "rewrite_clj/node/whitespace.clj", :line 135, :arglists ([nodes]), :doc "Interleave the given seq of nodes with newline nodes.\n", :type :var} {:name linebreak?, :file "rewrite_clj/node/whitespace.clj", :line 157, :arglists ([node]), :doc "Check whether a ndoe represents linebreaks.\n", :type :var} {:name newline-node, :file "rewrite_clj/node/whitespace.clj", :line 89, :arglists ([s]), :doc "Create newline node.\n", :type :var} {:name NewlineNode, :file "rewrite_clj/node/whitespace.clj", :line 52, :type :var} {:name newlines, :file "rewrite_clj/node/whitespace.clj", :line 121, :arglists ([n]), :doc "Create node representing the given number of newline characters.\n", :type :var} {:name space-separated, :file "rewrite_clj/node/whitespace.clj", :line 141, :arglists ([nodes]), :doc "Interleave the given seq of nodes with `\" \"` nodes.\n", :type :var} {:name spaces, :file "rewrite_clj/node/whitespace.clj", :line 116, :arglists ([n]), :doc "Create node representing the given number of spaces.\n", :type :var} {:name whitespace-node, :file "rewrite_clj/node/whitespace.clj", :line 77, :arglists ([s]), :doc "Create whitespace node.\n", :type :var} {:name whitespace-nodes, :file "rewrite_clj/node/whitespace.clj", :line 101, :arglists ([s]), :doc "Convert a string of whitespace to whitespace/newline nodes.\n", :type :var} {:name whitespace?, :file "rewrite_clj/node/whitespace.clj", :line 148, :arglists ([node]), :doc "Check whether a node represents whitespace.\n", :type :var} {:name WhitespaceNode, :file "rewrite_clj/node/whitespace.clj", :line 28, :type :var} {:name with-count-fn, :file "rewrite_clj/node/whitespace.clj", :line 21, :arglists ([f & body]), :type :macro} {:name with-newline-fn, :file "rewrite_clj/node/whitespace.clj", :line 16, :arglists ([f & body]), :type :macro})} {:name rewrite-clj.parser, :publics ({:name parse, :file "rewrite_clj/parser.clj", :line 10, :arglists ([reader]), :doc "Parse next form from the given reader.\n", :type :var} {:name parse-all, :file "rewrite_clj/parser.clj", :line 15, :arglists ([reader]), :doc "Parse all forms from the given reader.\n", :type :var} {:name parse-file, :file "rewrite_clj/parser.clj", :line 37, :arglists ([f]), :doc "Parse first form from the given file.\n", :type :var} {:name parse-file-all, :file "rewrite_clj/parser.clj", :line 44, :arglists ([f]), :doc "Parse all forms from the given file.\n", :type :var} {:name parse-string, :file "rewrite_clj/parser.clj", :line 27, :arglists ([s]), :doc "Parse first form in the given string.\n", :type :var} {:name parse-string-all, :file "rewrite_clj/parser.clj", :line 32, :arglists ([s]), :doc "Parse all forms in the given string.\n", :type :var})} {:no-doc true, :name rewrite-clj.parser.core, :publics ({:name parse-next, :file "rewrite_clj/parser/core.clj", :line 33, :arglists ([reader]), :type :var})} {:no-doc true, :name rewrite-clj.parser.keyword, :publics ({:name parse-keyword, :file "rewrite_clj/parser/keyword.clj", :line 8, :arglists ([reader]), :type :var})} {:no-doc true, :name rewrite-clj.parser.string, :publics ({:name parse-regex, :file "rewrite_clj/parser/string.clj", :line 40, :arglists ([reader]), :type :var} {:name parse-string, :file "rewrite_clj/parser/string.clj", :line 36, :arglists ([reader]), :type :var})} {:no-doc true, :name rewrite-clj.parser.token, :publics ({:name parse-token, :file "rewrite_clj/parser/token.clj", :line 36, :arglists ([reader]), :doc "Parse a single token.\n", :type :var})} {:no-doc true, :name rewrite-clj.parser.utils, :publics ({:name ignore, :file "rewrite_clj/parser/utils.clj", :line 19, :arglists ([reader]), :doc "Ignore next character of Reader.\n", :type :var} {:name linebreak?, :file "rewrite_clj/parser/utils.clj", :line 9, :arglists ([c]), :doc "Check if a given character is a linebreak.\n", :type :var} {:name read-eol, :file "rewrite_clj/parser/utils.clj", :line 33, :arglists ([reader]), :type :var} {:name space?, :file "rewrite_clj/parser/utils.clj", :line 14, :arglists ([c]), :doc "Check if a given character is a non-linebreak whitespace.\n", :type :var} {:name throw-reader, :file "rewrite_clj/parser/utils.clj", :line 25, :arglists ([reader & msg]), :type :var} {:name whitespace?, :file "rewrite_clj/parser/utils.clj", :line 4, :arglists ([c]), :doc "Check if a given character is a whitespace.\n", :type :var})} {:no-doc true, :name rewrite-clj.parser.whitespace, :publics ({:name parse-whitespace, :file "rewrite_clj/parser/whitespace.clj", :line 6, :arglists ([reader]), :doc "Parse as much whitespace as possible. The created node can either contain\nonly linebreaks or only space/tabs.", :type :var})} {:no-doc true, :name rewrite-clj.potemkin, :publics ({:name defprotocol+, :file "rewrite_clj/potemkin.clj", :line 132, :arglists ([name & body]), :doc "A simpler version of 'potemkin.types/defprotocol+'.\n", :type :macro} {:name import-def, :file "rewrite_clj/potemkin.clj", :line 84, :arglists ([sym] [sym name]), :doc "Given a regular def'd var from another namespace, defined a new var with the\nsame name in the current namespace.", :type :macro} {:name import-fn, :file "rewrite_clj/potemkin.clj", :line 37, :arglists ([sym] [sym name]), :doc "Given a function in another namespace, defines a function with the\nsame name in the current namespace.  Argument lists, doc-strings,\nand original line-numbers are preserved.", :type :macro} {:name import-macro, :file "rewrite_clj/potemkin.clj", :line 61, :arglists ([sym] [sym name]), :doc "Given a macro in another namespace, defines a macro with the same\nname in the current namespace.  Argument lists, doc-strings, and\noriginal line-numbers are preserved.", :type :macro} {:name import-vars, :file "rewrite_clj/potemkin.clj", :line 103, :arglists ([& syms]), :doc "Imports a list of vars from other namespaces.\n", :type :macro} {:name link-vars, :file "rewrite_clj/potemkin.clj", :line 29, :arglists ([src dst]), :doc "Makes sure that all changes to `src` are reflected in `dst`.\n", :type :var})} {:no-doc true, :name rewrite-clj.reader, :publics ({:name boundary?, :file "rewrite_clj/reader.clj", :line 23, :arglists ([c]), :type :var} {:name comma?, :file "rewrite_clj/reader.clj", :line 31, :arglists ([c]), :type :var} {:name file-reader, :file "rewrite_clj/reader.clj", :line 174, :arglists ([f]), :doc "Create reader for files.\n", :type :var} {:name ignore, :file "rewrite_clj/reader.clj", :line 101, :arglists ([reader]), :doc "Ignore the next character.\n", :type :var} {:name linebreak?, :file "rewrite_clj/reader.clj", :line 41, :arglists ([c]), :type :var} {:name next, :file "rewrite_clj/reader.clj", :line 107, :arglists ([reader]), :doc "Read next char.\n", :type :var} {:name peek, :file "rewrite_clj/reader.clj", :line 117, :arglists ([reader]), :doc "Peek next char.\n", :type :var} {:name position, :file "rewrite_clj/reader.clj", :line 122, :arglists ([reader row-k col-k]), :doc "Create map of `row-k` and `col-k` representing the current reader position.\n", :type :var} {:name read-include-linebreak, :file "rewrite_clj/reader.clj", :line 87, :arglists ([reader]), :doc "Read until linebreak and include it.\n", :type :var} {:name read-n, :file "rewrite_clj/reader.clj", :line 145, :arglists ([reader node-tag read-fn p? n]), :doc "Call the given function on the given reader until `n` values matching `p?` have been\ncollected.", :type :var} {:name read-repeatedly, :file "rewrite_clj/reader.clj", :line 137, :arglists ([reader read-fn]), :doc "Call the given function on the given reader until it returns\na non-truthy value.", :type :var} {:name read-until, :file "rewrite_clj/reader.clj", :line 78, :arglists ([reader p?]), :doc "Read until a char fulfills the given condition. Ignores the\nmatching char.", :type :var} {:name read-while, :file "rewrite_clj/reader.clj", :line 57, :arglists ([reader p? & [eof?]]), :doc "Read while the chars fulfill the given condition. Ignores\nthe unmatching char.", :type :var} {:name read-with-meta, :file "rewrite_clj/reader.clj", :line 128, :arglists ([reader read-fn]), :doc "Use the given function to read value, then attach row/col metadata.\n", :type :var} {:name space?, :file "rewrite_clj/reader.clj", :line 45, :arglists ([c]), :type :var} {:name string->edn, :file "rewrite_clj/reader.clj", :line 96, :arglists ([s]), :doc "Convert string to EDN value.\n", :type :var} {:name string-reader, :file "rewrite_clj/reader.clj", :line 167, :arglists ([s]), :doc "Create reader for strings.\n", :type :var} {:name throw-reader, :file "rewrite_clj/reader.clj", :line 11, :arglists ([reader fmt & data]), :doc "Throw reader exception, including line/column.\n", :type :var} {:name unread, :file "rewrite_clj/reader.clj", :line 112, :arglists ([reader ch]), :doc "Unreads a char. Puts the char back on the reader.\n", :type :var} {:name whitespace-or-boundary?, :file "rewrite_clj/reader.clj", :line 51, :arglists ([c]), :type :var} {:name whitespace?, :file "rewrite_clj/reader.clj", :line 35, :arglists ([c]), :type :var})} {:name rewrite-clj.zip, :publics ({:name ->root-string, :file "rewrite_clj/zip.clj", :line 116, :arglists ([zloc]), :doc "DEPRECATED. Use `root-string` instead.\n", :deprecated "0.4.0", :type :var} {:name ->string, :file "rewrite_clj/zip.clj", :line 111, :arglists ([zloc]), :doc "DEPRECATED. Use `string` instead.\n", :deprecated "0.4.0", :type :var} {:name append-child, :file "rewrite_clj/zip/insert.clj", :line 52, :arglists ([zloc item]), :doc "Insert item as last child of the current node. Will insert a space if necessary.\n", :type :var} {:name append-newline, :file "rewrite_clj/zip/whitespace.clj", :line 101, :arglists ([zloc & [n]]), :doc "Append a newline node representing the given number of linebreaks (default:\n1).\n\nDEPRECATED: use 'insert-newline-right' instead.", :deprecated "0.5.0", :type :var} {:name append-space, :file "rewrite_clj/zip/whitespace.clj", :line 86, :arglists ([zloc & [n]]), :doc "Append a whitespace node representing the given number of spaces (default: 1).\n\nDEPRECATED: use 'insert-space-right' instead.", :deprecated "0.5.0", :type :var} {:name assoc, :file "rewrite_clj/zip/seq.clj", :line 100, :arglists ([zloc k v]), :doc "Set map/seq element to the given value.\n", :type :var} {:name child-sexprs, :file "rewrite_clj/zip/base.clj", :line 51, :arglists ([zloc]), :doc "Get children as s-expressions.\n", :added "0.4.4", :type :var} {:name down, :file "rewrite_clj/zip/move.clj", :line 16, :arglists ([zloc]), :doc "Move down to next non-whitespace/non-comment location.\n", :type :var} {:name down*, :file "rewrite_clj/zip.clj", :line 98, :arglists ([G__2646]), :doc "Directly call 'rewrite-clj.custom-zipper.core/down' on the given arguments.\n", :type :var} {:name edit, :file "rewrite_clj/zip/edit.clj", :line 30, :arglists ([zloc f & args]), :doc "Apply the given function to the s-expression at the given\nlocation, using its result to replace the node there. (The\nresult will be coerced to a node if possible.)", :type :var} {:name edit*, :file "rewrite_clj/zip.clj", :line 104, :arglists ([loc f & args]), :doc "Directly call 'rewrite-clj.custom-zipper.core/edit' on the given arguments.\n", :type :var} {:name edit->, :file "rewrite_clj/zip/subedit.clj", :line 40, :arglists ([zloc & body]), :doc "Like `->`, applying the given function to the current zipper location.\nThe resulting zipper will be located at the same path (i.e. the same\nnumber of downwards and right movements from the root) as the original\nnode.", :type :macro} {:name edit->>, :file "rewrite_clj/zip/subedit.clj", :line 48, :arglists ([zloc & body]), :doc "Like `->>`, applying the given function to the current zipper location.\nThe resulting zipper will be located at the same path (i.e. the same\nnumber of downwards and right movements from the root) as the original\nnode.", :type :macro} {:name edit-node, :file "rewrite_clj/zip/subedit.clj", :line 31, :arglists ([zloc f]), :doc "Apply the given function to the current zipper location. The resulting\nzipper will be located at the same path (i.e. the same number of\ndownwards and right movements from the root) as the original node.", :type :var} {:name edn, :file "rewrite_clj/zip/base.clj", :line 24, :arglists ([node] [node {:keys [track-position?], :as options}]), :doc "Create zipper over the given Clojure/EDN node and move to the first\nnon-whitespace/non-comment child.\n\nIf `:track-position?` is set, this will create a custom zipper that will\nreturn the current row/column using `rewrite-clj.zip/position`. (Note that\nthis custom zipper will be incompatible with `clojure.zip`'s functions.)", :type :var} {:name edn*, :file "rewrite_clj/zip/base.clj", :line 11, :arglists ([node] [node {:keys [track-position?]}]), :doc "Create zipper over the given Clojure/EDN node.\n\nIf `:track-position?` is set, this will create a custom zipper that will\nreturn the current row/column using `rewrite-clj.zip/position`. (Note that\nthis custom zipper will be incompatible with `clojure.zip`'s functions.)", :type :var} {:name end?, :file "rewrite_clj/zip/move.clj", :line 35, :arglists ([zloc]), :doc "Check whether the given node is at the end of the depth-first traversal.\n", :type :var} {:name find, :file "rewrite_clj/zip/find.clj", :line 21, :arglists ([zloc p?] [zloc f p?]), :doc "Find node satisfying the given predicate by repeatedly\napplying the given movement function to the initial zipper\nlocation.", :type :var} {:name find-depth-first, :file "rewrite_clj/zip/find.clj", :line 35, :arglists ([zloc p?]), :doc "Find node satisfying the given predicate by traversing\nthe zipper in a depth-first way.", :type :var} {:name find-next, :file "rewrite_clj/zip/find.clj", :line 41, :arglists ([zloc p?] [zloc f p?]), :doc "Find node other than the current zipper location matching\nthe given predicate by applying the given movement function\nto the initial zipper location.", :type :var} {:name find-next-depth-first, :file "rewrite_clj/zip/find.clj", :line 50, :arglists ([zloc p?]), :doc "Find node other than the current zipper location matching\nthe given predicate by traversing the zipper in a\ndepth-first way.", :type :var} {:name find-next-tag, :file "rewrite_clj/zip/find.clj", :line 65, :arglists ([zloc t] [zloc f t]), :doc "Find node other than the current zipper location with the\ngiven tag by repeatedly applying the given movement function to\nthe initial zipper location.", :type :var} {:name find-next-token, :file "rewrite_clj/zip/find.clj", :line 85, :arglists ([zloc p?] [zloc f p?]), :doc "Find next token node matching the given predicate by applying the\ngiven movement function to the initial zipper location, defaulting\nto `right`.", :type :var} {:name find-next-value, :file "rewrite_clj/zip/find.clj", :line 106, :arglists ([zloc v] [zloc f v]), :doc "Find next token node whose value matches the given one by applying the\ngiven movement function to the initial zipper location, defaulting\nto `right`.", :type :var} {:name find-tag, :file "rewrite_clj/zip/find.clj", :line 57, :arglists ([zloc t] [zloc f t]), :doc "Find node with the given tag by repeatedly applying the given\nmovement function to the initial zipper location.", :type :var} {:name find-token, :file "rewrite_clj/zip/find.clj", :line 75, :arglists ([zloc p?] [zloc f p?]), :doc "Find token node matching the given predicate by applying the\ngiven movement function to the initial zipper location, defaulting\nto `right`.", :type :var} {:name find-value, :file "rewrite_clj/zip/find.clj", :line 94, :arglists ([zloc v] [zloc f v]), :doc "Find token node whose value matches the given one by applying the\ngiven movement function to the initial zipper location, defaulting\nto `right`.", :type :var} {:name get, :file "rewrite_clj/zip/seq.clj", :line 88, :arglists ([zloc k]), :doc "If a map is given, get element with the given key; if a seq is given, get nth element.\n", :type :var} {:name insert-child, :file "rewrite_clj/zip/insert.clj", :line 43, :arglists ([zloc item]), :doc "Insert item as first child of the current node. Will insert a space if necessary.\n", :type :var} {:name insert-left, :file "rewrite_clj/zip/insert.clj", :line 34, :arglists ([zloc item]), :doc "Insert item to the right of the left location. Will insert a space if necessary.\n", :type :var} {:name insert-left*, :file "rewrite_clj/zip.clj", :line 106, :arglists ([G__2685 G__2686]), :doc "Directly call 'rewrite-clj.custom-zipper.core/insert-left' on the given arguments.\n", :type :var} {:name insert-right, :file "rewrite_clj/zip/insert.clj", :line 25, :arglists ([zloc item]), :doc "Insert item to the right of the current location. Will insert a space if necessary.\n", :type :var} {:name insert-right*, :file "rewrite_clj/zip.clj", :line 107, :arglists ([G__2689 G__2690]), :doc "Directly call 'rewrite-clj.custom-zipper.core/insert-right' on the given arguments.\n", :type :var} {:name left, :file "rewrite_clj/zip/move.clj", :line 11, :arglists ([zloc]), :doc "Move left to next non-whitespace/non-comment location.\n", :type :var} {:name left*, :file "rewrite_clj/zip.clj", :line 96, :arglists ([G__2671]), :doc "Directly call 'rewrite-clj.custom-zipper.core/left' on the given arguments.\n", :type :var} {:name leftmost, :file "rewrite_clj/zip/move.clj", :line 61, :arglists ([zloc]), :doc "Move to the leftmost non-whitespace/non-comment location.\n", :type :var} {:name leftmost*, :file "rewrite_clj/zip.clj", :line 102, :arglists ([G__2678]), :doc "Directly call 'rewrite-clj.custom-zipper.core/leftmost' on the given arguments.\n", :type :var} {:name leftmost?, :file "rewrite_clj/zip/move.clj", :line 48, :arglists ([zloc]), :doc "Check if the given location represents the leftmost non-whitespace/\nnon-comment one.", :type :var} {:name length, :file "rewrite_clj/zip/base.clj", :line 56, :arglists ([zloc]), :doc "Get length of printable string for the given zipper location.\n", :type :var} {:name linebreak?, :file "rewrite_clj/zip/whitespace.clj", :line 11, :arglists ([zloc]), :type :var} {:name list?, :file "rewrite_clj/zip/seq.clj", :line 19, :arglists ([zloc]), :type :var} {:name map, :file "rewrite_clj/zip/seq.clj", :line 77, :arglists ([f zloc]), :doc "Apply function to all value nodes in the given seq node. Iterates over\nvalue nodes of maps but over each element of a seq.", :type :var} {:name map-keys, :file "rewrite_clj/zip/seq.clj", :line 65, :arglists ([f zloc]), :doc "Apply function to all key nodes of the given map node.\n", :type :var} {:name map-vals, :file "rewrite_clj/zip/seq.clj", :line 51, :arglists ([f zloc]), :doc "Apply function to all value nodes of the given map node.\n", :type :var} {:name map?, :file "rewrite_clj/zip/seq.clj", :line 31, :arglists ([zloc]), :type :var} {:name next, :file "rewrite_clj/zip/move.clj", :line 26, :arglists ([zloc]), :doc "Move to the next non-whitespace/non-comment location in a depth-first manner.\n", :type :var} {:name next*, :file "rewrite_clj/zip.clj", :line 99, :arglists ([G__2703]), :doc "Directly call 'rewrite-clj.custom-zipper.core/next' on the given arguments.\n", :type :var} {:name node, :file "rewrite_clj/custom_zipper/core.clj", :line 59, :arglists ([G__2630]), :doc "Returns the node at loc\n", :type :var} {:name of-file, :file "rewrite_clj/zip/base.clj", :line 75, :arglists ([f] [f options]), :doc "Create zipper from File.\n", :type :var} {:name of-string, :file "rewrite_clj/zip/base.clj", :line 69, :arglists ([s] [s options]), :doc "Create zipper from String.\n", :type :var} {:name position, :file "rewrite_clj/custom_zipper/core.clj", :line 82, :arglists ([loc]), :doc "Returns the ones-based [row col] of the start of the current node\n", :type :var} {:name postwalk, :file "rewrite_clj/zip/walk.clj", :line 37, :arglists ([zloc f] [zloc p? f]), :doc "Perform a depth-first post-order traversal starting at the given zipper location\nand apply the given function to each child node. If a predicate `p?` is given,\nonly apply the function to nodes matching it.", :added "0.4.9", :type :var} {:name prefix, :file "rewrite_clj/zip/edit.clj", :line 78, :arglists ([zloc s]), :type :var} {:name prepend-newline, :file "rewrite_clj/zip/whitespace.clj", :line 93, :arglists ([zloc & [n]]), :doc "Prepend a newline node representing the given number of linebreaks (default:\n1).\n\nDEPRECATED: use 'insert-newline-left' instead.", :deprecated "0.5.0", :type :var} {:name prepend-space, :file "rewrite_clj/zip/whitespace.clj", :line 79, :arglists ([zloc & [n]]), :doc "Prepend a whitespace node representing the given number of spaces (default: 1).\n\nDEPRECATED: use 'insert-space-left' instead.", :deprecated "0.5.0", :type :var} {:name prev, :file "rewrite_clj/zip/move.clj", :line 54, :arglists ([zloc]), :doc "Move to the next non-whitespace/non-comment location in a depth-first manner.\n", :type :var} {:name prev*, :file "rewrite_clj/zip.clj", :line 100, :arglists ([G__2710]), :doc "Directly call 'rewrite-clj.custom-zipper.core/prev' on the given arguments.\n", :type :var} {:name prewalk, :file "rewrite_clj/zip/walk.clj", :line 18, :arglists ([zloc f] [zloc p? f]), :doc "Perform a depth-first pre-order traversal starting at the given zipper location\nand apply the given function to each child node. If a predicate `p?` is given,\nonly apply the function to nodes matching it.", :type :var} {:name print, :file "rewrite_clj/zip/base.clj", :line 99, :arglists ([zloc & [writer]]), :doc "Print current zipper location.\n", :type :var} {:name print-root, :file "rewrite_clj/zip/base.clj", :line 106, :arglists ([zloc & [writer]]), :doc "Zip up and print root node.\n", :type :var} {:name remove, :file "rewrite_clj/zip/remove.clj", :line 20, :arglists ([zloc]), :doc "Remove value at the given zipper location. Returns the first non-whitespace\nnode that would have preceded it in a depth-first walk. Will remove whitespace\nappropriately.\n\n    [1  2  3]   => [1  3]\n    [1 2]       => [1]\n    [1 2]       => [2]\n    [1]         => []\n    [  1  ]     => []\n    [1 [2 3] 4] => [1 [2 3]]\n    [1 [2 3] 4] => [[2 3] 4]\n\nIf a node is located rightmost, both preceding and trailing spaces are removed,\notherwise only trailing spaces are touched. This means that a following element\n(no matter whether on the same line or not) will end up in the same position\n(line/column) as the removed one, _unless_ a comment lies between the original\nnode and the neighbour.", :type :var} {:name remove*, :file "rewrite_clj/zip.clj", :line 105, :arglists ([G__2717]), :doc "Directly call 'rewrite-clj.custom-zipper.core/remove' on the given arguments.\n", :type :var} {:name replace, :file "rewrite_clj/zip/edit.clj", :line 15, :arglists ([zloc value]), :doc "Replace the node at the given location with one representing\nthe given value. (The value will be coerced to a node if\npossible.)", :type :var} {:name replace*, :file "rewrite_clj/zip.clj", :line 103, :arglists ([G__2693 G__2694]), :doc "Directly call 'rewrite-clj.custom-zipper.core/replace' on the given arguments.\n", :type :var} {:name right, :file "rewrite_clj/zip/move.clj", :line 6, :arglists ([zloc]), :doc "Move right to next non-whitespace/non-comment location.\n", :type :var} {:name right*, :file "rewrite_clj/zip.clj", :line 95, :arglists ([G__2661]), :doc "Directly call 'rewrite-clj.custom-zipper.core/right' on the given arguments.\n", :type :var} {:name rightmost, :file "rewrite_clj/zip/move.clj", :line 68, :arglists ([zloc]), :doc "Move to the rightmost non-whitespace/non-comment location.\n", :type :var} {:name rightmost*, :file "rewrite_clj/zip.clj", :line 101, :arglists ([G__2668]), :doc "Directly call 'rewrite-clj.custom-zipper.core/rightmost' on the given arguments.\n", :type :var} {:name rightmost?, :file "rewrite_clj/zip/move.clj", :line 42, :arglists ([zloc]), :doc "Check if the given location represents the leftmost non-whitespace/\nnon-comment one.", :type :var} {:name root, :file "rewrite_clj/custom_zipper/core.clj", :line 127, :arglists ([G__2658]), :doc "zips all the way up and returns the root node, reflecting any changes.\n", :type :var} {:name root-string, :file "rewrite_clj/zip/base.clj", :line 88, :arglists ([zloc]), :doc "Create string representing the zipped-up zipper.\n", :added "0.4.0", :type :var} {:name seq?, :file "rewrite_clj/zip/seq.clj", :line 13, :arglists ([zloc]), :type :var} {:name set?, :file "rewrite_clj/zip/seq.clj", :line 27, :arglists ([zloc]), :type :var} {:name sexpr, :file "rewrite_clj/zip/base.clj", :line 46, :arglists ([zloc]), :doc "Get sexpr represented by the given node.\n", :type :var} {:name skip, :file "rewrite_clj/zip/whitespace.clj", :line 21, :arglists ([f p? zloc]), :doc "Perform the given movement while the given predicate returns true.\n", :type :var} {:name skip-whitespace, :file "rewrite_clj/zip/whitespace.clj", :line 30, :arglists ([zloc] [f zloc]), :doc "Perform the given movement (default: `z/right`) until a non-whitespace/\nnon-comment node is encountered.", :type :var} {:name skip-whitespace-left, :file "rewrite_clj/zip/whitespace.clj", :line 36, :arglists ([zloc]), :doc "Move left until a non-whitespace/non-comment node is encountered.\n", :type :var} {:name splice, :file "rewrite_clj/zip/edit.clj", :line 39, :arglists ([zloc]), :doc "Splice the given node, i.e. merge its children into the current one\n(akin to Clojure's `unquote-splicing` macro: `~@...`).\n\n- if the node is not one that can have children, no modification will\n  be performed.\n- if the node has no or only whitespace children, it will be removed.\n- otherwise, splicing will be performed, moving the zipper to the first\n  non-whitespace child afterwards.\n", :type :var} {:name string, :file "rewrite_clj/zip/base.clj", :line 83, :arglists ([zloc]), :doc "Create string representing the current zipper location.\n", :added "0.4.0", :type :var} {:name subedit->, :file "rewrite_clj/zip/subedit.clj", :line 73, :arglists ([zloc & body]), :doc "Like `->`, applying modifications to the current sub-tree, zipping\nup to the current location afterwards.", :type :macro} {:name subedit->>, :file "rewrite_clj/zip/subedit.clj", :line 79, :arglists ([zloc & body]), :doc "Like `->>`, applying modifications to the current sub-tree, zipping\nup to the current location afterwards.", :type :macro} {:name subedit-node, :file "rewrite_clj/zip/subedit.clj", :line 65, :arglists ([zloc f]), :doc "Apply the given function to the current sub-tree. The resulting\nzipper will be located on the root of the modified sub-tree.", :type :var} {:name suffix, :file "rewrite_clj/zip/edit.clj", :line 88, :arglists ([zloc s]), :type :var} {:name tag, :file "rewrite_clj/zip/base.clj", :line 41, :arglists ([zloc]), :doc "Get tag of node at the current zipper location.\n", :type :var} {:name up, :file "rewrite_clj/zip/move.clj", :line 21, :arglists ([zloc]), :doc "Move up to next non-whitespace/non-comment location.\n", :type :var} {:name up*, :file "rewrite_clj/zip.clj", :line 97, :arglists ([G__2655]), :doc "Directly call 'rewrite-clj.custom-zipper.core/up' on the given arguments.\n", :type :var} {:name value, :file "rewrite_clj/zip/base.clj", :line 61, :arglists ([zloc]), :doc "DEPRECATED. Return a tag/s-expression pair for inner nodes, or\nthe s-expression itself for leaves.", :deprecated "0.4.0", :type :var} {:name vector?, :file "rewrite_clj/zip/seq.clj", :line 23, :arglists ([zloc]), :type :var} {:name whitespace-or-comment?, :file "rewrite_clj/zip/whitespace.clj", :line 15, :arglists ([zloc]), :type :var} {:name whitespace?, :file "rewrite_clj/zip/whitespace.clj", :line 7, :arglists ([zloc]), :type :var})} {:no-doc true, :name rewrite-clj.zip.base, :publics ({:name child-sexprs, :file "rewrite_clj/zip/base.clj", :line 51, :arglists ([zloc]), :doc "Get children as s-expressions.\n", :added "0.4.4", :type :var} {:name edn, :file "rewrite_clj/zip/base.clj", :line 24, :arglists ([node] [node {:keys [track-position?], :as options}]), :doc "Create zipper over the given Clojure/EDN node and move to the first\nnon-whitespace/non-comment child.\n\nIf `:track-position?` is set, this will create a custom zipper that will\nreturn the current row/column using `rewrite-clj.zip/position`. (Note that\nthis custom zipper will be incompatible with `clojure.zip`'s functions.)", :type :var} {:name edn*, :file "rewrite_clj/zip/base.clj", :line 11, :arglists ([node] [node {:keys [track-position?]}]), :doc "Create zipper over the given Clojure/EDN node.\n\nIf `:track-position?` is set, this will create a custom zipper that will\nreturn the current row/column using `rewrite-clj.zip/position`. (Note that\nthis custom zipper will be incompatible with `clojure.zip`'s functions.)", :type :var} {:name length, :file "rewrite_clj/zip/base.clj", :line 56, :arglists ([zloc]), :doc "Get length of printable string for the given zipper location.\n", :type :var} {:name of-file, :file "rewrite_clj/zip/base.clj", :line 75, :arglists ([f] [f options]), :doc "Create zipper from File.\n", :type :var} {:name of-string, :file "rewrite_clj/zip/base.clj", :line 69, :arglists ([s] [s options]), :doc "Create zipper from String.\n", :type :var} {:name print, :file "rewrite_clj/zip/base.clj", :line 99, :arglists ([zloc & [writer]]), :doc "Print current zipper location.\n", :type :var} {:name print-root, :file "rewrite_clj/zip/base.clj", :line 106, :arglists ([zloc & [writer]]), :doc "Zip up and print root node.\n", :type :var} {:name root-string, :file "rewrite_clj/zip/base.clj", :line 88, :arglists ([zloc]), :doc "Create string representing the zipped-up zipper.\n", :added "0.4.0", :type :var} {:name sexpr, :file "rewrite_clj/zip/base.clj", :line 46, :arglists ([zloc]), :doc "Get sexpr represented by the given node.\n", :type :var} {:name string, :file "rewrite_clj/zip/base.clj", :line 83, :arglists ([zloc]), :doc "Create string representing the current zipper location.\n", :added "0.4.0", :type :var} {:name tag, :file "rewrite_clj/zip/base.clj", :line 41, :arglists ([zloc]), :doc "Get tag of node at the current zipper location.\n", :type :var} {:name value, :file "rewrite_clj/zip/base.clj", :line 61, :arglists ([zloc]), :doc "DEPRECATED. Return a tag/s-expression pair for inner nodes, or\nthe s-expression itself for leaves.", :deprecated "0.4.0", :type :var})} {:no-doc true, :name rewrite-clj.zip.edit, :publics ({:name edit, :file "rewrite_clj/zip/edit.clj", :line 30, :arglists ([zloc f & args]), :doc "Apply the given function to the s-expression at the given\nlocation, using its result to replace the node there. (The\nresult will be coerced to a node if possible.)", :type :var} {:name prefix, :file "rewrite_clj/zip/edit.clj", :line 78, :arglists ([zloc s]), :type :var} {:name replace, :file "rewrite_clj/zip/edit.clj", :line 15, :arglists ([zloc value]), :doc "Replace the node at the given location with one representing\nthe given value. (The value will be coerced to a node if\npossible.)", :type :var} {:name splice, :file "rewrite_clj/zip/edit.clj", :line 39, :arglists ([zloc]), :doc "Splice the given node, i.e. merge its children into the current one\n(akin to Clojure's `unquote-splicing` macro: `~@...`).\n\n- if the node is not one that can have children, no modification will\n  be performed.\n- if the node has no or only whitespace children, it will be removed.\n- otherwise, splicing will be performed, moving the zipper to the first\n  non-whitespace child afterwards.\n", :type :var} {:name suffix, :file "rewrite_clj/zip/edit.clj", :line 88, :arglists ([zloc s]), :type :var})} {:no-doc true, :name rewrite-clj.zip.find, :publics ({:name find, :file "rewrite_clj/zip/find.clj", :line 21, :arglists ([zloc p?] [zloc f p?]), :doc "Find node satisfying the given predicate by repeatedly\napplying the given movement function to the initial zipper\nlocation.", :type :var} {:name find-depth-first, :file "rewrite_clj/zip/find.clj", :line 35, :arglists ([zloc p?]), :doc "Find node satisfying the given predicate by traversing\nthe zipper in a depth-first way.", :type :var} {:name find-next, :file "rewrite_clj/zip/find.clj", :line 41, :arglists ([zloc p?] [zloc f p?]), :doc "Find node other than the current zipper location matching\nthe given predicate by applying the given movement function\nto the initial zipper location.", :type :var} {:name find-next-depth-first, :file "rewrite_clj/zip/find.clj", :line 50, :arglists ([zloc p?]), :doc "Find node other than the current zipper location matching\nthe given predicate by traversing the zipper in a\ndepth-first way.", :type :var} {:name find-next-tag, :file "rewrite_clj/zip/find.clj", :line 65, :arglists ([zloc t] [zloc f t]), :doc "Find node other than the current zipper location with the\ngiven tag by repeatedly applying the given movement function to\nthe initial zipper location.", :type :var} {:name find-next-token, :file "rewrite_clj/zip/find.clj", :line 85, :arglists ([zloc p?] [zloc f p?]), :doc "Find next token node matching the given predicate by applying the\ngiven movement function to the initial zipper location, defaulting\nto `right`.", :type :var} {:name find-next-value, :file "rewrite_clj/zip/find.clj", :line 106, :arglists ([zloc v] [zloc f v]), :doc "Find next token node whose value matches the given one by applying the\ngiven movement function to the initial zipper location, defaulting\nto `right`.", :type :var} {:name find-tag, :file "rewrite_clj/zip/find.clj", :line 57, :arglists ([zloc t] [zloc f t]), :doc "Find node with the given tag by repeatedly applying the given\nmovement function to the initial zipper location.", :type :var} {:name find-token, :file "rewrite_clj/zip/find.clj", :line 75, :arglists ([zloc p?] [zloc f p?]), :doc "Find token node matching the given predicate by applying the\ngiven movement function to the initial zipper location, defaulting\nto `right`.", :type :var} {:name find-value, :file "rewrite_clj/zip/find.clj", :line 94, :arglists ([zloc v] [zloc f v]), :doc "Find token node whose value matches the given one by applying the\ngiven movement function to the initial zipper location, defaulting\nto `right`.", :type :var})} {:no-doc true, :name rewrite-clj.zip.insert, :publics ({:name append-child, :file "rewrite_clj/zip/insert.clj", :line 52, :arglists ([zloc item]), :doc "Insert item as last child of the current node. Will insert a space if necessary.\n", :type :var} {:name insert-child, :file "rewrite_clj/zip/insert.clj", :line 43, :arglists ([zloc item]), :doc "Insert item as first child of the current node. Will insert a space if necessary.\n", :type :var} {:name insert-left, :file "rewrite_clj/zip/insert.clj", :line 34, :arglists ([zloc item]), :doc "Insert item to the right of the left location. Will insert a space if necessary.\n", :type :var} {:name insert-right, :file "rewrite_clj/zip/insert.clj", :line 25, :arglists ([zloc item]), :doc "Insert item to the right of the current location. Will insert a space if necessary.\n", :type :var})} {:no-doc true, :name rewrite-clj.zip.move, :publics ({:name down, :file "rewrite_clj/zip/move.clj", :line 16, :arglists ([zloc]), :doc "Move down to next non-whitespace/non-comment location.\n", :type :var} {:name end?, :file "rewrite_clj/zip/move.clj", :line 35, :arglists ([zloc]), :doc "Check whether the given node is at the end of the depth-first traversal.\n", :type :var} {:name left, :file "rewrite_clj/zip/move.clj", :line 11, :arglists ([zloc]), :doc "Move left to next non-whitespace/non-comment location.\n", :type :var} {:name leftmost, :file "rewrite_clj/zip/move.clj", :line 61, :arglists ([zloc]), :doc "Move to the leftmost non-whitespace/non-comment location.\n", :type :var} {:name leftmost?, :file "rewrite_clj/zip/move.clj", :line 48, :arglists ([zloc]), :doc "Check if the given location represents the leftmost non-whitespace/\nnon-comment one.", :type :var} {:name next, :file "rewrite_clj/zip/move.clj", :line 26, :arglists ([zloc]), :doc "Move to the next non-whitespace/non-comment location in a depth-first manner.\n", :type :var} {:name prev, :file "rewrite_clj/zip/move.clj", :line 54, :arglists ([zloc]), :doc "Move to the next non-whitespace/non-comment location in a depth-first manner.\n", :type :var} {:name right, :file "rewrite_clj/zip/move.clj", :line 6, :arglists ([zloc]), :doc "Move right to next non-whitespace/non-comment location.\n", :type :var} {:name rightmost, :file "rewrite_clj/zip/move.clj", :line 68, :arglists ([zloc]), :doc "Move to the rightmost non-whitespace/non-comment location.\n", :type :var} {:name rightmost?, :file "rewrite_clj/zip/move.clj", :line 42, :arglists ([zloc]), :doc "Check if the given location represents the leftmost non-whitespace/\nnon-comment one.", :type :var} {:name up, :file "rewrite_clj/zip/move.clj", :line 21, :arglists ([zloc]), :doc "Move up to next non-whitespace/non-comment location.\n", :type :var})} {:no-doc true, :name rewrite-clj.zip.remove, :publics ({:name remove, :file "rewrite_clj/zip/remove.clj", :line 20, :arglists ([zloc]), :doc "Remove value at the given zipper location. Returns the first non-whitespace\nnode that would have preceded it in a depth-first walk. Will remove whitespace\nappropriately.\n\n    [1  2  3]   => [1  3]\n    [1 2]       => [1]\n    [1 2]       => [2]\n    [1]         => []\n    [  1  ]     => []\n    [1 [2 3] 4] => [1 [2 3]]\n    [1 [2 3] 4] => [[2 3] 4]\n\nIf a node is located rightmost, both preceding and trailing spaces are removed,\notherwise only trailing spaces are touched. This means that a following element\n(no matter whether on the same line or not) will end up in the same position\n(line/column) as the removed one, _unless_ a comment lies between the original\nnode and the neighbour.", :type :var})} {:no-doc true, :name rewrite-clj.zip.seq, :publics ({:name assoc, :file "rewrite_clj/zip/seq.clj", :line 100, :arglists ([zloc k v]), :doc "Set map/seq element to the given value.\n", :type :var} {:name get, :file "rewrite_clj/zip/seq.clj", :line 88, :arglists ([zloc k]), :doc "If a map is given, get element with the given key; if a seq is given, get nth element.\n", :type :var} {:name list?, :file "rewrite_clj/zip/seq.clj", :line 19, :arglists ([zloc]), :type :var} {:name map, :file "rewrite_clj/zip/seq.clj", :line 77, :arglists ([f zloc]), :doc "Apply function to all value nodes in the given seq node. Iterates over\nvalue nodes of maps but over each element of a seq.", :type :var} {:name map-keys, :file "rewrite_clj/zip/seq.clj", :line 65, :arglists ([f zloc]), :doc "Apply function to all key nodes of the given map node.\n", :type :var} {:name map-vals, :file "rewrite_clj/zip/seq.clj", :line 51, :arglists ([f zloc]), :doc "Apply function to all value nodes of the given map node.\n", :type :var} {:name map?, :file "rewrite_clj/zip/seq.clj", :line 31, :arglists ([zloc]), :type :var} {:name seq?, :file "rewrite_clj/zip/seq.clj", :line 13, :arglists ([zloc]), :type :var} {:name set?, :file "rewrite_clj/zip/seq.clj", :line 27, :arglists ([zloc]), :type :var} {:name vector?, :file "rewrite_clj/zip/seq.clj", :line 23, :arglists ([zloc]), :type :var})} {:no-doc true, :name rewrite-clj.zip.subedit, :publics ({:name edit->, :file "rewrite_clj/zip/subedit.clj", :line 40, :arglists ([zloc & body]), :doc "Like `->`, applying the given function to the current zipper location.\nThe resulting zipper will be located at the same path (i.e. the same\nnumber of downwards and right movements from the root) as the original\nnode.", :type :macro} {:name edit->>, :file "rewrite_clj/zip/subedit.clj", :line 48, :arglists ([zloc & body]), :doc "Like `->>`, applying the given function to the current zipper location.\nThe resulting zipper will be located at the same path (i.e. the same\nnumber of downwards and right movements from the root) as the original\nnode.", :type :macro} {:name edit-node, :file "rewrite_clj/zip/subedit.clj", :line 31, :arglists ([zloc f]), :doc "Apply the given function to the current zipper location. The resulting\nzipper will be located at the same path (i.e. the same number of\ndownwards and right movements from the root) as the original node.", :type :var} {:name subedit->, :file "rewrite_clj/zip/subedit.clj", :line 73, :arglists ([zloc & body]), :doc "Like `->`, applying modifications to the current sub-tree, zipping\nup to the current location afterwards.", :type :macro} {:name subedit->>, :file "rewrite_clj/zip/subedit.clj", :line 79, :arglists ([zloc & body]), :doc "Like `->>`, applying modifications to the current sub-tree, zipping\nup to the current location afterwards.", :type :macro} {:name subedit-node, :file "rewrite_clj/zip/subedit.clj", :line 65, :arglists ([zloc f]), :doc "Apply the given function to the current sub-tree. The resulting\nzipper will be located on the root of the modified sub-tree.", :type :var} {:name subzip, :file "rewrite_clj/zip/subedit.clj", :line 58, :arglists ([zloc]), :doc "Create zipper whose root is the current node.\n", :type :var})} {:no-doc true, :name rewrite-clj.zip.walk, :publics ({:name postwalk, :file "rewrite_clj/zip/walk.clj", :line 37, :arglists ([zloc f] [zloc p? f]), :doc "Perform a depth-first post-order traversal starting at the given zipper location\nand apply the given function to each child node. If a predicate `p?` is given,\nonly apply the function to nodes matching it.", :added "0.4.9", :type :var} {:name postwalk-subtree, :file "rewrite_clj/zip/walk.clj", :line 27, :arglists ([p? f loc]), :type :var} {:name prewalk, :file "rewrite_clj/zip/walk.clj", :line 18, :arglists ([zloc f] [zloc p? f]), :doc "Perform a depth-first pre-order traversal starting at the given zipper location\nand apply the given function to each child node. If a predicate `p?` is given,\nonly apply the function to nodes matching it.", :type :var})} {:no-doc true, :name rewrite-clj.zip.whitespace, :publics ({:name append-newline, :file "rewrite_clj/zip/whitespace.clj", :line 101, :arglists ([zloc & [n]]), :doc "Append a newline node representing the given number of linebreaks (default:\n1).\n\nDEPRECATED: use 'insert-newline-right' instead.", :deprecated "0.5.0", :type :var} {:name append-space, :file "rewrite_clj/zip/whitespace.clj", :line 86, :arglists ([zloc & [n]]), :doc "Append a whitespace node representing the given number of spaces (default: 1).\n\nDEPRECATED: use 'insert-space-right' instead.", :deprecated "0.5.0", :type :var} {:name insert-newline-left, :file "rewrite_clj/zip/whitespace.clj", :line 63, :arglists ([zloc] [zloc n]), :doc "Insert a newline node before the given one, representing the given number of\nspaces (default: 1).", :added "0.5.0", :type :var} {:name insert-newline-right, :file "rewrite_clj/zip/whitespace.clj", :line 70, :arglists ([zloc] [zloc n]), :doc "Insert a newline node after the given one, representing the given number of\nlinebreaks (default: 1).", :added "0.5.0", :type :var} {:name insert-space-left, :file "rewrite_clj/zip/whitespace.clj", :line 43, :arglists ([zloc] [zloc n]), :doc "Insert a whitespace node before the given one, representing the given\nnumber of spaces (default: 1).", :added "0.5.0", :type :var} {:name insert-space-right, :file "rewrite_clj/zip/whitespace.clj", :line 53, :arglists ([zloc] [zloc n]), :doc "Insert a whitespace node after the given one, representing the given number\nof spaces (default: 1).", :added "0.5.0", :type :var} {:name linebreak?, :file "rewrite_clj/zip/whitespace.clj", :line 11, :arglists ([zloc]), :type :var} {:name prepend-newline, :file "rewrite_clj/zip/whitespace.clj", :line 93, :arglists ([zloc & [n]]), :doc "Prepend a newline node representing the given number of linebreaks (default:\n1).\n\nDEPRECATED: use 'insert-newline-left' instead.", :deprecated "0.5.0", :type :var} {:name prepend-space, :file "rewrite_clj/zip/whitespace.clj", :line 79, :arglists ([zloc & [n]]), :doc "Prepend a whitespace node representing the given number of spaces (default: 1).\n\nDEPRECATED: use 'insert-space-left' instead.", :deprecated "0.5.0", :type :var} {:name skip, :file "rewrite_clj/zip/whitespace.clj", :line 21, :arglists ([f p? zloc]), :doc "Perform the given movement while the given predicate returns true.\n", :type :var} {:name skip-whitespace, :file "rewrite_clj/zip/whitespace.clj", :line 30, :arglists ([zloc] [f zloc]), :doc "Perform the given movement (default: `z/right`) until a non-whitespace/\nnon-comment node is encountered.", :type :var} {:name skip-whitespace-left, :file "rewrite_clj/zip/whitespace.clj", :line 36, :arglists ([zloc]), :doc "Move left until a non-whitespace/non-comment node is encountered.\n", :type :var} {:name whitespace-or-comment?, :file "rewrite_clj/zip/whitespace.clj", :line 15, :arglists ([zloc]), :type :var} {:name whitespace?, :file "rewrite_clj/zip/whitespace.clj", :line 7, :arglists ([zloc]), :type :var})})}, :pom-str "<?xml version=\"1.0\" encoding=\"UTF-8\"?><project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n  <groupId>rewrite-clj</groupId>\n  <artifactId>rewrite-clj</artifactId>\n  <packaging>jar</packaging>\n  <version>0.6.1</version>\n  <name>rewrite-clj</name>\n  <description>Comment-/Whitespace-preserving rewriting of EDN documents.</description>\n  <url>https://github.com/xsc/rewrite-clj</url>\n  <licenses>\n    <license>\n      <name>MIT License</name>\n      <url>https://opensource.org/licenses/MIT</url>\n    </license>\n  </licenses>\n  <scm>\n    <url>https://github.com/xsc/rewrite-clj</url>\n    <connection>scm:git:git://github.com/xsc/rewrite-clj.git</connection>\n    <developerConnection>scm:git:ssh://git@github.com/xsc/rewrite-clj.git</developerConnection>\n    <tag>6b359d62ec5bad7d4afe848cd15d116b542c4212</tag>\n  </scm>\n  <build>\n    <sourceDirectory>src</sourceDirectory>\n    <testSourceDirectory>test</testSourceDirectory>\n    <resources>\n      <resource>\n        <directory>resources</directory>\n      </resource>\n    </resources>\n    <testResources>\n      <testResource>\n        <directory>resources</directory>\n      </testResource>\n    </testResources>\n    <directory>target</directory>\n    <outputDirectory>target/classes</outputDirectory>\n    <plugins/>\n  </build>\n  <repositories>\n    <repository>\n      <id>central</id>\n      <url>https://repo1.maven.org/maven2/</url>\n      <snapshots>\n        <enabled>false</enabled>\n      </snapshots>\n      <releases>\n        <enabled>true</enabled>\n      </releases>\n    </repository>\n    <repository>\n      <id>clojars</id>\n      <url>https://repo.clojars.org/</url>\n      <snapshots>\n        <enabled>true</enabled>\n      </snapshots>\n      <releases>\n        <enabled>true</enabled>\n      </releases>\n    </repository>\n    <repository>\n      <id>sonatype-oss-public</id>\n      <url>https://oss.sonatype.org/content/groups/public/</url>\n      <snapshots>\n        <enabled>true</enabled>\n      </snapshots>\n      <releases>\n        <enabled>true</enabled>\n      </releases>\n    </repository>\n  </repositories>\n  <dependencyManagement>\n    <dependencies/>\n  </dependencyManagement>\n  <dependencies>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>clojure</artifactId>\n      <version>1.9.0</version>\n      <exclusions>\n        <exclusion>\n          <artifactId>clojure</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n      </exclusions>\n      <scope>provided</scope>\n    </dependency>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>tools.reader</artifactId>\n      <version>1.2.2</version>\n      <exclusions>\n        <exclusion>\n          <artifactId>clojure</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n      </exclusions>\n    </dependency>\n    <dependency>\n      <groupId>org.clojure</groupId>\n      <artifactId>test.check</artifactId>\n      <version>0.7.0</version>\n      <exclusions>\n        <exclusion>\n          <artifactId>clojure</artifactId>\n          <groupId>org.clojure</groupId>\n        </exclusion>\n      </exclusions>\n      <scope>test</scope>\n    </dependency>\n  </dependencies>\n</project>\n\n<!-- This file was autogenerated by Leiningen.\n  Please do not edit it directly; instead edit project.clj and regenerate it.\n  It should not be considered canonical data. For more information see\n  https://github.com/technomancy/leiningen -->\n"}